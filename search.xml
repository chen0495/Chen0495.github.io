<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客换主题啦~</title>
      <link href="/posts/25ac6164/"/>
      <url>/posts/25ac6164/</url>
      
        <content type="html"><![CDATA[<h1>正文</h1><p>原博客使用 <a href="https://hexo.fluid-dev.com/docs/">Fluid主题</a> 因为实现说说功能比较麻烦，折腾半天不够满意，故干脆更换主题为 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 。</p><p>安装及配置比较简单,跟着教程 <a href="https://butterfly.js.org/">Butterfly - Jerry</a> 做就行了。</p><p>注意几个坑点：</p><ul><li>全局背景图片链接要严格按照格式输入，不能直接输入图片地址，要加上<code>url()</code>。<img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207280029709.png" alt=""></li><li>网站底部信息背景的配置在<code>footer_bg</code>,推荐和全局背景相同，直接<code>true</code>会与文章的头图相同。</li></ul><h1>效果展示</h1><p><font size=4 color=red>下面是本人博客效果展示</font>：</p><div class="fj-gallery"><p><img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207280021667.png" alt="封面"><br><img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207280022229.png" alt="主页"><br><img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207280023240.png" alt="留言板"><br><img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207280023789.png" alt="说说"><br><img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207280024163.png" alt="友链"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGA论坛IP数据分析</title>
      <link href="/posts/764c611d/"/>
      <url>/posts/764c611d/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>NGA论坛刚刚开放了用户IP显示功能，早就想查查泥潭精英充分的我连夜花费数个小时写了个IP爬虫出来，看看都是哪些人在泥潭大漩涡板块活跃</p><h1>爬虫</h1><h2 id="包与headers">包与headers</h2><p>首先是配置headers：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="comment"># 在浏览器中，network查看</span></span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Safari/537.36 Edg/103.0.1264.62&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># API文档参考 https://github.com/wolfcon/NGA-API-Documents</span></span><br></pre></td></tr></table></figure><h2 id="版面页">版面页</h2><p>然后是从网事杂谈板块前几页的爬取到各个帖子的链接(API接口参数可查看<a href="https://github.com/wolfcon/NGA-API-Documents">文档</a>)<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/202207211536431.png" alt=""><br>F12查找到对应元素(不准确，需要自行修改)方便抓取链接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">urls = []  <span class="comment"># 保存页面uid</span></span><br><span class="line">limit = <span class="number">5</span>  <span class="comment"># 版面页数，请勿设置过多</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,limit+<span class="number">1</span>):  <span class="comment"># 获取近期网事杂谈板块回复前limit页中的帖子地址</span></span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">1</span>) </span><br><span class="line">    </span><br><span class="line">    mainPage = req.get(<span class="string">&#x27;https://bbs.nga.cn/thread.php?fid=-7&amp;order_by=lastpostdesc&amp;page=&#x27;</span>+<span class="built_in">str</span>(i),headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">    doc = etree.HTML(mainPage.text)</span><br><span class="line">    pages_url = doc.xpath(<span class="string">&#x27;//td[@class=&quot;c1&quot;]/a&#x27;</span>)  <span class="comment"># 查找对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pg <span class="keyword">in</span> pages_url:</span><br><span class="line">        r = re.search(<span class="string">r&#x27;[0-9]+&#x27;</span>,pg.attrib[<span class="string">&#x27;href&#x27;</span>]).group()   <span class="comment"># 帖子uid</span></span><br><span class="line">        urls.append(r)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;no.&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27; : &#x27;</span>+<span class="built_in">str</span>(r))</span><br></pre></td></tr></table></figure><p>之后对抓取到的主题贴进行去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urls = <span class="built_in">set</span>(urls) <span class="comment"># 帖子去重,注意此处顺序被打乱</span></span><br><span class="line">urls = <span class="built_in">list</span>(urls)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(urls))</span><br></pre></td></tr></table></figure><h2 id="主题页">主题页</h2><p>之后获取到主题贴第一页(默认)的内容，找到对应结果计算帖子页数，并获取到每页的用户uid, 用户uid可去重可不去重。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/202207211545161.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">uid = [] </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span>  urls:  <span class="comment"># 帖子中用户uid获取</span></span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    page_url = <span class="string">&#x27;https://bbs.nga.cn/read.php?tid=&#x27;</span>+<span class="built_in">str</span>(item)+<span class="string">&#x27;&amp;lite=js&#x27;</span>         <span class="comment"># 获取当前帖子页数</span></span><br><span class="line">    mainPage = req.get(page_url,headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">    txt = <span class="built_in">str</span>(mainPage.text).replace(<span class="string">&#x27;window.script_muti_get_var_store=&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    Rows = re.findall(<span class="string">r&#x27;&quot;__ROWS&quot;\:[0-9]+&#x27;</span>,txt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> Rows:        <span class="comment"># nga一小部分帖子js只传一半</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">    pageNum = <span class="built_in">int</span>(<span class="built_in">int</span>(Rows[<span class="number">0</span>].replace(<span class="string">&#x27;&quot;__ROWS&quot;:&#x27;</span>,<span class="string">&#x27;&#x27;</span>))/<span class="number">20</span> + <span class="number">1</span>)  <span class="comment"># 当前帖子页数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(item)+<span class="string">&quot; pages: &quot;</span>+<span class="built_in">str</span>(pageNum))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pageNum&gt;<span class="number">100</span>:  <span class="comment">#去除超过100页的帖子</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,pageNum+<span class="number">1</span>):       <span class="comment"># 用户uid获取</span></span><br><span class="line">        u = page_url+<span class="string">&#x27;&amp;page=&#x27;</span>+<span class="built_in">str</span>(i)</span><br><span class="line">        mainPage = req.get(u,headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">        txt = <span class="built_in">str</span>(mainPage.text).replace(<span class="string">&#x27;window.script_muti_get_var_store=&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        tmp = re.findall(<span class="string">r&#x27;&quot;uid&quot;\:[0-9]+&#x27;</span>,txt)</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tmp:</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>):</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i = t.replace(<span class="string">&#x27;&quot;uid&quot;:&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            uid.append(i)</span><br></pre></td></tr></table></figure><h2 id="用户IP获取">用户IP获取</h2><p>通过uid查到用户信息，并筛出ipLoc数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://bbs.nga.cn/nuke.php?lite=js&amp;__lib=ucp&amp;__act=get&amp;uid=&#x27;</span>  <span class="comment"># 用户IP查询</span></span><br><span class="line">ips = [] <span class="comment"># 保存ip</span></span><br><span class="line">nums = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> uid:</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    person_page_url = url + person</span><br><span class="line">    mainPage = req.get(person_page_url,headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">    txt = <span class="built_in">str</span>(mainPage.text).replace(<span class="string">&#x27;window.script_muti_get_var_store=&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    tmp = re.findall(<span class="string">r&#x27;&quot;ipLoc&quot;\:&quot;[\u4e00-\u9fa5]+&#x27;</span>,txt) <span class="comment"># 正则查找</span></span><br><span class="line">    <span class="keyword">if</span> tmp:  <span class="comment"># nga有概率js只传一半</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    tmp = tmp[<span class="number">0</span>].replace(<span class="string">&#x27;&quot;ipLoc&quot;:&quot;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    ips.append(tmp)</span><br><span class="line">    <span class="built_in">print</span>(nums,tmp)  <span class="comment"># 输出当前位置，方便网络中断后继续运行</span></span><br><span class="line">    nums = nums+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;.\\area.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment"># 写入文件保存</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ips:</span><br><span class="line">        f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="结果处理">结果处理</h2><p>对结果进行相应处理，作图。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/202207211551039.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/202207211551059.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> NGA </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【公告】</title>
      <link href="/posts/26c1dbaf/"/>
      <url>/posts/26c1dbaf/</url>
      
        <content type="html"><![CDATA[<div class="note danger flat"><h1>最新公告 - 7/27/2022</h1><p>原主题实现一些功能过于麻烦，故更换博客主题为<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></p></div><hr><div class="note secondary flat"><h1>以往公告</h1><h2 id="7-27-2022">7/27/2022</h2><p>jsDelivr被墙，<a href="http://xn--360lib-vy7ih2z7x2aj9ah2e78j03d87qie64rl47aia5821d0v8dti0b.baomitu.com">所有样式源替换为360前端静态资源库lib.baomitu.com</a>。</p><h2 id="7-26-2022">7/26/2022</h2><p>评论区系统默认头像更新、添加IP显示功能。</p><h2 id="7-25-2022">7/25/2022</h2><p>支持评论区系统。</p></div>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
          <category> 公告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 公告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git连接Coding坑点</title>
      <link href="/posts/29f2c3fc/"/>
      <url>/posts/29f2c3fc/</url>
      
        <content type="html"><![CDATA[<h1>问题</h1><p>电脑重装，恢复博客备份时出现问题，连接不到Coding，原因应该是多密钥冲突，<strong>错误信息</strong>：<code>git@git.coding.net: Permission denied (publickey)</code><br>记录下解决办法，同时对以前文章<a href="https://chen0495.top/posts/87a809ba/">双线部署你的个人博客</a> 打下补丁。</p><h1>解决</h1><p>参考: <a href="https://blog.csdn.net/yigehui12/article/details/89333264">windows下同一主机多个git ssh秘钥配置（码云 github coding）解决主机用户为中文配置不成功的问题</a><br><strong>但要注意！！！</strong>，生成密钥时不能参照网上的博客，要查阅<a href="https://help.coding.net/docs/repo/ssh/config.html">官方文档</a>，如下：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/20220405171337.png" alt="coding官方文档"><br>即要使用Ed25519算法生成的密钥对以避免冲突：<code>ssh-keygen -m PEM -t ed25519 -C &quot;your.email@example.com&quot;</code><br>出现以下信息即成功：<img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/20220405171813.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>肖四背诵汇总</title>
      <link href="/posts/a74bb55f/"/>
      <url>/posts/a74bb55f/</url>
      
        <content type="html"><![CDATA[<h1>马原</h1><h2 id="第一套">第一套</h2><ul><li>人与自然的辩证关系(2前提,2基础,2方面)<ol><li>自然是人类社会构成的前提,是人类社会客观现实性的基础</li><li>人的实践是物质世界分化为自然界和人类社会的历史前提,是两者统一的基础</li><li>一方面,人具有主观能动性;另一方面,自然规律对人的实践存在制约作用</li></ol></li><li>自然地理环境<ol><li>⾃然地理环境提供了社会⽣活和⽣产资料的来源；</li><li>⾃然地理环境的优劣对社会发展起促进或延缓的作⽤。</li></ol></li><li>唯物辩证法中联系的原理<ol><li>世界的物质统一性是多样性的统一</li><li>唯物辩证法认为，世界上的万事万物处于普遍联系之中。<br>联系具有客观性，事物的联系是事物本身所固有的；<br>联系具有普遍性，任何事物都同其他事物处于一定的联系之中；<br>联系具有多样性，世界上的事物是多样的，事物之间的联系也是多样的</li></ol></li></ul><h2 id="第二套">第二套</h2><ul><li>人民群众是历史的创造者<ol><li>在社会历史发展过程中，人民群众起着决定性的作用，人民群众是社会历史实践的主体，是历史的创造者。</li><li>人民群众是社会物质财富的创造者，人民群众是社会精神财富的创造者，人民群众是社会变革的决定力量。</li><li>唯物史观要求我们坚持全心全意为人民服务的马克思主义群众观点，贯彻党的群众路线，即一切为了群众，一切依靠群众，从群众中来，到群众中去。</li></ol></li><li>历史思维<ol><li>是辩证思维与历史眼光的结合</li><li>是马克思主义科学历史观的表现和运用</li><li>作用、好处、怎么做</li></ol></li><li>历史虚无主义（怎么评价历史人物）<ol><li>唯物史观主张，评价历史人物时应该坚持<strong>历史分析方法</strong>和<strong>阶级分析方法</strong></li><li>历史分析方法要求从特定的历史背景出发、根据当时的历史条件，对历史人物的是非功过进行具体的、全面的考察。</li><li>阶级分析方法要求把历史人物置于一定的阶级关系中，同他们所属的阶级联系起来加以考察和评价</li></ol></li></ul><h2 id="第三套">第三套</h2><ul><li>实践与认识<ol><li>实践是认识的基础。实践是认识的来源；实践是认识发展的动⼒；实践是认识的⽬的；实践是检验认识真理性的唯⼀标准。</li><li>认识具有反复性和无限性，从实践到认识、从认识到实践，实践、认识、再实践、再认识，认识运动不断反复和⽆限发展。</li><li>（总结）在实践和认识的辩证运动中，主观必须统⼀于客观，认识必须统⼀于实践。</li></ol></li><li>唯物辩证法中联系的原理（重复）</li><li>矛盾普遍性和特殊性<ol><li>矛盾具有普遍性，矛盾的普遍性即矛盾的共性是绝对的、无条件的；</li><li>矛盾具有特殊性，矛盾的特殊性即矛盾的个性是相对的、有条件的；</li><li>共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。总结：具体问题具体分析，不同方法解决不同矛盾</li></ol></li></ul><h2 id="第四套">第四套</h2><ul><li>实践与认识（重复）</li><li>重视实践（用第一问中部分展开即可）</li><li>认识的两大因素<ul><li>认识具有理性因素，在认识活动中具有指导、解释和预见作用</li><li>认识具有非理性因素，在认识活动中具有激活、驱动和控制作用</li></ul></li></ul><h1>毛中特</h1><h2 id="第一套-2">第一套</h2><ul><li>共同富裕<ol><li>共同富裕时社会主义本质要求，是社会主义制度优越性的体现。</li><li>共同富裕是党为人民…的初心和使命。</li><li>打赢脱贫攻坚战，全面建成小康社会，实现第一个百年奋斗目标已经为共同富裕创造了良好的条件，但也要看到发展不平衡不充分、城乡差距问题。</li><li>共同富裕是高质量发展的需要。</li></ol></li><li>高质量发展促进共同富裕<ol><li>要在⾼质量发展中促进共同富裕，这指明了共同富裕的实现途径和努⼒⽅向。</li><li>第一，发展是实现人民幸福的关键。</li><li>第二，⾼质量发展是能够很好满⾜⼈⺠⽇益增⻓的美好⽣活需要的发展，是体现新发展理念的发展（此处无材料就背新发展理念）。</li></ol></li><li>怎么实现共同富裕<ol><li>推动共同富裕，我们要构建初次分配、再分配、三次分配协调配套的基础性度安排。</li><li>⾼收⼊-规范调节；中收⼊-扩⼤；低收⼊-增加收⼊。</li><li>要形成中间⼤、两头⼩的橄榄型分配结构；促进社会公平正义；促进⼈的全⾯发展；最终实现全体⼈⺠共同富裕。</li></ol></li></ul><h2 id="第二套-2">第二套</h2><ul><li>新发展阶段<ol><li>历史⽅位,是指⼀个国家、⼀个⺠族在历史发展进程中所处的位置。⼀个国家的进步,只有从历史发展的坐标上去认识,才能更加准确。</li><li>全⾯建成⼩康社会、实现第⼀个百年奋⽃⽬标之后，我国进⼊了开启全⾯建设社会主义现代化国家新征程、向第⼆个百年奋⽃⽬标进军的新发展阶段。</li><li>马克思主义认为：发展社会主义不仅是⼀个⻓期历史过程，⽽且是需要划分为不同历史阶段的过程，而我们已经拥有实现新的更⾼⽬标的雄厚物质基础。新发展阶段是社会主义初级阶段中的⼀个新的阶段，是我们党带领⼈⺠迎来从站起来、富起来到强起来历史性跨越的新阶段。</li></ol></li><li>新发展格局<ol><li>第一，从发展进程来看，改革开放特别是加入WTO之后，我国深度参与国际分工合作，形成市场和资源两头在外的发展格局。十八大以来，基于对国内外形势的判断，党提出供给侧结构性改革，坚持实施扩大内需战略。</li><li>第二，从发展条件来看，国内经济循环同国际经济循环的关系客观上早有调整的要求</li><li>第三，从外部环境来看，疫情影响深远，逆全球化趋势加剧，保护主义、单边主义、霸权主义对世界和平发展构成威胁，我们要立足国内，依托国内市场优势，化解外部冲击带来的影响。</li></ol></li><li>创新<ol><li>当前，我国经济发展环境出现了变化，科学技术的重要性全⾯上升，我们必须更加强调⾃主创新。</li><li>创新是引领发展的第⼀动⼒。</li><li>科学技术是第一生产力。</li><li>（国际环境）当今世界正经历百年未有之⼤变局…要应对这些⻛险挑战⾼⽔平科技⾃⽴⾃强是关键。</li></ol></li></ul><h2 id="第三套-2">第三套</h2><ul><li>新发展理念<ol><li>⼀定的发展实践都是由⼀定的发展理念来引领的。发展理念是否对头，从根本上决定着发展成效乃⾄成败。</li><li>第⼆，新发展理念的根”和“魂”是为⼈⺠谋幸福、为⺠族谋复兴，这也是我们党领导现代化建设的出发点和落脚点。</li><li>（国际环境）当今世界正经历百年未有之⼤变局…应对这些⻛险挑战就要坚持新发展理念</li></ol></li><li>进⼊新发展阶段、贯彻新发展理念、构建新发展格局三者关联（考察概率不大）</li><li>习中特思想飞跃<ol><li>习近平新时代中国特⾊社会主义思想深深植根于中华⽂化的沃⼟之中，凝结着中国⼈⺠的伟⼤创造精神、伟⼤奋⽃精神、伟⼤团结精神、伟⼤梦想精神</li><li>马克思主义（中国化、结合、飞跃）展开</li></ol></li></ul><h2 id="第四套-2">第四套</h2><ul><li>全过程⼈⺠⺠主<ol><li>我国全过程⼈⺠⺠主是⼀个完整的制度链条，包括包括选举⺠主、协商⺠主、社会⺠主、基层⺠主、公⺠⺠主等⺠主政治的全部要素；涵盖了⺠主选举、⺠主协商、⺠主决策、⺠主管理、⺠主监督等⺠主过程的⼀切领域，不仅有完整的制度程序，⽽且有完整的参与实践，这是最⼴泛、最真实、最管⽤的社会主义⺠主（公鸡会举鞋，坚决管举鞋）</li></ol></li><li>⼈⺠代表⼤会制度<ol><li>⼈⺠代表⼤会制度将⺠主选举、⺠主协商、⺠主决策、⺠主管理、⺠主监督融会贯通。（坚决管举鞋）通过⻓期探索、实践和发展，⼈⼤的各个方面都形成了⼀套体现全过程⼈⺠⺠主要求的理念原则和制度安排。</li><li>我们应该⽀持和保障⼈⼤代表在全过程⼈⺠⺠主中发挥作⽤。</li></ol></li><li>人民至上，党的初心和使命<ol><li>党的初⼼和使命是党的性质宗旨、理想信念、奋⽃⽬标的集中体现</li><li>我们党能够在那么弱⼩的情况下发展壮⼤起来，能够在千难万险中⼀次次浴⽕重⽣，根本原因就在于我们党始终牢记初⼼使命。</li><li>越是⻓期执政，越不能丢掉⻢克思主义政党的本⾊，越不能忘记党的初⼼使命，越不能丧失⾃我⾰命精神。</li><li>忘记这个初⼼和使命，党就会改变性质、改变颜⾊，就会失去⼈⺠、失去未来。</li></ol></li></ul><h1>史纲</h1><h2 id="第一套-3">第一套</h2><ul><li>党的功绩<ol><li>中国共产党始终不忘初心和使命，坚定不渝的为中国人民谋幸福，为中华民族谋复兴。</li><li>创造四个伟大成就。中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入不可逆转的历史进程。</li></ol></li><li>党的打算<ul><li>全面建成小康社会、实现第一个百年奋斗目标为我国进入全面建设社会主义现代化强国、向第二个百年奋斗目标进军奠定了基础。我们还需要继续担当历史使命，奋勇前进。</li><li>（我们怎么做）我们必须坚持和加强党的全面领导；在新时代坚持和发展中国特色社会主义；保持革命精神和革命斗志；同舟共济，团结战胜一切艰难险阻；高举人类命运共同体旗帜，为人类做出更大贡献。</li></ul></li><li>第三次历史决议<ol><li>党的第一、二个历史决议，实事求是总结了党的重大历史事件和重要经验教训，在重大历史关头统一了全党思想和行动</li><li>现在，距离第二个历史决议的制定已经过去了40年，党和国家的事业大大向前发展了。</li><li>同时，第三次历史决议是增强“四个意识”，坚定“四个自信”，做到“两个维护”，确保全党步调一致前进的需要；是全面建设社会主义现代化国家新征程、在新时代坚持和发展中特的需要</li></ol></li><li>两个确立<ol><li>确立了习近平同志党中央的核心，全党的的核心地位；确立了习近平新时代中国特色社会主义思想的指导地位。</li><li>强的领导核心和科学的理论指导，是关乎党和国家前途命运、党和人民事业成败的根本性问题。</li><li>我们要把“两个确立”真正转化为做到“两个维护”的思想政治自觉。</li></ol></li></ul><h2 id="第二套-3">第二套</h2><ul><li>辛亥革命（如果是纯辛亥答下面的，如果是为了引出党就是其它题，只在材料提一嘴）<ol><li>辛亥革命推翻了清朝政府，结束了中国几千年的封建君主专制制度，极大促进了中华民族的思想解放，民主共和的理念深入人心…材料…</li><li>辛亥革命没能改变中国半殖民地半封建社会的性质和中国人民的悲惨命运，革命胜利的果实被窃取，中国迫切需要新的思想引领救亡运动。</li></ol></li><li>中共诞生+伟大复兴<br>1.①在中国人民和中华民族的伟大觉醒中，在马克思列宁主义同中国工人运动的紧密结合中，中国共产党应运而生。②中国产生了共产党，这是开天辟地的大事件，中国人民有了主心骨、中国革命的面貌焕然一新。③从此，中国共产党带领人民进行的一切奋斗、牺牲、创造，归根结底就是一个主题：实现中华民族伟大复兴。<br>2. 可用第一套党的功绩回答</li><li>中共+伟大复兴<ol><li>可用第一套党的功绩回答</li></ol></li></ul><h2 id="第三套-3">第三套</h2><ul><li>中共诞生+百年奋斗<ol><li>第二套：中共诞生+伟大复兴</li></ol></li><li>中华民族伟大复兴进入了不可逆转的历史进程<ol><li>中华民族迎来了从站起来、富起来到强起来的伟大飞跃实现中华民族伟大复兴进入不可逆转的历史进程体现在：中华民族伟大复兴有了更坚强的领导核心、更强大的中国力量、更成熟的理论指导、更完善的制度保障、更雄厚的物质基础、更主动的精神力量。（党国、理论制度、物质精神）</li></ol></li><li>马克思和中国：<ol><li>马克思主义深刻改变了中国、十月革命一声炮响，把马克思主义送来中国，为正苦苦追寻救国道路的中国前进分子指明了方向，中国共产党应运而生。中国共产党之所以能够带领人民取得四个伟大成就，归根结底在于始终坚持把马克思主义作为行动指南…材料…</li><li>中国社会历史实践也极大丰富了马克思主义。马克思主义中国化、时代化不断取得成功，不断开辟马克思主义新境界，实现了马克思主义中国化的第三次飞跃。</li></ol></li></ul><h2 id="第四套-3">第四套</h2><ul><li>全面从严治党/自我革命精神<ol><li>自我革命是我们党最鲜明的品格，是我们党最大的优势，也是中国共产党区别于其他政党的显著标志。</li><li>全面从严治党。第一，是由全面从严治党在党和国家事业发展中的根本性作用决定的；第二是深入解决党内突出矛盾和问题的需要；第三，这是有效应对“四大考验”和“四大危险”的必然选择。</li></ol></li><li>保证新征程的稳定：<ol><li>随便答，党+国家+个人即可</li></ol></li><li>伟大建党精神<ol><li>伟大建党精神是中国共产党的精神之源。展现了中国共产党人崇高的精神风范；集中体现了党的优良作风；凝聚了中国共产党人的伟大品格；丰富了中国精神的内涵。</li><li>伟大建党精神实际作用（保持党的先进性、党发展的强大动力…）</li></ol></li></ul><h1>思修</h1><h2 id="第一套-4">第一套</h2><ul><li>红色血脉、伟大建党精神<ol><li>红色资源是我党百年艰辛奋斗历程的见证，是我党宝贵的精神财富；红色血脉是我党政治本色的集中体现，是新时代中国共产党人的精神力量源泉。</li><li>伟大建党精神是中国共产党的精神之源。</li><li>回望过往历程，眺望前方征程，我们必须始址延续红色血脉；用党的奋斗历程和伟大成就鼓舞斗志、指引方向；用党的光荣传统和优良作风坚定信念、凝聚力量；用党的历史经验和实践创造启迪智慧，砥砺品格。<ul><li><code>用历程和成就鼓舞、指引；用传统和作风坚定、凝聚；用经验和实践启迪、砥砺</code></li></ul></li></ol></li><li>新青年做什么<ul><li>坚定信念、树立对马克思主义的信仰和中华民族伟大复兴的信心，做有志⽓的新时代青年。结合材料论述如何坚定理想信念</li><li>要勇立潮头、争做先锋、甘于担当，做有⻣⽓的新时代青年；结合材料论述如何敢于担当</li><li>坚定“四个自信”，做有底⽓的新时代青年；结合材料论述如何有底⽓</li></ul></li><li>历史虚无主义<ul><li>历史虚无主义的本质，就是以所谓“重新评价”之名，歪曲中国近现代革命历史。其根本目的就是要搞乱人心。</li><li>抛弃传统、丢弃根本，无异于割断了自己的精神命脉。一个有希望的民族不能没有英雄，一个有前途的国家不能没有先锋。</li></ul></li></ul><h2 id="第二套-4">第二套</h2><ul><li>XXX等英雄事迹对我们人生的启示<ul><li>XXX事迹描述，体现了“服务⼈⺠、奉献社会”的⾼尚品质和崇⾼精神，他们的事迹启迪了我们：</li><li>”服务⼈⺠、奉献社会“代表了人类社会迄今为止最先进的人生追求。</li><li>在今天，衡量人生价值最重要的的标准就是看一个人是否为国家和社会真诚奉献、为人民群众尽心尽力服务</li><li>新时代大学生应该坚定信念、争做先锋、坚定“四个自信”，做有志气、有骨气、有底气的新时代青年。</li></ul></li><li>能否躺平？<ol><li>没有积极进取的人生态度，再崇高的人生追求也难以实现；</li><li>幸福都是奋斗出来的，一切伟大成就都是不断奋斗的结果；</li><li>当代大学生怎么做？</li></ol></li><li>如何实现理想？<ol><li>首先，要正确认识理想和现实的关系，不能脱离现实来谈理想，也不能用现实否定理想；</li><li>其次，要充分认识理想的长期性、艰巨性和曲折性，不能惧难而退；</li><li>最后要，通过在实践中的艰苦奋斗，逐步将理想变为现实。</li></ol></li></ul><h2 id="第三套-4">第三套</h2><ul><li>新时代中国⻘年为什么要坚定信仰、信念、信心<ul><li>理想信念是精神之“钙”，是人生发展的内在动力，它昭示奋斗目标、催生前进动力、提供精神支柱、提高精神境界</li><li>新时代青年怎么做。</li></ul></li><li>爱国主义<ul><li>爱国，是人世间最深层次、最持久的情感；</li><li>爱国主义是中华民族精神的核心。爱国是每个人都应当自觉履行的责任和义务，是对祖国的报答；</li><li>培养社会注意建设者和接班人，⾸先要培养⻘少年的爱国情怀，要把爱国主义教育作为永恒主题。</li></ul></li><li>爱国、爱党、爱社会主义相统一<ul><li>新中国是中国共产党领导的社会主义国家，祖国的命运与党的命运、社会主义的命运密不可分</li><li>坚定拥护中国共产党的领导，坚持中国特色社会主义事业，是中华民族伟大复兴的必然要求</li><li>（怎么爱国）一方面，我们要做好自己的本职工作，做好每一件平凡的事，从小事做起，用实际行动来表达自己的爱国情怀；另一方面，要献身于建设中国特色社会主义事业中，献身于实现中华民族伟大复兴中国梦的实践中。</li></ul></li></ul><h2 id="第四套-4">第四套</h2><ul><li>治理网络环境<ul><li>网络不是法外之地，要依法治理网络空间，维护社会和谐。</li><li>⽹络空间也是公共领域，公共⽣活需要公共秩序，有序的公共生活是社会生产活动的重要基础，是社会文明的重要标志。</li></ul></li><li>如何治理网络<ul><li>网络空间的治理与国家治理有相通之处，既要依靠法治，也要依靠德治。</li><li>要强化道德对法制的支撑作用</li><li>要运用法制手段解决道德领域的突出问题</li></ul></li><li>任何遵守⽹络⽣活中的道德要求，成为营造清朗的⽹络空间的正能量？<ul><li>第一，正确使用网络工具，网络不是法外之地。</li><li>第二，加强网络文明⾃律。</li><li>第三，营造良好网络道德环境。</li></ul></li></ul><h1>时政</h1><h2 id="第一套-5">第一套</h2><ul><li>有选择的多边主义<ul><li>多边主义的要义是国际上的事大家商量着办,世界的前途和命运由各国共同掌握.而有选择的多边主义是以我划线,本质上是单边主义.</li><li>要践行多边主义,就要秉持人类命运共同体理念,坚持和平发展、公平正义、民主自由的人类共同价值，摆脱意识形态偏见，最大程度上增强合作机制的开放性和包容性。共同维护世界和平稳定，才是真正践行多边主义</li></ul></li><li>怎样践行多边主义<ul><li>维护以联合国为核心的国际体系、以国际法为基础的国际秩序、以联和国宪章宗旨和原则为基础的国际关系基本准则</li><li>要致力于维护国际秩序，提高发展中国家在国际事务中的代表性和发言权，在推动国际关系民主化和法治化方面走在前列</li><li>要平衡和稳定安全、发展、人权三大领域工作，聚焦突出问题，重在采取行动，把多边主义落到实处。</li></ul></li><li>中美关系<ul><li>中、美分别是最⼤的发展中国家和最⼤的发达国家，是世界第⼀和第⼆⼤经济体。</li><li>中美合则两利，⽃则俱伤，⼀个健康稳定的中美关系不仅符合双⽅利益，也是国际社会的共同期盼</li><li>总结中美关系发展经验和教训新时期中美相处应该坚持三点原则：⼀是相互尊重；⼆是和平共处；三是合作共赢</li></ul></li></ul><h2 id="第二套-5">第二套</h2><ul><li>新中国联合国合法席位<ul><li>恢复中华人民共和国在联合国的一切合法权力，是世界上的一个大事件，是联合国的一个大事件，标志著占世界人口四分之一的中国人民重新走上了联合国舞台。</li><li>这是世界上一切爱好和平和主持正义的国家共同努力的结果，是世界公道正义的胜利，也是联合国宪章宗旨和原则的胜利，联合国的普遍性、代表性、权威性得到了切实增强</li><li>50年来，中国对联合国事业和世界和平发展做出了重大贡献</li></ul></li><li>中国对联合国贡献<ul><li>第⼀，中国⼈⺠始终同世界各国⼈⺠团结合作，维护国际公平正义，为世界和平与发展作出了重⼤贡献。</li><li>第⼆，中国⼈⺠始终维护联合国权威和地位，践⾏多边主义，中国同联合国合作⽇益深化。</li></ul></li><li>中国加入世贸<ul><li>加⼊世界贸易组织以来，中国始终不渝履⾏⼊世承诺。</li><li>中国始终谋求共同发展，体现责任和担当。</li><li>总结</li></ul></li></ul><h2 id="第三套-5">第三套</h2><ul><li>气候变化<ul><li>应对气候变化，事关中华⺠族永续发展，事关⼈类前途命运，既是中国可持续发展的内在要求，更是负责任⼤国应尽的国际义务。</li><li>中国要不断提高应对气候变化力度，力争2030年前实现碳达峰，2060年前实现碳中和的自主贡献目标，这是构建⼈类命运共同体的庄严承诺，展现了中国作为全球⽣态⽂明建设的重要参与者、贡献者和引领者的负责任⼤国担当。</li></ul></li><li>中国气候承诺对全球启示<ul><li>第⼀，要携⼿应对全球性挑战，共同缔造⼈类美好未来。xxx结合材料论述xxx</li><li>第⼆，要坚持⾛多边主义道路。xxx结合材料论述xxx，也可以直接抄第⼀卷第⼆问的答案。</li><li>第三，全球治理体系亟待改⾰和完善。xxx结合材料论述xxx</li><li>第四，要聚焦务实⾏动。xxx结合材料论述xxx</li></ul></li></ul><h2 id="第四套-5">第四套</h2><ul><li>全⼈类共同价值和多样性<ul><li>当前，⼈类前途命运休戚与共，各国相互联系和彼此依存⽐过去任何时候都更频繁、更紧密；全球性问题必须开展共同⾏动、合作；共同⾏动呼唤共同价值。</li><li>和平、发展、公平、正义、⺠主、⾃由六⼤要素蕴含着不同⽂明对价值内涵和价值实现的共通点，凝聚了⼈类不同⽂明的价值共识，反映了世界各国⼈⺠普遍认同的价值理念的最⼤公约数。可⻅，全⼈类共同价值与⽂明多样性并不⽭盾。</li><li>我们应该把全⼈类共同价值具体地、现实地体现到实现本国⼈⺠利益的实践中去。</li></ul></li><li>为什么要提出全球发展倡议，呼吁构建全球发展共同体<ul><li>第⼀，习近平主席提出全球发展倡议，呼吁构建全球发展共同体，“努⼒不让任何⼀个国家掉<br>队”，旨在推动国际社会合⼒应对挑战，促进世界经济复苏，加快落实联合国 2030 年可持续发展<br>议程。xxx结合材料论述xxx</li><li>第⼆，发展是实现⼈⺠幸福的关键。发展是世界各国的权利，⽽不是少数国家的专利。我们需要<br>谋求共同发展。xxx结合材料论述xxx</li></ul></li><li>为什么要“努⼒塑造可信、可爱、可敬的中国形象”，“展示真实、⽴体、全⾯的中国”？<ul><li>⾸先，这是加强我国国际传播能⼒建设的重要任务。认识到新形势下加强和改进国际传播⼯作的重要性和必要性，下⼤⽓⼒加强国际传播能⼒建设，）就能为我国改⾰发展稳定营造有利外部舆论环境。</li><li>其次，近年来，我国国际话语权和影响⼒显著提升，但依然有⼀些负⾯看法甚⾄歪曲中国形象的声⾳。xxx结合材料论述xxx</li><li>我们必须加快构建中国话语和中国叙事体系，⼴泛宣介中国主张、中国智慧、中国⽅案，“努⼒塑造可信、可爱、可敬的中国形象”，“展示真实、⽴体、全⾯的中国”</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 政治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理六-七章</title>
      <link href="/posts/c43c38b4/"/>
      <url>/posts/c43c38b4/</url>
      
        <content type="html"><![CDATA[<h1>第六章 - 总线系统</h1><ol><li>系统总线按照传输信息内容分类<ul><li>数据总线<ul><li>唯一的双向传输的总线</li><li>位数(根数)与机器字长、存储字长<strong>有关</strong>（非相等）</li></ul></li><li>地址总线<ul><li>单向</li><li>位数(根数)与<strong>主存</strong>地址空间大小及设备数量有关<ul><li>如根数与<strong>主存能保存的地址个数</strong>的表示位数一致，或者地址总线上连接设备的个数一致.</li></ul></li></ul></li><li>控制总线<ul><li>单向</li><li>CPU发出控制信号，设备返回CPU的回馈信号</li></ul></li></ul></li><li>系统总线的结构（按照CPU、I/O设备、主存之间有几组总线进行连接来划分）<ul><li>单总线结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041332023.png" alt="单总线结构"><ul><li>并非只有一条信号线，而是CPU、I/O设备、主存之间通过一组系统总线（包含数据、地址、控制总线）连接.</li><li>CPU、I/O设备、主存之间可<strong>直接交换</strong>信息，<strong>不同I/O之间也可直接交换信息</strong></li><li>优点<ul><li>结构简单、成本低、方便新设备接入</li></ul></li><li>缺点<ul><li>带宽低、负载重、不支持并行传输</li><li>比较快速的总线受到慢速设备的制约</li></ul></li></ul></li><li>双总线结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041331196.png" alt="双总线结构"><ul><li>分为主存总线（CPU、主存、通道）和I/O总线（I/O、通道）</li><li>通道程序放在主存当中</li><li>主存总线支持突发（猝发）传送。即CPU发出一个地址、主存返回多个地址连续的数据。</li><li>优点<ul><li>将慢速设备与高速的主存总线分离开来</li></ul></li><li>缺点<ul><li>需要增加通道等硬件设备</li></ul></li></ul></li><li>三总线结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041345549.png" alt="三总线结构"><ul><li>分别位主存总线、I/O总线、DMA总线</li><li>回想操作系统，DMA总线使得I/O和主存之间能够在CPU极少干预下实现传输</li><li>优点<ul><li>提高了I/O设备的性能、使其更快响应命令、提高了系统吞吐量</li></ul></li><li>缺点<ul><li>系统工作效率较低（三总线只能有一条总线正在工作）</li><li>那DMA传输过程中CPU怎么使用内存？通常采用以下三种方法。<ul><li>停止CPU访内存</li><li>周期挪用</li><li>DMA与CPU交替访问内存</li></ul></li></ul></li></ul></li><li>四在线结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041411948.png" alt="四在线结构"><ul><li>桥接器（北桥、南桥）<ul><li>连接不同总线，具有数据缓存、转换和控制功能</li></ul></li><li>该结构不重要</li></ul></li></ul></li><li>总线的性能指标<ul><li>总线传输周期<ul><li>一次总线操作所需要的时间（包括<strong>申请阶段、寻址阶段、传输阶段和结束阶段</strong>）</li><li>一条总线有32条线，一个传输周期即可传送32bit的信息</li><li>一个传输周期可能由若干总线时钟周期构成，但：<ul><li>也有可能只由一个总线时钟周期构成</li><li>也有可能<strong>一个总线时钟周期内包含多个总线传输周期</strong><ul><li>原因：一个时钟周期是一个上升沿和一个下降沿的过程，而可能总线检测到一次跳变就进行传输，所以一个时钟周期内有两个传输周期</li></ul></li></ul></li></ul></li><li>总线时钟周期<ul><li>即机器的时钟周期</li><li>现代计算机中，时钟信号也有可能是桥接器提供的</li></ul></li><li>总线的工作频率<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041600050.png" alt=""></li></ul></li><li>总线的时钟频率<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041602140.png" alt=""></li></ul></li><li>总线宽度<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041602065.png" alt=""></li><li>通常不包含地址总线和控制总线</li></ul></li><li>总线带宽<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041604096.png" alt=""></li><li><strong>例题</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041605563.png" alt=""><ul><li>1个时钟周期传送<code>32 * 2 = 64bit</code>的数据，时钟频率66MHz，所以<code>总线带宽 = 66M * 64 （bit/s）</code></li><li><code>128 / 32 = 4次</code>占两个时钟周期，<code>一个时钟周期 = 1/66MHz ≈ 15ns</code>，CPU发生首地址占用一个时间周期，传输数据花费2个时钟周期，所以<code>(1+2)*15 = 45ns</code></li></ul></li></ul></li></ul></li><li>串行总线与并行总线的速度对比<ul><li>在频率相等的情况下，显然并行更快</li><li>但实际情况下并行线路中存在干扰，因此频率不能很高，<strong>不一定并行就比串行更快</strong></li></ul></li><li>总线仲裁<ul><li>主设备：获得总线控制权的设备</li><li>从设备：被主设备访问的设备，只能被动响应从主设备发来的各自总线命令</li><li><strong>总线仲裁分类</strong><ul><li>集中式仲裁（由总线控制器来判断）<ul><li>链式查询<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041709293.png" alt=""><ol><li>设备向BR（总线请求）发出请求。</li><li>总线控制器向BG（总线允许）发出信号，信号来到设备0，若设备0没有发出请求则不应答，信号到了后面的设备。直到遇到发出过请求的设备。</li><li>第一个遇到允许信号的设备会向BS（设备忙）发出信号，表示占用。同时还会截断总线允许信号，防止后面设备接收到。</li></ol><ul><li><strong>离总线控制器远的设备其优先级会较低</strong></li><li>当线路上游的设备出现问题时，之后的线路都会崩溃（信号需要上游设备转发）</li></ul></li><li>计数器定时查询<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041734207.png" alt=""><ol><li>总线控制器接收到请求，判断总线空闲</li><li>总线控制器从0开始计数，依次询问总线上的设备是否需要使用</li><li>设备接到总线控制器的询问信号，发现其数据与自身编号一致，且此时本设备需要使用总线，于是向BS总线忙发出信号表示占用。</li></ol><ul><li>计数器可以每次从0开始，也可以从上一次的终点开始，还可以通过程序进行控制</li><li>没有链式敏感，前面设备坏了后面设备依然能收到信号</li><li>控制线数会增多</li></ul></li><li>独立请求<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109041734139.png" alt=""><ol><li>每个设备都有<strong>总线请求BR</strong>和<strong>总线允许BG</strong>两条专用线路，同时也都连接在<strong>总线忙BS</strong>线上（图中未画出）</li><li>设备的请求会放到总线控制器里的等待队列，由总线控制器选出设备并发出允许信号，设备接收到后占用总线忙BS</li></ol><ul><li>速度快、优先级控制灵活</li><li>控制线数量极多，<strong>设备有n个，就需要2n+1的控制线</strong>。且控制逻辑复杂</li></ul></li></ul></li><li>分布式仲裁（每个设备具有仲裁器和仲裁号）<ol><li>设备发出自己唯一的仲裁号到共享的仲裁总线上。</li><li>每个设备的仲裁器将由仲裁总线上得到仲裁号与自己的仲裁号进行比较、观察优先级。</li><li>若自己的仲裁号优先级更低，就自觉撤销仲裁信号</li><li>最终，优先级最高的设备的仲裁号会保留在仲裁总线上</li></ol></li></ul></li></ul></li><li>总线的操作和定时<ul><li>总线周期的四个阶段<ul><li>申请分配阶段<ul><li>可细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段</li></ul></li><li>寻址阶段<ul><li>主设备通过总线发出<strong>从设备</strong>的<strong>地址信息和相关命令</strong>,启动本次传输的从设备</li></ul></li><li>传输阶段<ul><li>主设备和从设备进行<strong>数据交换</strong>（数据总线：可双向）</li></ul></li><li>结束阶段<ul><li>主设备相关信息从系统总线上撤销，让出总线使用权</li></ul></li></ul></li><li>总线定时（总线两端双方交换数据的过程中需要在时间上有所配合）<ul><li>同步通信<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109042023233.png" alt=""><ul><li>由<font color=blue size=4>统一的时钟信号</font>控制</li><li>优点<ul><li>速度快、较高传输速率；总线控制逻辑简单</li></ul></li><li>缺点<ul><li>主从设备是强制性同步，若主从设备没对上节拍就会传输失败；不能及时校验数据、可靠性差。</li></ul></li><li>适合<strong>总线长度短</strong>和<strong>总线所接设备的存取时间相近</strong>的系统</li></ul></li><li>异步通信<ul><li>采用<font color=blue size=4>应答方式</font>，通过握手协议控制</li></ul><ol><li>主从设备分别发生请求和应答信号</li><li>根据“请求”和“回答”信号的撤销是否互锁进行分类<ol><li>不互锁（速度最快，可靠性最差）<ul><li>主设备：发出<strong>请求</strong>，不等待<strong>回答</strong>，而是经过一段时间后就撤销<strong>请求</strong></li><li>从设备：接收<strong>请求</strong>，发出<strong>回答</strong>，经过一段时间后撤销<strong>回答</strong>。双方不存在互锁。</li></ul></li><li>半互锁<ul><li>主设备：发出<strong>请求</strong>，<strong>等待回答</strong>，接收到<strong>回答</strong>之后才会撤销<strong>请求</strong>，有互锁。</li><li>从设备：接收<strong>请求</strong>，发出<strong>回答</strong>，经过一段时间后撤销<strong>回答</strong>，不互锁。</li></ul></li><li>全互锁（速度最慢，可靠性最强）<ul><li>主设备：发出请求，<strong>等待回答</strong>，接收到<strong>回答</strong>之后才会撤销<strong>请求</strong>，有互锁。</li><li>从设备：接收<strong>请求</strong>，发出<strong>回答</strong>，同时<strong>必须获知到主设备的请求已经撤销后才能</strong>撤销<strong>回答</strong>，有互锁。</li></ul></li></ol></li></ol><ul><li>优点：总线周期长度可变、自由适应时间配合。</li><li>缺点：控制更复杂、速度比同步更慢</li></ul></li><li>半同步通信<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109042043656.png" alt=""><ul><li>同步、异步结合</li><li>增加一个<code>wait信号</code>，当主从设备速度不匹配时放慢速度。</li></ul></li><li>分离式通信<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109042048416.png" alt=""><ul><li>从设备准备数据时，总线其实是空闲的</li></ul><ol><li>因此在主设备申请占用总线，发送完从设备地址和控制信息后<strong>立即放弃总线</strong></li><li>从设备准备数据时，其它主设备就可以占用总线</li><li>然后从设备申请占用总线，变为主设备，向原来的主设备发生数据</li></ol></li></ul></li></ul></li><li>总线标准（<strong>了解</strong>）<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109042058064.png" alt=""></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109042116989.png" alt=""></li></ul></li><li>为何串行总线取代并行总线<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109042119311.png" alt=""></li></ol><h1>第七章- 输入输出系统</h1><ol><li>I/O接口: 也叫I/O控制器、设备控制器；负责协调主机与外部设备之间的数据传输。</li><li>I/O接口具有数据、控制、状态寄存器。</li><li>I/O指令: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109061146652.png" alt=""></li><li>显示存储器（VRANM）：也叫<strong>刷新存储器</strong>，为了存储了一帧的图像信息，<code>VRAM容量 = 分辨率 × 灰度级位数</code>，同时<code>VRAM带宽 = VRAM容量 × 刷新率（帧频）</code></li><li>磁盘阵列(RAID)<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109061553885.png" alt=""></li><li>I/O接口的作用<ul><li>数据缓存：通过数据缓冲寄存器（DBR）达到主机和外设间速度的匹配</li><li>错误和状态检测：状态寄存器反馈设备的各种错误、状态信息，供CPU查用</li><li>控制和定时： 接收从控制总线发来的控制信号、时钟信号</li><li>数据格式转换：串-并、并-串等格式转换</li><li>与主机和设备通信：实现<code>主机 - I/O设备 - I/O设备 - I/O设备</code>的通信</li></ul></li><li>I/O接口的结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109061642721.png" alt=""><ul><li>内部接口（接口面向主机的部分）：2010年前大多采用并行，但之后逐渐向串行转变</li><li>外部接口（设备侧）：I/O接口可能连接多个设备</li></ul></li><li>一次I/O过程<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109061649209.png" alt=""><ol><li>CPU发出<strong>命令字</strong>到<strong>I/O控制寄存器</strong>，该过程需要驱动程序的协助（不同设备命令字集各不相同，需要厂家提供驱动）。如<code>我要打印文档</code>。</li><li>CPU从状态寄存器中读取对应设备的<strong>状态字</strong>，获得设备或I/O控制器的状态信息。<code>1号打印机状态正常，空闲中，准备就绪</code>。</li><li>从数据缓冲寄存器中读取或发送数据，完成主机与外设的信息交换。<code>发送文档数据到数据缓冲寄存器，由地址译码和I/O控制逻辑负责控制打印过程</code>。</li><li>完成后可通过处理机轮询或中断请求等方法告知CPU。</li></ol><ul><li>当CPU发出控制信号给控制寄存器之后，设备会开始准备可用资源，并通过状态寄存器告知CPU一些信息。这两者之间是错开的，因此，可以将状态寄存器和控制寄存器合二为一。</li><li>数据线指明：读写数据、状态字、控制字、中断类型号</li><li>地址线指明I/O端口（哪个设备）</li><li>控制线指明读写信号，中断请求信号</li></ul></li><li>I/O编址（区分设备地址）<ul><li>统一编制：在内存划分出一部分区域用来存放设备地址，但其在内存中的地址<strong>从高位开始</strong>（相当于绝对地址）<ul><li>常见于RISC指令集，不需要专门的I/O指令</li><li>地址位多，地址译码就慢</li></ul></li><li>独立编址：在内存划分出一部分区域用来存放设备地址，但其在内存中的地址<strong>从零位开始</strong>（相当于相对地址）<ul><li>Q：独立编址中访问0号地址怎么区分是设备区还是内存区？</li><li>A：通过指令类型，如IN和OUT这两种I/O指令会自动去设备区找。</li><li>常见于CISC指令集，需要专门的I/O指令</li><li>地址位少（只需要表示出相对地址位，即不用考虑内存区的部分），译码快</li><li>I/O指令类型不能过多（否则区分也要时间），程序设计灵活性差；增加了控制逻辑电路的复杂性。</li></ul></li></ul></li><li>程序查询方式（轮询）流程（以打印字符a为例）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109061741334.png" alt=""><ol><li>字符数据a被读入到CPU的寄存器中</li><li>CPU得出控制字/命令字（由驱动程序协助提供），发给控制寄存器，<code>我要打印文档</code>；通过地址线告知I/O控制器以设备地址，<code>用啥打印</code>；通过控制线告知I/O控制器具体操作，<code>微操，怎么打印</code>。<ul><li>后两步在I/O设备准备好之后才执行</li></ul></li><li>设备控制器得到命令后会去准备设备，设备准备好后通过状态寄存器告知CPU以设备状态，<code>设备X准备好了</code>。</li><li><strong>CPU轮询访问状态寄存器</strong>，<code>检查需要使用的设备准备好没</code>。<ul><li>这期间CPU无法干其他工作。</li></ul></li><li>I/O控制器将CPU写入数据缓冲寄存器的数据转发到设备。</li></ol></li><li>中断<ul><li>PSW（程序状态字）中的IF（Interrupt Flag）字段标识了此时是否开中断（1开0关）</li><li>中断服务程序：处理中断的程序；当响应中断时，取出中断服务程序的入口地址并传送给程序计数器PC。<ul><li>中断向量：中断服务程序的入口地址</li><li>中断向量地址：中断服务程序的入口地址的地址</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062022975.png" alt=""></li></ul><ol><li>发生中断时，由<strong>中断向量地址形成部件</strong>将不同的中断信号映射为中断向量（不同中断处理方法不同），中断向量即对应中断服务程序的入口地址。</li><li>通过这个中断向量（中断服务程序地址），找到服务程序所在的内存位置，开始执行。</li><li><strong>为什么不能让中断向量地址生成部件直接产生入口地址300，而要产生13H再指向300？</strong><ul><li>因为当服务程序的地址发生变动时，地址生成部件的映射方式也要改变，但地址生成部件是硬件！！！逻辑电路不能随意修改…</li></ul></li></ol></li></ul></li><li>多重中断<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062037051.png" alt=""><ul><li>当执行中断服务程序时，<strong>依然能够响应中断信号</strong>（利用堆栈）</li><li>屏蔽字：也叫中断屏蔽字，屏蔽优先级更低的中断信号。</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062045590.png" alt=""><ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062048682.png" alt=""></li></ul><ol><li>可以理解为A最先执行，但D的中断会打断A</li><li>B先运行5us后被D打断，处理完D时是30us处，35us处B再次被A打断…</li></ol></li></ul></li><li>DMA控制器<ul><li>CPU可向DMA控制器指明：要输入还是输出、要传送多少数据、数据在主存和外设中的位置</li><li>DMA与磁盘是逐字传输，与内存是逐块传输</li><li><strong>传输过程</strong><ol><li>外设发出DMA请求（也就是传送一个字）</li><li>DMA向CPU发出总线请求，CPU响应后得到总线控制权，进入DMA周期</li><li>确定传送数据的主存单元地址及长度（由CPU提前告知），并且DMA能够自动修改主存地址计数和传送长度计数。</li><li>DMA规定每次主存与外设间的传输方向，发出读写等控制信号，执行数据传输操作。</li><li>向CPU报告DMA结束（中断），移交总线控制权。</li></ol></li><li><strong>结构</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062135899.png" alt=""><ul><li>“控制/状态”逻辑：负责存放状态字和控制字的寄存器。</li><li>DMA请求触发器：每当I/O设备准备好数据时，向其发送一个控制信号，令其置位触发，就会发送一个状态信号给状态寄存器，CPU就知道准备好了。</li><li>传送长度计数器：归0后传送完成，自动向CPU发出中断请求信号。</li></ul></li><li>DMA和CPU的访存冲突<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062151548.png" alt=""></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109062153762.png" alt=""></li></ul></li></ol><h1>补充考点</h1><ul><li>固态硬盘SSD:<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151046878.png" alt=""></li><li>SISD、SIMD、MISD、MIMD：看同时执行几个指令，有多少个处理器。</li></ul><h1>tool</h1><pre><code class="language-text">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;四号蓝: &lt;font color=blue size=4&gt;&lt;/font&gt;红:    &lt;font color=red&gt;&lt;/font&gt; 绿:    &lt;font color=green&gt;&lt;/font&gt;蓝:    &lt;font color=blue&gt;&lt;/font&gt;分割线:  ----------------------------表格:  |        |      |       || ----- | --:  | :----: ||       |       |       ||       |       |       ||       |       |       |拼图&#123;% gi 2 2 %&#125;&#123;% endgi %&#125;便签：  &#123;% note success %&#125;  &#123;% endnote %&#125;链接:  🔗</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理补充疑难点</title>
      <link href="/posts/88a8eec7/"/>
      <url>/posts/88a8eec7/</url>
      
        <content type="html"><![CDATA[<h1>第一章 - 计算机系统概述</h1><ol><li><p>计算机硬件发展：<code>电子管 ➡ 晶体管 ➡ 中小规模集成电路 ➡ 超大规模集成电路</code></p></li><li><p>数据库管理系统（DBMS）是操作系统软件，数据库系统（DBS）是用户软件。</p></li><li><p>计算机系统结构</p><ul><li><strong>软硬件逻辑上等效</strong></li><li>计算机硬件结构：<ul><li>冯·诺伊曼机：<ul><li>运算器为中心</li><li>包括：运算器、存储器、控制器、输入设备、输出设备</li><li>特点：后面学的都是冯·诺依曼机，有什么特点看对不对的上就行</li></ul></li><li>现代机：<ul><li>存储器为中心（最慢的部分放在首位）</li><li>I/O操作尽可绕开CPU</li></ul></li></ul></li><li>语言层次：<code>高级语言 ➡ 汇编语言 ➡ 机器语言</code></li></ul></li><li><p>计算机的工作过程 - 1：<font color=blue>(看看就行，后面会详细)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108191632384.png" alt="计算机的工作过程"><br>0: 刚开始时,<code>PC = 0</code>,即当前要执行的指令的地址在0号主存地址.<br>1: <code>PC -&gt; MAR</code>,控制器通过地址总线告诉内存(主存储器)要取的数据,导致<code>MAR = 0</code>.<br>2&amp;3: <code>MAR -&gt; 存储体 -&gt; MDR</code>,取出数据到MDR,导致<code>MDR = 000001 0000000101</code>.<br>4: 控制器通过总线取走MDR的数据,存放到IR,导致<code>IR = 000001 0000000101</code>.<br>5: CU控制单元取走IR的<strong>操作码</strong>部分,CU因此得知这时<strong>取数</strong>指令.<br>6: <code>IR -&gt; MAR</code>,控制器将IR的<strong>地址码</strong>发给MAR,导致<code>MAR = 5</code>.<br>7&amp;8: <code>MAR -&gt; 存储体 -&gt; MDR</code>, 导致<code>MDR = 0000000000000010 = 2</code>.<br>9: <code>MDR -&gt; ACC</code>,控制器取出MDR数据到累加寄存器ACC中,导致<code>ACC = 0000000000000010 = 2</code>.<br>10：<font color=blue size=4>上一条指令执行后</font><code>PC = PC+1</code>.</p></li><li><p>计算机的工作过程 - 2：<font color=blue>(重点！！！)</font></p><ul><li><strong>执行指令</strong>的工作流程：<ol><li>取指令</li><li>指令译码、执行指令（取操作数、运算等）</li><li>完成指令，取下一条指令</li></ol></li><li>⬇不放图，图要记在脑海里！！！⬇</li><li><strong>各阶段寄存器数据流动方向</strong>：<ul><li>取指令：<code>PC ➡ MAR、MAR ➡ M主存 ➡ MDR、MDR ➡ IR</code>同时<code>PC+1 ➡ PC</code></li><li>分析指令：<code>OP（MAR）➡ CU</code>，指令的操作数部分放入控制单元CU</li><li>执行指令：<code>Ad（IR）➡ MAR、MAR ➡ MDR、MDR ➡ ACC</code>（执行过程各不相同、以加法指令为例）</li></ul></li></ul></li><li><p>计算机的多级层次结构<font color=blue>(简单了解)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109241919057.png" alt=""></p><ul><li>上层分别是<code>高级语言 ➡ 汇编语言 ➡ 机器语言</code>，下层是<code>微程序 ➡ 微指令</code></li></ul></li><li><p>各硬件<font color=blue>(记忆)</font>：</p><ul><li>运算器：ACC累加寄存器、ALU算术逻辑单元、MQ乘商寄存器、X通用寄存器（可通过编程变成其它寄存器）、IX变址寄存器（理解为可随意改变的基址，IX+A就是当前地址）、BR基址寄存器、PSW程序状态寄存器</li><li>存储器：MAR（存储地址寄存器）、MDR（存储数据寄存器）<ul><li>存储器结构：<code>存储元件(1bit) ➡ 存储单元（1B或者1B的偶数倍，这个数值就是存储字长）</code></li><li>MAR标志地址，所以其位数对应着存储单元的个数，如<code>MAR = 10bit，存储单元 = 2^10 = 1024个</code></li><li>MDR标志数据，所以其位数一般是存储字长或者存储字长的<code>2^n</code>倍</li></ul></li><li>控制器：IR指令寄存器（当前指令）、PC程序计数器（下一条指令地址）、CU控制单元</li></ul></li><li><p>计算机性能指标：</p><ul><li>机器字长：一次整数运算的数据的最大位数，一般情况下等于内部寄存器（ACC等）的位数</li><li>数据通路带宽：数据总线一次能够传输数据的位数（此处指外部数据总线，而非CPU内部总线）</li><li>主存容量</li><li>运算速度<font color=blue>(理解)</font>：<ul><li>吞吐量：单位时间内处理请求的数量，主要取决于主存速度</li><li>响应时间：发送请求到收到响应的时间</li><li>主频：CPU单位时间内的时钟周期数</li><li>CPI（Clock Per Instruction）：一条指令占用周期数</li><li>CPU执行时间：一个程序消耗时间</li><li><strong>计算能力</strong>：<ul><li>MIPS：每秒（PS）多少百万条指令（MI）</li><li>MFLOPS：每秒多少百万次浮点运算，十亿（GFLOPS），万亿（TFLOPS）</li></ul></li></ul></li></ul></li></ol><h1>第二章 - 数据的表示和运算</h1><ol><li><p>海明码补充知识点<font color=blue>(详细请查看<a href="https://chen0495.top/posts/a01c1709/#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">计网-海明码</a>) </font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108211542372.png" alt="海明码补充知识点"></p></li><li><p>进制转换：</p><ul><li><code>2 ➡ 8/16</code>：小数点为分界线，每3或者4位为一组分别计算，不足3或4位就补0<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242016666.png" alt=""></li><li><code>8/16 ➡ 2</code>：小数点为分界线：每1位都写成3或4位二进制数（不足就补0）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242018465.png" alt=""></li><li><code>任意 ➡ 10</code>：每项乘权值求和<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242024766.png" alt=""></li><li><code>10 ➡ 任意</code><font color=blue>(重点！！！)</font>：<ul><li>整数部分（除基取余法）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242024947.png" alt=""></li><li>小数部分（乘基取余法）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242026403.png" alt=""></li></ul></li></ul></li><li><p><s>字符串编码</s><font color=blue>(已删)</font>：</p><ul><li>ASCⅡ编码：7b<ul><li>0~31：控制字符</li><li>127：DEl</li><li>48~57：0~9</li><li>65~90、97~122：A~Z、a~z</li></ul></li><li>汉字的表示和编码：<ul><li>每个编码2个字节</li><li>输入编码（计算机输入）、汉字内码（计算机处理，坐标）、汉字形码（计算机图形输出）</li></ul></li><li>大端和小端：<ul><li>整数127（十进制）在计算机(64位)中大/小端字节序<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242037243.png" alt=""></li></ul></li></ul></li><li><p>校验码：奇偶、CRC、海明码，参考<a href="https://chen0495.top/posts/a01c1709/">计网</a></p></li><li><p>定点数的表示<font color=blue>(重点！！！尤其补码！！！)</font>：</p><ul><li>定点整数<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242047762.png" alt=""></li><li>定点小数<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242046222.png" alt=""></li><li>原码的表示范围：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242106675.png" alt=""><br>- <strong>最小负全1，最大正全1，用幂次累加和公式计算</strong></li><li>反码的表示范围：正不变、负全变<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242110982.png" alt=""></li><li>补码：正不变、负全变并+1（补码到原码也是这个！）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242110334.png" alt=""><ul><li>整数：<ul><li>在原码当中，“+0”<code>0 000 0000</code>和“-0”<code>1 000 0000</code>表示同一个数</li><li>即0的<strong>反码</strong>可以表示成“-0”<code>1 111 1111</code>和“+0”<code>0 000 0000</code>，反码中<code>“-0” + 1 = “+0”</code>，这样负数对于的反码整体“+1右移”，使0不再重复，解放出一个最小值-2^n</li></ul></li><li>小数：<ul><li><ul><li>在原码当中，“+.0”<code>0 . 000 0000</code>和“-.0”<code>1 . 000 0000</code>表示同一个数</li></ul></li><li>即0的<strong>反码</strong>可以表示成“-0”<code>1 . 111 1111</code>和“+0”<code>0 . 000 0000</code>，反码中<code>“-.0” + 0 . 000 0001 = “+.0”</code>，这样负数对于的反码整体“+.000 0001右移”，使.0不再重复，解放出一个最小值-1</li></ul></li><li><strong>符号相同时,补码数据部分越大,码值越大</strong></li><li>模4补码：2位符号数；模2补码：1位符号数</li></ul></li><li>移码：补码符号位取反<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242128049.png" alt=""><ul><li>本质上是加上一个2^n使得符号取反，所以不可用于纯小数</li></ul></li></ul></li><li><p>定点数的移位运算</p><ul><li>算数移位（符号位不参与运算）<font color=blue>(重点！！！但只记图，下面的理解为主)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242156655.png" alt=""><ul><li>正数：正数的原码、反码、补码相同，均移位添0即可</li><li>负数：<ul><li>原码：<strong>移位添0</strong></li><li>反码：<strong>反码数据位正好与原码相反，所以原码是移位添0，反码就应该移位添1</strong></li><li>补码：<strong>负数补码当中，最右边的1及其右边同原码、左边同反码</strong>，所以左移应该同原码补0，右该同反码补1</li></ul></li></ul></li><li>逻辑移位：不管操作数，看出无符号数，左右移都添0</li><li>循环移位<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242204251.png" alt=""><ul><li>不带进位位的循环左移将最高位进入最低位和标志寄存器位</li><li>不带进位位的循环右移将最低位进入最高位和标志寄存器位</li></ul></li></ul></li><li><p>定点数的加减运算</p><ul><li>原码：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242206998.png" alt=""><ul><li>“正+正”或者“负+负”可能溢出</li></ul></li><li>补码（可以直接运算）<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242207800.png" alt=""><ul><li>溢出判断<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242214279.png" alt=""></li></ul></li></ul></li><li><p>符号扩展<font color=blue>(理解为主)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242209770.png" alt=""></p><ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108231554191.png" alt=""></li></ul></li><li><p>定点数的乘法运算<font color=blue>(要会算!!!)</font>：</p><ul><li>乘法可以用加法和移位运算实现</li><li>原码乘法：<ul><li>符号位异或确定</li><li>手算：<strong>直接乘</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242225048.png" alt=""></li><li>手算<strong>模拟ALU</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109242225592.png" alt=""></li></ul></li><li>补码乘法模拟ALU：<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250844906.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250829455.png" alt=""></li></ul></li><li>原码除法运算<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250837182.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250837394.png" alt=""></li></ul></li><li>补码除法运算<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250839775.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250839641.png" alt=""></li></ul></li></ul></li><li><p>浮点数的表示<font color=blue>(超重点!!!每个概念都要搞懂)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250848887.png" alt="">:</p><ul><li>如<code>+11 +3.026</code>或者<code>+15 +0.0003026</code></li><li>浮点数<strong>尾数部分</strong>规范化:<ul><li>原码<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250904921.png" alt=""></li><li>补码<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250904044.png" alt=""></li></ul></li><li>IEEE 754：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250923520.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250909145.png" alt=""><ul><li>移码的定义是<code>移码 = 真值 + 偏置值</code>，一般偏置值 = 2^(n-1)，这时刚好<code>移码 = 补码符号位取反</code></li><li>IEEE 754的偏置值是<code>2^(n-1) - 1</code><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250929274.png" alt=""><ul><li>例子：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109250931530.png" alt=""></li></ul></li></ul></li></ul></li><li><p>数据存储：</p><ul><li>边界对齐方式和边界不对齐方式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109251100466.png" alt=""><ul><li>注意！边界对齐方式是不足字或半字就立即填充，而不是在最后填充</li><li>如<code>A（4B）、B（1B）、C（2B）</code>应该填充为<code>A（4B）、B（1B）+T（1B）、C（2B）</code>而不是<code>A（4B）、B（1B）、C（2B）+T（1B）</code></li></ul></li></ul></li><li><p>ALU算术逻辑单元：也就是数字电路课上的小芯片.<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108251727065.png" alt=""></p><ul><li>电路从左到右分别是：<ul><li><code>与、或、非</code><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252055502.png" alt=""></li><li><code>与非、或非、异或</code><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252057084.png" alt=""></li></ul></li><li>标志位（CF、OF、ZF、SF）：<ul><li>CF（进位/借位标志）</li><li>OF（Overflow Flag、溢出标志）：符号位进位⊕最高位进位</li><li>ZF（Zero Flag、零标志）</li><li>SF（符号标志）：和的符号</li></ul></li></ul></li></ol><div class="note success flat"><p>习题1:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281522151.png" alt=""><br>习题2:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281600221.png" alt=""></p><ul><li>补码<code>1000 0000</code>的原码是<code>1000 0000</code>,原码里表示-0,补码中表示-128,所以转成原码会产生溢出<br>习题3:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281608244.png" alt=""></li></ul></div><h1>第三章- 存储系统</h1><ol><li><p>存储器的层次结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252110753.png" alt=""></p><ul><li>外存中的程序要执行必须先调入主存</li></ul></li><li><p>RAM和ROM：</p><ul><li>RAM（随机存储器）：<ul><li>随机存取，用于高速缓存存储器（如内存）</li><li>易失性</li></ul></li><li>ROM（只读存储器）：<ul><li>只能读不能写（狭义上），随机存取（广义上，在写入上有某些限制）；</li><li>和随机存储器一起构成主存，存储某些固定不变的程序（如BIOS）；</li><li>非易失性</li></ul></li></ul></li><li><p>存储器的性能指标：</p><ul><li>大容量、低成本、高速度</li><li><code>存储容量 = 存储字数 * 字长</code></li><li><code>单位成本 = 总成本 / 总容量</code></li><li>存储速度<code>数据传输率 = 数据宽度 / 存储周期</code></li></ul></li><li><p>半导体存储芯片（半导体存储器）组成结构：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252146694.png" alt=""></p><ul><li>图中是一种拓展方式，还有其他方式</li><li><strong>读写控制器</strong>：决定读还是写操作</li><li><strong>片选器</strong>：决定哪个芯片被选中（用来存取数据）</li><li><strong>地址线</strong>：决定要读写数据位于芯片中的哪些存储单元</li><li><strong>数据线</strong>：双向（读写），位数与读写数据的位数有关</li><li><strong>数据线数与地址线数共同反应存储芯片容量大小</strong></li></ul></li><li><p>SRAM和DRAM</p><ul><li>都是半导体随机存储器，SRAM用于高速缓存（Cache），DRAM用于主存（内存）</li><li>SRAM（静态RAM）：<ul><li>使用双稳态触发器（六管MOS）记忆信息</li><li>非破坏性读出，但具有易失性（信息很快就会自己消失）</li><li>存取速度快（Cache比主存快）、集成度低、功耗大、成本高</li><li>行列地址同时发送（DRAM是先行后列）</li><li>习题：<ol><li>地址线<code>1024 = 2^10，10根</code>，<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109261341490.png" alt=""></li></ol></li></ul></li><li>DRAM（动态存储器）：<ul><li>使用电容存储信息</li><li>破坏性读出，且有易失性（电容难以长时间留住电荷，需要充电）</li><li>存取速度慢（相对SRAM）、集成度高、功耗低、容量大、成本低</li><li>分别送行列地址</li><li>刷新（DRAM特有，单位是行）：<ul><li>集中刷新<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252150447.png" alt=""><ul><li>固定时间刷新、存在死区（一段时间内无法访问DRAM）</li><li>但读写速度快，读写不会受到刷新影响（指读写的过程中被刷新）</li></ul></li><li>分散刷新<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252153913.png" alt=""><ul><li>分时刷新/读写、没有死区（分时，宏观下没有死区）</li><li>存取周期长、降低整机速度</li></ul></li><li>异步刷新<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252155452.png" alt=""><ul><li>相当于读写占用时间片更多的分散刷新</li><li>减小了死区</li></ul></li><li>透明刷新：刷新安排在译码阶段，不存在死区</li></ul></li></ul></li><li>SRAM与DRAM对比<font color=blue>(理解!!!)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108252155045.png" alt=""></li></ul></li><li><p>存储器的读写周期：</p><ul><li>RAM读周期：存储器连续两次读操作时（读开始到下一次读开始），必须间隔的时间</li><li>RAM写周期：存储器启动到数据线上的数据全部可靠地写入存储器的时间</li></ul></li><li><p>闪存（FLASH）和固态（SSD）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252203460.png" alt=""></p></li><li><p>主存与CPU连接（总线、容量扩展/集成、片选）<font color=blue>(超重点！！！)</font>：</p><ul><li>连接：数据总线、控制总线、地址总线<ul><li>细分下来又有：读写命令线“WE/WR”（控制），片选线“CS/CE”（地址）</li></ul></li><li>主存容量的扩展：<ul><li>位扩展：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252208980.png" alt=""><ul><li>1B中每1b所在的存储芯片都不同</li><li>并联、每次同时读取8个存储芯片的一位</li><li>地址总线不变，数据总线n倍</li></ul></li><li>字扩展：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252210192.png" alt=""><ul><li>8B中每1B所在的存储芯片都不同</li><li>串联、每次读取1个存储芯片的一字节</li><li>数据总线不变，地址总线n倍</li></ul></li><li>字位同时扩展：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252213446.png" alt=""><ul><li>8B中每1B所在的存储芯片都不同，同时1B中每1b所在的存储芯片都不同（图中只分成4位，每4b不同）</li><li>串联+并联、每次从1组存储芯片中同时读取该组所有芯片的1位</li></ul></li></ul></li><li>片选：<ul><li>线选法：几个存储器就几根地址线，哪根地址线“亮了”就选择哪个存储器<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252219377.png" alt=""></li><li>（译码）片选法：加个译码器，如<code>01</code>是1号、<code>10</code>是2号，这样4个存储器只需要2根线而非4根线。</li></ul></li></ul></li><li><p>双端口RAM和多模块存储器<font color=blue>(理解)</font>：</p><ul><li>双端口RAM：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109252227921.png" alt=""></li><li>多模块存储器：<ul><li>普通存储器：每行为一个存储单元<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109260843889.png" alt=""></li><li>单体多字存储器：每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109260844200.png" alt=""></li><li>多体并行存储器：每个模块都有相同的容量和存取速度，各个模块都有独立的读写控制电路、地址寄存器、数据寄存器<ul><li>高位交叉编制：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109260848303.png" alt=""><ul><li>本质上仍是顺序存储器</li></ul></li><li>低位交叉编址：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109260849092.png" alt=""><ul><li>可使用流水线方式</li></ul></li><li>试想：连续访问<code>00000、00001、00010、00011、00100</code>时，对于高位交叉编制，依然是顺序地一直访问一个存储器，而低位交叉编址则是并行访问多个存储器。</li></ul></li></ul></li></ul></li><li><p>Cache和主存的映射<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108262155095.png" alt=""></p><ul><li>直接映射：每个主存块只能放在特定Cache块</li><li>全相联映射：每个主存块可以放在任意Cache块</li><li>组相联映射：每个主存块可以放在特定Cache组中的任意Cache块</li></ul></li><li><p>Cache写策略（命中：Cache中是否有所需数据）<font color=blue>(理解)</font>：</p><ul><li>写命中：全写法（同时写入主存和Cache）、写回法（只修改Cache，不立即写入主存）</li><li>写不命中：写分配法（加载内存块到Cache，然后修改Cache）、非写分配法（只写入主存、不调入Cache）</li><li>多级Cache（通常三级，L1、L2、L3缓存）：离CPU越近的Cache越快，容量一般越小。<ul><li>可以避免因频繁写造成的写缓存饱和溢出</li></ul></li></ul></li><li><p>虚拟存储器<font color=blue>(超重点！！！)</font>：</p><ul><li>问题引出：<ol><li>磁盘可能有坏道，这会影响数据的连续存储，怎么让数据跳过坏道实现”连续存储“？</li><li>多根内存条，每个内存条都有自己的从零开始的实际物理地址，怎么区分不同内存的”相同地址“？</li><li>多个磁盘，有的磁盘需要和其他磁盘合并为一个虚拟磁盘，有的磁盘需要划分出多个虚拟磁盘，怎么将虚拟磁盘的地址映射到实际磁盘物理地址？</li></ol></li><li><strong>页式虚拟存储器</strong>：以页（大小相等）为基本单位<ul><li>地址变换过程<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109260922055.png" alt=""></li></ul><ol><li>根据虚拟地址中的虚页号加上页表基地址，去页表找到对应的物理页号</li><li>物理页号+页内地址即可找到实际物理地址</li></ol></li><li><strong>段式虚拟存储器</strong>：以段（大小不等）为基本单位，其它基本与页式存储器类似<ul><li>地址变换过程<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109260928375.png" alt=""></li></ul></li></ul></li><li><p>存储系统大题<font color=blue>(超重点！！！)</font>：</p><ul><li>Cache行的完整构成：<code>Tag(标记)、V(有效)、替换信息、行号、组号、脏位、块内数据、块内地址</code></li><li>影响Cache行构成的因素：<code>PA位数、Cache总行数、Cache块大小、Cache-主存映射方式、写策略、替换算法</code><ul><li>Tag标记：受到PA（物理地址）位数、Cache块大小（块内地址位数）、Cache行数(组号/行号)、映射方式的影响（4者唯一确定Tag标记位数）：<ul><li>全相联：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109261746185.png" alt=""></li><li>直接相联（相当于1行就是1组）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109261747945.png" alt=""></li><li>组相联：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109261746594.png" alt=""></li></ul></li><li>V有效位：一定是1个比特</li><li>替换信息：<ul><li>随机替换：0 bit</li><li>LRU：N个比特，N是：<ul><li>直接映射：0 bit</li><li>全相联：log（2，Cache总行数） bit</li><li>组相联：log（2，Cache路数/组内行数） bit</li></ul></li></ul></li><li>脏位：<ul><li>写回法：1 bit</li><li>直写法：0 bit</li></ul></li></ul></li><li>例题1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109261803998.png" alt=""></li></ul></li></ol><div class="note success flat"><p><strong>注意地址线数与地址位数的区别!!!</strong>,以下可能用&quot;位&quot;但实际是&quot;线&quot;.<br>习题1:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281622671.png" alt=""></p><ul><li>注意是问的芯片引脚,不是存储器线路<br>习题2:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281653424.png" alt=""></li><li>4行2列,每行<code>2k × 8位</code>,即每行地址数<code>2^11 = 11位</code>,<code>0B1F = 0000 1011 XXXX XXXX</code>舍弃后11位是<code>0000 1</code>即第二个(第一个是0)芯片,其地址是…<br>习题3:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281710371.png" alt=""></li><li><code>4K = 12线</code>而不是<code>16K = 14线</code>,想想看增加了4倍的存储单元(存储单元的位数增加了2倍),需要额外2根片选线(相当于地址线,但因为多个芯片不是整体而是组合,实际上是控制线)来定位.<br>习题4:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281728612.png" alt=""></li><li>注意不是芯片扩展,而是芯片内存储单元阵列!</li><li>DRAM的行列地址线共用,所以行列数尽可能接近,同时DRAM按行刷新,行要少.<br>习题5:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281737900.png" alt=""></li><li>用流水线做!<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281739711.png" alt=""><br>习题6:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281852689.png" alt=""><br>习题7:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281917615.png" alt=""><br>习题8:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281928083.png" alt=""></li><li>主存地址32位,即物理地址32位,直接映射(行号10位),块内地址(4bit),所以<code>Tag = 32 - 10 - 4 = 18位</code>;回写(脏位1bit),有效位(1bit),一共20位,Cache索引位一共<code>20位 × 2^10 = 20K</code>,数据位4K*32=128K</li></ul></div><h1>第四章 - 指令系统</h1><ol><li><p>指令格式<font color=blue>(了解！)</font>：半字长指令、单字长指令、双字长指令： 指令长度是机器字长的多少倍</p><ul><li>指令字长会影响取指令所需时间。如： 机器字长 = 存储字长 = 16bit， 则取一条双字长指令需要两次访存</li><li>零地址指令：<code>OP</code><ul><li>空操作、停机、关中断</li></ul></li><li>一地址指令：<code>OP A1</code><ul><li>只有目的操作数的单操作数指令（+1、-1、求反、求补）、隐含约定目的地址的双操作数指令</li></ul></li><li>二地址指令：<code>OP A1 A2</code><ul><li>算数和逻辑运算指令</li></ul></li><li>三地址指令：<code>OP A1 A2 A3(结果)</code><ul><li>运算结果存放在A3</li><li>需要四次访存：取指令、取操作数×2、存放结果</li></ul></li><li>四地址指令：<code>OP A1 A2 A3(结果) A4(下址)</code><ul><li>相对于三址多了下一条执行命令的地址A4</li></ul></li></ul></li><li><p>定长操作码（RISC）、扩展（不定长）操作码（CISC）</p></li><li><p>指令寻址和数据寻址<font color=blue>(重点！！！)</font>：</p><ul><li>指令寻址：<ul><li>顺序寻址：通过程序计数器PC自动+1，生成下一条指令地址</li><li>跳跃寻址：结果是修改当前指令的PC值</li></ul></li><li>数据寻址（在指令中标记操作数的地址、操作码+地址（寻址特征+形式地址A））：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109262044462.png" alt=""><ul><li>隐含寻址：不给出操作数地址，而是指令中隐含。<ul><li>比如ALU中加法需要取一个数，另一个数隐含</li><li>不访存</li></ul></li><li>立即（数）寻址：形式地址A就是操作数本身<ul><li>不访存</li></ul></li><li>直接寻址：形式地址A就是真实地址<ul><li>访存一次</li></ul></li><li>间接寻址：形式地址A给出的是存有操作数地址的地址（套娃）<ul><li>具体看几次间接寻址</li></ul></li><li>寄存器寻址：形式地址A给出操作数所在的寄存器编号<ul><li>不访存</li></ul></li><li>偏移寻址（区别在于偏移的”起点“不同）：<ul><li>相对寻址：以PC为起点<ul><li>EA = （PC） + A</li><li>形式地址A是相对于PC的偏移量</li></ul></li><li>基址寻址：以程序起始地址为起点<ul><li>EA = 基址寄存器的内容（BR） + 形式地址A</li><li>基址寄存器BR的内容由操作系统指定，即使指定通用寄存器X为基址寄存器BR，其内容仍由操作系统指定。</li></ul></li><li>变址寻址：程序员自己决定起点（通过修改IX而非PC，修改PC的是跳跃寻址）<ul><li>EA = 变址寄存器（IX） + 形式地址A</li><li>通用寄存器X可作变址寄存器IX；变址寄存器IX面向用户，内容可由用户改变</li></ul></li></ul></li></ul></li></ul></li><li><p>CISC和RISC<font color=blue>(理解)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108312201978.png" alt=""></p></li></ol><div class="note success flat"><p>习题1:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109281952221.png" alt=""></p></div><h1>第五章 - 中央处理器</h1><ol><li><p>CPU基本结构<font color=blue>(重点！！！)</font>：</p><ul><li>运算器：算术逻辑单元ALU、程序状态字寄存器PSW、暂存寄存器、累加寄存器ACC、通用寄存器组（AX~DX、SP等）、移位器、计数器CT等</li><li>控制器：程序计数器PC、指令寄存器IR、指令译码器、存储器地址寄存器MAR、存储器数据寄存器MDR、时序系统和微操作信号发生器</li><li><strong>只有PC、PSW、ACC、X是可见（可编程）的</strong><ul><li>PC，可用条件转移指令改变其值</li><li>PSW，条件转移指令需要用到PSW的值，且比较指令可改变PSW的值</li><li>ACC，加法乘法可直接改变其值</li><li>X，通用寄存器，可以存放数据或者地址，位数一般与机器字长相等</li></ul></li></ul></li><li><p>指令周期：CPU完成一条指令的时间</p><ul><li>包含多个机器周期、每个机器周期又包含多个时钟周期</li><li>每个指令周期包含的机器周期可能不等、每个机器周期包含的时钟周期（节拍）也可能不等</li><li><strong>基本组成</strong>：取指周期、间址周期、执行周期、中断周期<ul><li>无条件转移指令只有取指和执行</li></ul></li></ul></li><li><p>不同周期的数据流<font color=blue>(重点！！！)</font>：</p><ul><li>取址周期：<code>(PC) ➡ MAR</code>、<code>1 ➡ R</code>、<code>M(MAR) ➡ MDR</code>、<code>(MDR) ➡ IR</code>、<code>(PC) + 1 ➡ PC</code><ul><li>取址周期由控制器自动进行，不需要得到指令才进行</li></ul></li><li>间址周期：<code>Ad(IR) ➡ MAR</code>、<code>1 ➡ R</code>、<code>M(MAR) ➡ MDR</code>、<code>(MDR) ➡ Ad(IR)</code><ul><li>间址周期取的是操作数的地址，而不是操作数！</li></ul></li><li>执行周期：各不相同、具体分析</li><li>中断周期：<ul><li>执行周期完成后，只有检测到中断才会进入中断周期</li></ul><ol><li>修改栈顶指针SP减一，送入MAR（保存断点至主存）<code>(SP) - 1 ➡ SP</code>、<code>(SP) ➡ MAR</code></li><li>读写控制<code>1 ➡ W</code></li><li>保存PC内容到主存<code>(PC) ➡ MDR</code></li><li>中断处理，将中断服务程序的入口地址（由向量地址生成部件生成）<code>向量地址 ➡ PC</code></li></ol></li></ul></li><li><p>指令执行方案：</p><ul><li>单指令周期：所有指令周期时间相等，取决于最长那个</li><li>多指令周期：不同指令选用不同执行步骤完成，不定长周期</li><li>流水线周期：指令之间尽量并行（有些指令之间或者指令不同步骤之间没有资源冲突，可以并行）<ul><li>RISC必须实现流水线</li><li>CISC通过优化实现流水线</li></ul></li></ul></li><li><p>数据通路：</p><ul><li>不包含控制部件！！！</li><li>总线结构<ul><li>单总线结构：所有寄存器的输入输出在同一条公共通路上<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109262152377.png" alt=""></li><li>三总线方式：数据总线、控制总线、数据总线</li><li>专用数据通路：减少共享线路、专线专用</li></ul></li></ul></li><li><p>控制器的设计<font color=blue>(重点！！！)</font>：</p><ul><li>硬布线控制器的设计（根据指令、时序以及PSW等，按照时间顺序，由硬件电路产生一些微操作控制信号）：<ul><li>控制单元CU的信号来源：指令译码器、时序信号、执行单元的反馈标志、来自总线的控制信号</li><li>控制器的时序系统：<ul><li>时钟周期：用时钟信号控制节拍发生器，每个节拍内机器可以完成一个或几个需要同时执行的操作</li><li>机器周期：可以视为所有指令执行过程中的一个基准时间，通常以存取周期作为基准时间</li><li>指令周期：取指、间址、执行、中断</li></ul></li><li>CPU控制方式：同步（统一时钟）、异步（无时钟，各自按照自己的速度工作（有前置步骤的可以暂停或”预判“））、联合控制（同步异步结合，大部件同步，小部件异步）</li></ul></li><li>微程序控制器（用软件设计硬件的技术）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109270924588.png" alt=""><ul><li>术语：<ul><li>微命令：控制部件向执行部件发出的控制信号，是构成控制序列的最小单位。<ul><li>例如：打开/关闭控制门电路的电位信号</li></ul></li><li>微操作：执行部件接收到微命令后执行的操作，和微命令是一一对应的<ul><li>微命令是微操作的控制信号，微操作是微命令的执行过程，微操作是执行部件中最基本的操作</li></ul></li><li>微指令：若干微命令的集合，存放在一个控制存储器中。存放微指令的控制存储器的单元被称为微地址。<ul><li>同一CPU周期内，并行执行的一组微命令，存储在控制存储器上，叫做一条微指令</li></ul></li><li>微周期：从读取一条微指令，到执行完成的时间</li><li>微程序：实现一条机器指令功能的微指令序列</li><li><code>程序 ➡ 微程序(机器指令) ➡ 微指令(微周期) ➡ 微命令(微操作)</code></li></ul></li><li>微指令至少包含：<ul><li>操作控制字段：用于产生某一步操作的各种操作控制信号</li><li>顺序控制字段：控制产生下一条要执行的微指令地址</li></ul></li><li>主存储器与控制存储器：<ul><li>主存：RAM，存放程序和数据</li><li>控存：ROM，存放微程序</li></ul></li><li>微地址寄存器（CMAR）和微指令寄存器（CMDR/μIR）<ul><li>类比MAR和MDR</li></ul></li><li><strong>微指令的控制/编码方式</strong>：如何对微指令的控制字段进行编码，以形成控制信号<ul><li>直接编码法：不需要进行译码。其中每一位都代表一个微操作命令，例如控制字段中的某位为1，则代表着控制信号有效，0代表无效。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109270936223.png" alt=""></li><li>字段直接编码法：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109270937176.png" alt=""><ul><li>如图微指令被分成三段，互斥的微命令(微操作)可以放在不同的段，相容的微命令则可以放在同一段内</li><li><strong>每个字段都需要留出一个状态表示此字段无效</strong></li></ul></li><li>字段间接编码法：一个字段的某些微命令需要由另一个字段当中的某些微命令来解释。</li></ul></li><li>微指令格式：<ul><li>水平型微指令：一次能够执行多个并行操作的微命令。<ul><li>直接编码、字段直接编码、字段间接编码都属于这种</li></ul></li><li>垂直型微指令：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109270951299.png" alt=""><ul><li>设置微操作码字段，其规定了微指令的功能，并不强调并行控制功能</li></ul></li></ul></li><li>硬布线控制与微程序控制对比<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109022143070.png" alt=""><ul><li>微程序控制器的时序系统相对简单</li></ul></li></ul></li></ul></li><li><p>指令流水线<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109270956773.png" alt=""></p><ul><li>一条指令的执行一般分为：取指、分析、执行。也可以分成其它步骤，但因保证其并行度</li><li>流水线需要装入时间和排空时间<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109270959379.png" alt=""></li><li>流水线的分类：<ul><li>流水级别分类：部件功能级流水线（CPU内的各部件流水线）、处理机级流水线（子进程流水线）、处理机间流水线（分布式、每个处理机专门完成一种任务）</li><li>功能分类：单功能流水线，多功能流水线</li><li>连接方式分类：静态流水线（同一时间内，流水线的各段只能按照同一种功能的连接方式工作），动态流水线（不同段完成的运算可能不一样，可以提高效率，但控制困难）</li><li>反馈信号分类：线性流水线（无反馈回路）、非线性流水线（存在反馈回路，适合线性递归运算）</li></ul></li></ul></li><li><p>影响流水线性能的因素<font color=blue>(理解)</font>：</p><ul><li>结构相关/资源冲突：多条指令并行过程中争抢同一互斥资源<ul><li>可能发生冲突时，使后一条指令及其后续指令暂停</li><li>增加资源，使指令在不同资源上运行</li></ul></li><li>数据相关/数据冲突：下一条指令可能会用到当前指令的最终结果<ul><li>可能发生冲突时，使后一条指令及其后续指令暂停</li><li>设置<strong>专用通路</strong>，直接将当前指令的运行结果作为下一条指令输入，而不是先存入寄存器再输入。也叫<strong>数据旁路技术</strong></li><li>编译器优化，调整指令顺序</li></ul></li><li>控制相关/控制冲突：例如分支结构中的并行，当前指令未运行完成前，后一条指令无法确定分支的流向<ul><li>分支预测，尽早生成转移目标地址，不对就重新运行错误分支点即可</li><li>同时预取转移成功和不成功两个方向上的目标指令</li><li>加快前提形成条件码</li><li>提高转移方向的猜准率</li></ul></li></ul></li><li><p>流水线性能指标<font color=blue>(理解)</font>：</p><ul><li>吞吐率：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109271027567.png" alt=""></li><li>流水线的加速比：不使用流水线与使用流水线的时间比值</li><li>流水线效率：有效时空面积与总时空面积比值<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109271030344.png" alt=""></li></ul></li><li><p>流水线多发技术（假定指令周期分为四个阶段：<code>取指FI、译码ID、执行EX、回写WR</code>）<font color=blue>(了解)</font>：</p><ul><li>超标量技术<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109271033390.png" alt=""></li><li>超流水线技术<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109271033382.png" alt=""></li><li>超长指令字技术<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109271034924.png" alt=""></li></ul></li></ol><div class="note success flat"></div><h1>tool</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;</span><br><span class="line">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;</span><br><span class="line">四号蓝: &lt;font color=blue size=4&gt;&lt;/font&gt;</span><br><span class="line">红:    &lt;font color=red&gt;&lt;/font&gt; </span><br><span class="line">绿:    &lt;font color=green&gt;&lt;/font&gt;</span><br><span class="line">蓝:    &lt;font color=blue&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">分割线:  </span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">表格:  </span><br><span class="line">|        |      |       |</span><br><span class="line">| ----- | --:  | :----: |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line"></span><br><span class="line">拼图</span><br><span class="line">&#123;% gi 2 2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endgi %&#125;</span><br><span class="line"></span><br><span class="line">便签：  </span><br><span class="line">&#123;% note success %&#125;  </span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">链接:  </span><br><span class="line">🔗</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统考研复习</title>
      <link href="/posts/4c949373/"/>
      <url>/posts/4c949373/</url>
      
        <content type="html"><![CDATA[<h1>第一章 - 计算机系统概述</h1><ol><li><p>操作系统的概念<font color=blue>（了解，选择题不选错就行）</font>：</p><ol><li>控制和管理计算机软硬件</li><li>合理组织调度计算机的工作与资源</li><li>为用户和其它软件提供接口</li></ol></li><li><p>操作系统的基本特征<font color=blue>（了解）</font>：</p><ul><li>并发（<strong>区分并行</strong>）</li><li>共享</li><li>虚拟：一个物理实体变成多个逻辑上的对应物<ul><li>虚拟处理器：并发多道程序，让用户以为有多个处理器</li><li>虚拟存储器：如虚拟内存</li><li>I/O处理器的空分复用技术</li></ul></li><li>异步：多道程序走走停停，以不可预知的速度前进</li></ul></li><li><p>操作系统的目标和功能<font color=blue>（了解）</font></p><ul><li>管理功能：处理机管理、存储器管理、文件管理、设备管理。</li><li>接口功能：<ul><li>命令接口：联机命令接口（cmd）、脱机命令接口（批处理系统的作业说明书）。</li><li>程序接口：由系统调用（也叫广义指令）组成，例如“printf程序调用”由定位内存、显示字符等多个系统调用组成。</li></ul></li><li>扩展机器（不重要）</li><li>系统调用<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109292038825.png" alt=""></li></ul></li><li><p>操作系统发展与分类<font color=blue>（重点关注批处理阶段，其它了解即可）</font></p><ol><li>手工处理阶段：这个阶段<strong>没有操作系统</strong>，所有调度包括程序的装入、允许、结果输出都需要人为干预</li><li>批处理阶段：出现操作系统，为了解决“人（慢）机（快）矛盾”和“CPU（快）与I/O设备（慢）矛盾”而出现<ol><li>单道批处理系统：自动性（磁带上的程序逐个允许，无需人工干预）、顺序性（磁带上的程序依次调入内存、依次按序执行）、单道性（一次只调入一道程序到内存，只有一道程序在运行）</li><li>多道批处理系统：允许多个程序同时（宏观）被调入内存并交替执行。宏观上并行，微观上串行。</li></ol></li><li>分时操作系统：处理机运行时间划分时间片，分配给任务运行。同时、交互、独立、及时性。</li><li>实时操作系统：保证规定时间内完成某项任务。实时性、可靠性。</li><li>分布式计算机系统、个人计算机操作系统。</li></ol></li><li><p>操作系统的运行机制<font color=blue>（重点关注中断和异常部分，其它简单或者在后面章节才展开）</font></p><ul><li>操作系统内核程序（核心态/管态）和用户程序（用户态/目态）<ul><li>核心态可以执行特权指令，而用户态只能执行非特权指令。</li><li>切换要通过程序状态字寄存器PSW（计组）</li><li><code>核心态 ➡ 用户态</code>: 执行一条特权指令,修改程序状态字PSW,主动让出CPU使用权</li><li><code>用户态 ➡ 核心态</code>: 自陷/中断</li></ul></li><li>内核需要实现：<ol><li>时钟管理：CLOCK</li><li>中断机制：<font color=blue>见后面部分</font>，一开始是为了提高CPU利用率（计组-系统总线设计部分），后面也负责核心/用户态切换。</li><li>原语：不可被打断的小程序，因为某些操作被中断会造成大麻烦。</li><li>系统控制的数据结构及处理：快表、索引表、进程控制块等等…</li></ol></li><li>中断与异常<font color=blue>（重点！！！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109292035480.png" alt=""><ul><li><strong>中断是操作系统必须要实现的！！！</strong></li><li>访管/陷入指令：顾名思义，访问管态程序/特权指令的指令，因其可以在用户态下使用，所以不是特权指令</li><li>中断（外中断、相对于CPU来说是“外”）：I/O中断（输入输出完成）、时钟中断<ul><li>内存外存的访问都需要通过系统调用trap触发中断</li></ul></li><li>异常（内中断、相对于CPU来说是“内”、<strong>不能被屏蔽</strong>）：非法操作数（除0、地址越界、算术溢出）、陷入指令（用户程序自己设置，用户态➡核心态）<ul><li>内中断的响应发生在指令执行过程中，且不需要返回断点</li></ul></li></ul></li><li>系统调用：操作系统中提供的实现一些特定功能的小程序。<ul><li>分类就不谈了，没见过考这么细的。</li></ul></li></ul></li><li><p>大内核与微内核<font color=blue>（需要理解）</font>：</p><ul><li>大内核：操作系统的大多数功能都运行在核心态<ul><li>优点：性能优势（想想大部分功能都可以在核心态，也就是更靠近硬件的状态下运行）</li><li>缺点：设计复杂</li></ul></li><li>微内核：操作系统的最基本功能运行在核心态<ul><li>优点：有效分离各功能模块，维护成本大大降低</li><li>缺点：性能问题（需要在用户态和核心态频繁切换）</li></ul></li></ul></li></ol><h1>第二章 - 进程管理</h1><ol><li><p>进程<font color=blue>（超重点！！！）</font>：</p><ul><li>区分<strong>程序</strong>和<strong>进程</strong>:<ul><li>程序：是<strong>静态</strong>的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</li><li>进程（Process）：是动态的，是程序的一次执行过程。</li></ul></li><li><font color=green size=4>进程控制块PCB</font>,以&quot;打开三个QQ进程，操作系统怎么区分他们？&quot;为例:<ul><li>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <font color=red size=4>PID</font>（Process ID，进程ID）</li></ul><ol><li>操作系统要记录PID、进程所属用户ID（UID）——<em>基本的进程描述信息，可以让操作系统区分各个进程</em></li><li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）——<em>可用于实现操作系统对资源的管理</em></li><li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）——<em>可用于实现操作系统对进程的控制、调度</em></li></ol><ul><li><strong>这些信息都被保存在一个数据结构PCB （Process Control Block）中，即进程控制块操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</strong></li></ul></li><li>程序的运行过程: <code>程序文件 ➡ 可执行文件(二进制、机器指令) ➡ 入内存 ➡ 分配PCB ➡ 顺序执行机器指令 ➡ 执行产生的中间数据被放入数据段</code></li><li>一个<strong>进程实体（进程映像）<strong>由</strong>PCB、程序段、数据段</strong>组成。<ul><li><strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）<strong>是</strong>静态</strong>的。</li></ul></li><li><font color=green size=4>进程的特征</font>: 动态性、独立性、并发性、异步性、结构性（PCB、程序段、数据段）</li></ul></li><li><p>进程的状态和转换</p><ul><li>状态<font color=blue>（解释部分看看就行）</font>：<ul><li>运行态。进程正在处理机上运行。在单处理机环境下，一个<strong>时刻</strong>最多只有一个进程处于运行态。</li><li>就绪态。进程已经获得了除了处理机以外的所有资源，一旦得到处理机资源，即可立即运行。处于就绪态的进程可能有多个，通常将他们排成队列即<strong>就绪队列</strong>。</li><li>阻塞态（等待态）。进程正在等待某一事件而暂停运行，如等待某资源（除处理机以外）可用或I/O完成。即使处理机空闲，该进程也不能运行。</li><li>创建态。<strong>进程正在被创建</strong>，尚未转到就绪态。</li><li>结束态。进程正在从系统中消失，可能是进程正常运行结束或者中断退出运行。进程需要结束运行时，首先将进程置为结束态，然后回收资源。</li></ul></li><li>进程状态的转换<font color=blue>（超重点！！！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728151032.png" alt="进程状态的转换"><ul><li>阻塞态只能到就绪态，只有运行态能到阻塞态。</li></ul></li><li>进程的创建：<code>分配进程号、申请PCB ➡ 分配资源（内存等） ➡ 初始化PCB ➡ 进入就绪队列</code></li><li>进程的结束：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机 ➡ 终止子进程 ➡ 剥夺所有资源（还给父进程或操作系统） ➡ 删除PCB</code><ul><li>正常结束、异常结束（异常事件导致无法执行）、外界干预（用户或操作系统请求关闭）</li></ul></li><li>进程的阻塞：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机，保存现场至PCB并修改状态为阻塞态 ➡ 入阻塞队列</code></li><li>进程的唤醒/就绪：<code>阻塞队列找到PCB ➡ 移出阻塞队列，状态改为就绪 ➡ 入就绪队列</code></li></ul></li><li><p>进程的切换：</p><ul><li><strong>状态的切换在核心态！！！</strong></li><li>进程切换过程：<code>保存现场 ➡ 更新PCB ➡ PCB移入相应队列（就绪、等待） ➡ 找到切换进程的进程号，更新其PCB ➡ 运行 ➡ 运行结束 ➡ 根据PCB恢复现场（不一定是那个被替换掉的进程）</code></li></ul></li><li><p>进程的组织</p><ul><li>即要解决怎么将各个进程的PCB组织起来的问题。</li><li>进程控制块PCB：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109282140340.png" alt=""><ul><li>PID（进程号、进程标识符）和UID（用户号、标识进程归属用户）</li><li>进程运行、控制、中断相关的信息</li><li>资源分配清单、处理机相关信息</li></ul></li><li>进程包括：程序控制块PCB、程序段、数据段</li><li>进程的组织方式<font color=blue>（重点！！！）</font>：<ul><li>链接方式：指针。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728151601.png" alt="链接方式"><ul><li>也可以细分，如阻塞队列细分为：打印机阻塞队列、磁盘阻塞队列</li></ul></li><li>索引方式：索引表。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728151920.png" alt="索引方式"></li></ul></li></ul></li><li><p>进程的控制</p><ul><li>创建进程、结束进程、进程状态转换</li><li>原语的“原子性”<ul><li>利用开/关中断实现</li></ul></li><li>原语<font color=blue>（理解）</font>：<ul><li>进程创建原语：<code>分配进程号、申请PCB ➡ 分配资源（内存等） ➡ 初始化PCB ➡ 进入就绪队列</code><ul><li>引起进程创建的事件：用户登录（创建系统父进程）、作业调度（作业放入内存，为其创建进程）、提供服务（某些请求会创建进程，如FTP）、应用请求（用户进程请求创建子进程）</li></ul></li><li>进程终止原语：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机 ➡ 终止子进程 ➡ 剥夺所有资源（还给父进程或操作系统） ➡ 删除PCB</code><ul><li>引起进程终止的事件：正常结束、异常结束、外界干预</li></ul></li><li>进程阻塞原语：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机，保存现场至PCB并修改状态为阻塞态 ➡ 入阻塞队列</code><ul><li>引起进程阻塞的事件：请求的资源不足、等待其它进程</li></ul></li><li>进程唤醒原语：<code>阻塞队列找到PCB ➡ 移出阻塞队列，状态改为就绪 ➡ 入就绪队列</code><ul><li>引起进程唤醒的事件：等待的事件发生</li></ul></li><li>进程切换原语：<code>保存现场 ➡ 更新PCB ➡ PCB移入相应队列（就绪、等待） ➡ 找到切换进程的进程号，更新其PCB ➡ 运行 ➡ 运行结束 ➡ 根据PCB恢复现场（不一定是那个被替换掉的进程）</code><ul><li>引起进程切换的事件：时间片到、高优先级到、进程主动阻塞、进程结束</li></ul></li></ul></li></ul></li><li><p>进程的通信</p><ul><li>共享存储：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728163632.png" alt="共享存储"></li><li>管道通信：相当于缓存<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728164048.png" alt="管道通信"></li><li>信息传递：类似计网，中间一个信箱，信息都发往信息<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728164418.png" alt="信息传递"></li></ul></li><li><p>线程：<code>进程 ➡ 线程</code></p><ul><li>引入线程之后：进程只是资源分配的单位，线程成为处理机的分配单元；</li><li>线程最直接的理解就是“轻量级进程”。</li><li>引入线程后的变化<ul><li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</li><li>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。</li><li>线程则作为处理机的分配单元。</li></ul></li><li>线程的特点/属性：<font color=blue>（理解）</font>：<ul><li>线程不能创建进程</li><li>不拥有系统资源，拥有唯一标识符和线程控制块</li><li>不同线程可以执行相同程序，同一服务程序被不同用户调用，可能创建不同线程</li><li>同一进程的线程共享该进程全部资源（互斥共享）</li><li>线程是处理机的独立调度单位</li><li>线程也有生命周期、阻塞、就绪、运行等状态</li><li>多CPU，各个线程可占用不同CPU</li><li>每个线程都有线程ID、线程控制块（TCB）</li><li>切换同进程的线程，开销小（不用换进程）</li><li>线程共享进程的内存空间，因此其通信甚至无需系统干预</li></ul></li></ul></li><li><p>线程的实现方式<font color=blue>（重点！！！）</font>：</p><ul><li>用户级线程：线程管理工作交由进程，内核意识不到线程的存在<ul><li>用户级线程切换不需要CPU状态转换</li><li>当一个用户级线程被阻塞时，整个进程都被阻塞。多个线程不可在多核处理机上运行</li></ul></li><li>内核级线程：线程的管理工作由内核完成<ul><li>主流方式</li><li>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul></li><li>多线程模型<ul><li><strong>一对一</strong>模型<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728172054.png" alt="一对一模型"><ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul></li><li><strong>多对一</strong>模型<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728172505.png" alt="多对一模型"><ul><li>退化为用户级线程</li><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li><li><strong>重点重点重点</strong>：操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</li></ul></li><li><strong>多对多</strong>模型<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210728172949.png" alt="多对多模型"><ul><li>即提高了并发性，又降低了开销（什么都会就是什么都不会…）</li></ul></li></ul></li></ul></li><li><p>处理机调度：作业调度（高级调度）、中级调度（内存调度）、进程调度（低级调度、<strong>最基本</strong>）<font color=blue>（重要的是计算）</font>：</p><ul><li>三层调度的对比<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210729162951.png" alt="三层调度的对比"></li><li>不能进行调度的场景：中断处理中、进程进入<strong>内核程序临界区</strong>、其它需要完全屏蔽中断的原子操作过程</li><li>剥夺式调度和非剥夺式调度</li><li>周转时间：是指从<strong>作业被提交</strong>给系统开始，到<strong>作业完成为止</strong>的这段时间间隔。<ul><li>它包括四个部分<ol><li>作业在外存后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列上等待进程调度（低级调度）的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</li></ol></li><li><code>（作业）周转时间 = 作业完成时间 – 作业提交时间</code></li><li><code>平均周转时间 = 各作业周转时间之和 / 作业数</code></li><li><code>带权周转时间 = 作业周转时间 / 作业实际运行时间</code></li><li><code>带权平均周转时间 = 带权周转时间 / 作业数</code></li></ul></li></ul></li><li><p>调度算法<font color=blue>（重要的是计算）</font>：</p><ul><li>先来先服务(FCFS)调度算法<ul><li>顾名思义：谁先到谁先被服务</li><li>如图：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109290929702.png" alt=""><ul><li><code>P1、P2、P3、P4</code>依次到达，所以其时序图：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109290933835.png" alt=""></li><li>周转时间：<code>7-0、11-2、12-4、16-5</code>，平均周转时间8.75</li><li>带权周转时间：<code>7/7、9/4、8/1、11/4</code>，平均带权周转时间3.5</li><li>等待时间：<code>0、7-2、11-4、12-5</code>，平均等待时间4.75</li></ul></li><li>特点：<ul><li>不会导致饥饿</li><li>不可剥夺</li><li>长作业有利、短作业不利（排在后面的短作业要等上非常久、但只运行小段时间）</li><li><strong>有利千CPU繁忙型作业、不利于I/0繁忙型作业</strong>（I/O作业往往更加紧急）</li></ul></li></ul></li><li>短作业优先（SJF）算法：<ul><li>短作业优先调度</li><li>如图：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109290929702.png" alt=""></li><li>短作业优先调度SJF没什么好说的<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109291702353.png" alt=""></li><li>最短剩余时间优先SRTN（剥夺式SJF）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109291703123.png" alt=""></li><li>特点：<ul><li>可能“饥饿”</li></ul></li></ul></li><li>高响应比优先（HRRN）：<ul><li><code>响应比 = （等待时间 + 要求服务时间） / 要求服务时间</code></li><li>如图<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109291705026.png" alt=""></li><li>特点：<ul><li>不会“饥饿”</li><li>非抢占式</li></ul></li></ul></li><li>时间片轮转算法：<ul><li>使用分时系统，使用时间片，就绪进程按照到达先后排成队列，依次在时间片内占用处理机，时间片到就释放</li><li>时间片选择很重要，过大就变成了先来先服务，过小就变成了短作业优先</li><li>特点：<ul><li>不会导致饥饿</li><li>抢占式</li></ul></li></ul></li><li>优先级调度算法<ul><li>抢占式、非抢占式都有</li><li>会导致饥饿</li><li>如图：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109291714349.png" alt=""><ul><li>非抢占式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109291715863.png" alt=""></li><li>抢占式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109291716006.png" alt=""></li></ul></li><li>补充：<ul><li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li><li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种。<ul><li>静态优先级：创建进程时确定，之后一直不变。</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。<ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul></li><li>一些常见的系统优先级<ul><li>系统进程优先级<strong>高于</strong>用户进程</li><li>前台进程优先级<strong>高于</strong>后台进程</li><li>操作系统更偏好<strong>I/O型进程</strong>（或称<strong>I/O繁忙型进程</strong>）<ul><li>这是因为<em>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</em></li></ul></li><li>与I/O型进程相对的是<strong>计算型进程</strong>（或称<strong>CPU繁忙型进程</strong>）</li></ul></li></ul></li></ul></li><li>多级反馈调度算法：<ul><li>抢占式、会饥饿</li><li>算法规则：<ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第k 级队列为空时，才会为k+1 级队头的进程分配时间片</li></ol></li><li>在k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k 级队列队尾。</li><li>流程：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108021619391.png" alt="多级反馈队列调度算法"><ol><li><code>P1(8)</code>先到达, 入1级队列. 执行1个单位时间片<code>P1(7)</code>, 进入2级队列.</li><li>1时刻<code>P2(4)</code>到达, 入1级队列. 执行1个单位时间片<code>P2(3)</code>, 进入2级队列.</li><li>2时刻1级队列为空, 则对2级队列进行调度, <code>P1(7)</code>执行2个单位时间片之后入三级队列<code>P1(5)</code>.</li><li>4时刻<code>P2(3)</code>运行到5时刻<code>P2(2)</code>, 此时<code>P3(1)</code>进入, 应该优先调度1级队列, 被剥夺处理机的<code>P2(2)</code>重新放回2级队列.</li><li><code>P3(1)</code>运行1个单位时间<code>P3(0)</code>, 完成并结束该进程.</li><li><code>P2(2)</code>运行2个时间单位<code>P2(0)</code>, 完成并结束该进程.</li><li><code>P1(5)</code>运行4个时间单位<code>P1(1)</code>, 已经位于最下级队列, 回到该队列运行并完成.</li></ol></li></ul></li></ul></li><li><p>进程同步、互斥<font color=blue>（理解！！！）</font>：</p><ul><li>进程同步：直接制约关系，进程间可能需要一种先后顺序或者互相依赖的关系</li><li>进程互斥：间接制约关系，当一个进程访问临界资源的时候，其它进程不能访问<ul><li><strong>一段时间内只允许一个进程使用</strong>的资源叫<strong>临界资源</strong></li></ul></li><li>临界区互斥的实现<font color=blue>（重点！！！）</font>：<ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol></li></ul></li><li><p>进程互斥的软件实现方法<font color=blue>（理解！！！）</font>：</p><ul><li><font color=green size=4>单标志法</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108021757036.png" alt="单标志法"><ul><li>只能按<code>P0 P1 P0 P1 ……</code>这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</li><li>因此，单标志法存在的主要问题是：<strong>违背“空闲让进”原则</strong>。</li></ul></li><li><font color=green size=4>双标志先检查法</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042010911.png" alt="双标志先检查法"><ul><li>先检查是否被占用，然后才自己占用</li><li>若按照<code>①⑤②⑥③⑦….</code>的顺序执行，<code>P0</code> 和 <code>P1</code> 将会同时访问临界区。(即并发进程中,<code>P0</code>执行while后正要标记数组值,这时发生切换…)</li><li>因此，双标志先检查法的<strong>主要问题</strong>是：<strong>违反“忙则等待”原则</strong>。</li><li>原因在于，<strong>进入区</strong>的“检查”和“上锁” 两个处理<strong>不是一气呵成</strong>的。“检查”后，“上锁”前可能发生进程切换。</li></ul></li><li><font color=green size=4>双标志后检查法</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042021519.png" alt="双标志后检查法"><ul><li>先自己占用，然后才检查是否被占用</li><li>若按照<code>①⑤②⑥….</code>的顺序执行，<code>P0</code> 和 <code>P1</code> 将都无法进入临界区</li><li>因此，双标志后检查法虽然 <strong>解决了“忙则等待”</strong> 的问题，但是又 <strong>违背了“空闲让进”和“有限等待”</strong> 原则，会因各进程都长期无法访问临界资源而 <strong>产生“饥饿”</strong> 现象。</li><li>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</li></ul></li><li><font color=green size=4>Peterson算法</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042027612.png" alt="Peterson算法"><ul><li>进入区:<ol><li>主动争取；</li><li>主动谦让；</li><li>检查对方是否也想使用，且最后一次是不是自己说了“客气话”</li></ol></li><li>Peterson 算法用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然<strong>未遵循让权等待</strong>的原则。</li></ul></li></ul></li><li><p>进程互斥的硬件实现方法<font color=blue>（理解！！！）</font>：</p><ul><li><font color=green size=4>中断屏蔽方法</font>：<ul><li>利用<strong>开/关中断</strong>指令实现(与原语的实现思想相同,从进程开始访问临界区到结束访问为止都不允许中断,也就是不能发生进程切换)  <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042055893.png" alt="开/关中断"></li><li>优点: 简单、高效</li><li>缺点: 不适合多处理机; 只适用于操作系统内核进程,不适用于用户进程(开/关中断指令无法在用户态进行,也不能让用户随意使用)</li></ul></li><li>TestAndSetLock指令（TSL）、Swap指令：硬件实现，不允许中断，必须一气呵成</li><li>信号量<ul><li>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 wait(S)和 signal(S)访问， 也可记为 “ P 操作“ 和 “ V 操作“（来自荷兰语proberen 和verhogen）。<strong>其中S即信号量（可以是整型，也可以是复杂的记录型）</strong>。</li><li>信号量其实就是一个变量，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量，<code>P： S-- #若S不为0，则可以使用，资源S的量减少1</code>，<code>V： S++ # 资源使用完毕，释放资源，资源量+1</code>。</li><li>记录型信号量例子：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042151771.png" alt=""><ol><li>P0申请打印机资源，S–</li><li>P0使用打印机时，P1申请，S–</li><li>P1使用打印机时，P2申请，S–，但此时<code>S.value = -1</code>，所以将其挂到等待队列中去</li><li>P3申请，S–，<code>S.value = -2</code>，挂载到等待队列</li><li>此时P0使用完资源，S++，<code>S.value = -1</code>，唤醒等待队列中的一个进程（如P2，将其放入就绪队列，打印机资源分配给它）</li><li>这时P2得到处理机，使用资源并释放，S++，<code>S.value = 0</code>，唤醒P3，P3进入就绪队列，打印机资源分配给P3</li><li>P3得到处理机，使用资源并释放，S++，因为<code>S.value = 1</code>，所以不需要执行唤醒操作</li><li>最后P1得到处理机并使用资源，S++，<code>S.value = 2</code>，不需要执行唤醒操作</li></ol></li><li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value &lt; 0 </code>时表示该类资源已分配完毕，因此进程应<strong>调<br>用 block原语 进行自我阻塞</strong>（当前运行的进程从<strong>运行态➡阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列S.L 中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</li><li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行<code>S.value++</code>，表示资源数加1，若加1后仍是<code>S.value &lt;= 0</code>，表示依然有进程在等待该类<br>资源，因此应<strong>调用 wakeup原语 唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态➡就绪态</strong>）。</li></ul></li></ul></li><li><p>管程<font color=blue>（重要！！！）</font>：</p><ul><li>用共享数据结构来描述临界资源，如：S是共享数据结构，然后take_away()申请一个资源，give_back()归还一个资源</li><li>定义条件变量x，x.wait()表示将自己插入x条件的等待队列（x是否满足条件需要用户自己判断，这里一定会插入），x.signal()表示唤醒一个因为x条件阻塞的进程（一定唤醒，x是否满足条件用户判断）</li></ul></li><li><p>信号量机制实现进程同步和互斥：</p><ul><li>同步：实现进程或代码段的运行“一前一后”<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042253759.png" alt="进程同步"></li><li>前驱：拆分成同步问题：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108042258300.png" alt="前驱关系"></li><li>认为PV操作中V操作自带唤醒功能!!!不然若多个进程互斥访问临界资源时,信号量负数,即使V操作释放了也依然负数,进程无法继续!!!</li></ul></li><li><p>死锁的条件<font color=blue>（重要！！！）</font>：</p><ul><li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放。</li><li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又提出了<strong>新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</li><li><strong>循环等待条件</strong>：存在一种进程资源的<strong>循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。<ul><li><strong>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）</li><li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</li></ul></li></ul></li><li><p>为什么会发生死锁：<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong>。</p></li><li><p><a href="https://chen0495.top/posts/59e4ca55/">🔗银行家算法🔗</a></p></li><li><p>死锁的检测和解除<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108122017602.png" alt=""></p></li><li><p>解除死锁<font color=blue>（重要！！！）</font>：</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol></li></ol><h1>第三章 - 内存管理</h1><ol><li><p>内存管理：</p><ul><li>程序的装入和链接<font color=blue>（理解！！！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108122057849.png" alt="链接"><ol><li>编译：编译程序将用户源代码编译成若干目标模块</li><li>链接：各个模块和所需要的库函数链接起来（形成完整装入模块、形成逻辑地址）<ul><li>静态链接：程序<strong>运行前</strong>，各模块和所需库函数链接，之后不再拆开</li><li>装入时动态链接：<strong>装入过程中</strong>，边装入边链接</li><li>运行时动态链接：程序<strong>运行时</strong>，执行中若需要某模块，才进行链接<ul><li>便于修改更新，便于模块共享</li></ul></li></ul></li><li>装入：模块装入内存（绝对地址）<ul><li><strong>绝对装入</strong>：按照绝对地址寻址<ul><li><em>编译阶段（得到模块的绝对地址）</em></li><li><em>只适用于单道程序环境。</em></li></ul></li><li><strong>静态重定位</strong>：又称可重定位装入。按照相对地址寻址<ul><li>装入后物理地址不再改变（固定分区分配）的才能静态重定位</li><li><em>装入阶段</em></li><li><em>特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</em></li></ul></li><li><strong>动态重定位</strong>：又称动态运行时装入。装入内存后，绝对地址可变，而且程序运行时才进行地址转换。这种方式需要一个重定位寄存器的支持。<ul><li><em>程序执行阶段</em></li><li>重定位寄存器：存放装入模块存放的起始位置</li></ul></li></ul></li></ol></li><li>内存保护<ol><li>CPU中设置上、下限寄存器</li><li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。<em>重定位寄存器中存放的是进程（数据）的起始物理地址</em>。<em>界地址寄存器中存放的是进程（数据）的最大逻辑地址</em>。</li></ol></li></ul></li><li><p>连续分配管理方式<font color=blue>（了解）</font>：</p><ul><li>连续分配（分配一个连续的内存空间）<ul><li>单一连续分配（将内存分为系统区/用户区，系统区存操作系统，<strong>用户区只有一道用户程序</strong>）</li><li>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC 操作系统MS-DOS）。</li><li>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</li></ul></li><li><strong>固定分区分配</strong><ul><li>分区大小也可以不等，但必须予以规定，即总的来说固定。如：较多小分区、适量中分区、少量大分区</li><li>优点：无外部碎片</li><li>缺点：程序过大时一个分区不够、主存利用率低、内部碎片</li></ul></li><li><strong>动态分区分配</strong><ul><li>进程装入时，根据程序大小动态建立分区</li><li>程序运行时可以改变物理位置</li><li>优点：无内部碎片</li><li>缺点：外部碎片（紧凑技术）</li></ul></li></ul></li><li><p>动态分区分配算法<font color=blue>（理解）</font>：</p><blockquote><p>首次适应算法</p><blockquote><ul><li>思想: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li><li>算法: 空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的<strong>第一个空闲分区</strong>。</li></ul></blockquote><p>最佳适应算法</p><blockquote><ul><li>思想: 优先使用能够满足要求的<strong>最小的空闲分区</strong></li><li>算法: 空闲分区<strong>按容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul></blockquote><p>最坏(最大)适应算法</p><blockquote><ul><li>思想: 优先使用能够满足要求的<strong>最大的空闲分区</strong>,以使得外部小碎片数量问题得到缓解.</li><li>算法: 空闲分区<strong>按容量递减</strong>次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul></blockquote><p>邻近适应算法</p><blockquote><ul><li>思想: 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都<strong>从上次查找结束的位置开始检索</strong>，就能解决上述问题。</li><li>算法: 空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li></ul></blockquote><p>总结</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108131510981.png" alt="总结"><br><font color=blue size=4><em>综合来看，四种算法中，首次适应算法的效果反而更好</em></font></p></blockquote></blockquote></li><li><p>分页<font color=blue>（了解）</font>：</p><ul><li>将内存空间划分为<strong>大小相等的分区</strong>, 每个分区就是一个&quot;<strong>页框</strong>&quot;(= 页框 = 页帧 = 内存块 = 物理块 = 物理页), 页框号从0开始。</li><li>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，<strong>页号也是从0开始,与页框号一一对应.</strong><ul><li><em>逻辑地址分成很多页，页表项 = {页号：物理块号/页框号/内存块号}</em></li><li>页表项大小与页面大小没有直接联系！但由页表项大小可以推出逻辑空间大小，间接得出页面大小！<ul><li>认为<code>页面个数 = 页面大小 / 页表项大小</code></li></ul></li></ul></li><li>页表寄存器（PTR）：<strong>方便将逻辑地址转换为物理地址</strong>。存放页表在内存中的起始地址F 和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器</li><li><strong>页表</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301852851.png" alt=""></li></ul></li><li><p>快表</p></li><li><p><a href="https://blog.csdn.net/sjxgghg/article/details/107726093">🔗二级页表🔗</a> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301845847.png" alt=""></p></li><li><p>分段存储：分段大小不定,分页大小固定.</p><ul><li>段表：每个进程都有一张逻辑空间与内存空间的映射的段表，每个段表项对应进程的一段，段表项记录了该段在内存中的始址和长度<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301854406.png" alt=""><ul><li><code>段表内容 = 段号（隐含）、段长、本段在主存中的位置</code></li></ul></li></ul></li><li><p>段页式管理</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table></li><li><p>虚拟内存<font color=blue>（了解）</font>：<br>虚拟存储技术和交换技术很像，乍一看都是换入换出，把暂时不需要用的数据换出内存，将需要用到的数据换入内存，从而实现逻辑上内存的扩充。二者之间的区别是，虚拟存储技术是在一个作业运行的过程中，将作业的数据进行换入换出。王道老师举得例子就是玩儿游戏。这儿换一个游戏，比如玩儿DOTA，停留在场景A的时候，场景B的数据不需要用到，所以不放在内存，转换到场景B的时候再把场景B的数据放入内存。而交换技术是内存紧张时，换出某些进程，腾出内存空间，换入其他进程。换而言之，交换技术是在不同的进程（作业）间的，虚拟存储技术是在一个作业间的。另外提一嘴，覆盖技术也是在同一个程序或进程中的。<br>引用一个大哥的话，“<strong>交换技术是以进程为单位</strong>，若进程所需内存大于系统内存 ，则此进程无法进行。而<strong>虚拟存储是以页或段为单位</strong>，是把进程再分为页或段对内存进行分化，若进程所需内存大于系统内存，进程也可以运行，因为该进程的一部分可换到外存上”，这个总结的挺好的。(否则我以4G的老年机怎么可能运行十几G的游戏23333)</p></li><li><p>请求分页管理方式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108141422518.png" alt="请求分页"></p><ul><li>缺页时，请求从外存上调入缺失的页。</li></ul></li><li><p>页面置换算法<font color=blue>（理解！！！）</font>：</p><blockquote><p>最佳置换算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108141434736.png" alt="最佳置换算法"></p></blockquote><p>先进先出置换算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108141438152.png" alt="先进先出置换算法"><br>只有先进先出算法会产生<strong>Belady异常</strong>, 即可用内存块增加, 缺页次数反而增加的现象.</p></blockquote><p>最近最久未使用置换算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108141443127.png" alt="最近最久未使用置换算法"></p></blockquote><p>时钟置换算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108141456296.png" alt="时钟置换算法"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108141510606.png" alt="改进时钟置换算法"></p></blockquote></blockquote></li><li><p>页面分配策略和调页时机<font color=blue>（重要！）</font>：</p><ul><li>页面分配策略（物理块数即页框数、驻留集大小）：<ul><li>固定分配全局置换<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301907172.png" alt=""></li><li>可变分配全局置换<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301909268.png" alt=""></li><li>可变分配局部置换<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301909435.png" alt=""></li></ul></li><li>调页时机：<ul><li>预调页策略：把预计不久将被访问的页面调入，成功率55开</li><li>请求调页：进程提出缺页时，才调入</li></ul></li><li>调页来源：<ul><li>对换区充足：从对换区调入可以提高速度</li><li>对换区不足：不会被修改的文件从文件区调入，可能被修改的文件换入对换区，再从对换区调入</li><li>UNIX方式：进程相关文件访问文件区，没有运行的页面从文件区调入，曾经运行过但被换出的页面放在对换区</li></ul></li></ul></li></ol><h1>第四章 - 文件管理</h1><ol><li><p>文件的结构：数据项（描述某个属性的值，如文件大小是10KB、文件名是1.txt等）、记录（一组相关数据项的集合，如一个文件包含文件名、后缀名/格式、大小等）、文件（有结构文件、无结构文件）</p><ul><li><code>数据项 ➡ 记录 ➡ 文件</code></li></ul></li><li><p>文件的属性：名称、标识符（计算机识别的唯一标签，用户不可见）、类型（格式）、位置、大小、保护、其它（时间、日期、归属用户等标识）</p></li><li><p>文件控制块和索引节点<font color=blue>（理解！！！）</font>：</p><ul><li>文件控制块（FCB）：用来存放控制文件需要的各种信息的数据结构，实现“按名存取”<ul><li>包含：基本信息（文件名、文件物理位置、逻辑结构、物理结构等）、存取控制信息（文件存取权限、安全）、使用信息（文件建立信息、修改时间）</li></ul></li><li>索引节点（检索文件时，不需要将文件调入内存，而只是查找由目录项、文件描述信息等形成的叫做索引节点的数据结构）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108161617195.png" alt="索引节点"><ul><li>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</li><li>磁盘索引节点：文件主标识符、文件类型（目录、文件、ISO）、文件存取权限、文件物理地址、文件大小、<strong>文件链接计数（文件系统中指向该文件的快捷方式等）</strong>，文件存取/修改时间</li><li>文件打开后索引节点增加的信息：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109301957667.png" alt=""></li></ul></li><li>索引表查找到的是逻辑地址</li></ul></li><li><p>文件共享<font color=blue>（理解！！！）</font>：</p><ul><li>基于索引节点的共享（硬链接）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302016546.png" alt=""> 如共享文件<code>D:\MATH\1.txt</code>的物理地址及其它文件信息不再放在目录项当中，而是放在索引结点当中（目录项中关于该文件就只会有：文件名、指向改索引结点的指针）。需要共享给其它文件夹<code>D:\ENGLISH\ </code>时在文件目录里增加一项指针指向那个索引节点即可<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302016761.png" alt=""></li><li>基于符号链的共享（软连接）：创建一个<strong>快捷方式</strong>（内含原文件路径），将快捷方式加入要共享到的路径下即可</li></ul></li><li><p>目录的实现：线性列表（文件名：文件指针）、哈希表（哈希值：文件指针）</p></li><li><p>存储空间<strong>分配</strong>方式（在磁盘上的物理存储方式）<font color=blue>（重点！！！）</font>：</p><ul><li>连续分配<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302024434.png" alt=""><ul><li>记录文件的<strong>起始块号</strong>和<strong>长度</strong></li><li>支持顺序访问和随机(直接)访问</li><li>连续分配的文件块物理相邻,所以方便磁盘读取</li><li>不方便文件的拓展(当前连续分配块之后的空闲地址块可能不够)</li><li><strong>存储空间利用率低,产生磁盘碎片</strong></li></ul></li><li>链接分配<ul><li><em>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</em></li><li><strong>隐式链接</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302025602.png" alt=""><ul><li>记录<strong>起始块号</strong>和<strong>结束块号(或者长度)</strong>,</li><li><strong>每个磁盘块(除最后)都保存有一个指针指向下一个盘块</strong>.</li><li>只支持顺序访问,查找效率低</li><li>不会产生碎片问题、方便拓展文件</li><li>指针也要占用盘块少量空间</li></ul></li><li><strong>显式链接</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302027061.png" alt=""><ul><li>将隐式链接盘块尾的指针用文件分配表(FAT)来表示</li><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间。</li></ul></li></ul></li><li>索引分配<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302030928.png" alt=""><ul><li>在显示链接的基础上，将文件分配表变成索引块存在盘块上，目录信息直接指向索引盘块</li><li>优化方式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302036504.png" alt=""></li></ul></li><li>文件分配方式比较<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302032592.png" alt=""></li></ul></li><li><p>空闲空间管理<font color=blue>（重点！！！）</font>：</p><ul><li><strong>空闲表法</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302038406.png" alt=""></li><li><strong>空闲链表法</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108162121777.png" alt=""><ul><li>空闲盘块链</li><li>空闲盘区链</li></ul></li><li><strong>位示图法</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108162130254.png" alt=""></li><li><strong>成组链接法</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302043678.png" alt=""><ul><li>把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区则保存另一顺序扇区的地址，如此继续，直到所有空闲扇区都链接上</li><li>超级块：一般放在卷头，开机时超级块会被读入到主存，并保持主存和辅存超级块的一致性。</li></ul></li></ul></li><li><p>磁盘的结构<font color=blue>（理解）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171506931.png" alt="磁盘的结构"></p><ul><li>磁盘以簇为分配单位进行空间分配!</li><li><strong>寻找时间（寻道时间）T_s</strong>：在读/写数据前，将磁头移动到指定磁道所花的时间<ol><li>启动磁头臂是需要时间的。假设耗时为s；</li><li>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间<code>T_s = s + m * n</code></li></ol></li><li><strong>延迟时间T_r</strong>：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（单位：转/秒，或转/分），则平均所需的延迟时间<code>T_r = (1/2)*(1/r) = 1/2r</code></li><li><strong>传输时间T_t</strong>：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。则：传输时间<code>T_t = (1/r) * (b/N) = b/(rN)</code></li><li><font color=blue size=4>可以看到操作系统唯一能够影响的只有寻道时间, 所以寻道算法很重要…</font></li></ul></li><li><p>磁盘调度算法<font color=blue>（重点！！！）</font>：</p><blockquote><p>先来先服务(FCFS)</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171519677.png" alt="先来先服务"></p></blockquote><p>最短寻找时间优先(SSTF)</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171520001.png" alt="最短寻找时间优先"></p></blockquote><p>扫描算法(SCAN)</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171521264.png" alt="扫描算法"></p></blockquote><p>LOOK调度算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171524120.png" alt="LOOK调度算法"></p></blockquote><p>C-SCAN算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171527604.png" alt="C-SCAN算法"></p></blockquote><p>C- LOOK算法</p><blockquote><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171528987.png" alt="CLOCK算法"></p></blockquote></blockquote></li><li><p>减少磁盘延迟时间的方法：扇区交替编号，因为磁头在读/写完一个数据块时（往往是一个扇区），需要经过短暂的处理时间才能继续读/写下一块</p></li><li><p>磁盘的管理</p><ul><li>磁盘初始化: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108171551683.png" alt="磁盘初始化"><ul><li>物理(低级)格式化：划分扇区、扇区校验码、分区</li><li>逻辑格式化：创建文件系统、根目录、初始化存储空间管理的数据结构（位示图、空闲分区表）</li></ul></li><li>引导块: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302057927.png" alt=""></li><li>坏道</li></ul></li></ol><h1>第五章 - I/O管理</h1><ol><li><p>I/O设备分类<font color=blue>（了解）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302059335.png" alt=""></p><ul><li>块设备。<strong>以数据块为存取单位</strong>，属于<strong>有结构</strong>设备。传输速率<strong>高</strong>，<strong>可寻址（随机读写）</strong>。<ul><li>硬盘、蓝光光盘、U盘</li></ul></li><li>字符设备。<strong>以字符为存取单位</strong>，属于<strong>无结构</strong>设备。传输速率<strong>低</strong>，<strong>不可寻址（不可随机读写）</strong><ul><li>打印机、网络设备、鼠标以及大多数与磁盘不同的设备</li></ul></li></ul></li><li><p>I/O控制方式<font color=blue>（理解！！！）</font>：</p><ul><li><strong>程序直接控制方式</strong>：每次读一个字的数据，对读入的每个字，CPU都要对外设状态循环检查<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302106898.png" alt=""><ul><li>读写单位：<strong>字</strong></li><li>优点：简单</li><li>缺点：CPU全程负责I/O设备，效率极低。CPU和I/O只能串行</li></ul></li><li><strong>中断驱动方式</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302111116.png" alt=""><ul><li>读写单位：<strong>字</strong></li><li>优点：CPU效率比程序直接控制高</li><li>缺点：数据的传输需要经过CPU，仍然消耗CPU的时间</li></ul></li><li><strong>DMA方式</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302114733.png" alt=""><ul><li>读写单位：<strong>数据块</strong></li><li>在I/O设备和内存间开辟数据通路，彻底解放CPU</li><li>设备直接送入内存</li><li>只有当一个或多个数据块开始/结束时，CPU才会干预</li><li>DMA控制器的组成：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302117102.png" alt=""><ul><li>命令/状态寄存器（CR）。用来接收CPU发来的控制信息，或设备的状态</li><li>内存地址寄存器（MAR）。输入时，存放数据将要放到内存的起始目标地址；输出时，存放数据由内存到设备的内存源地址。</li><li>数据寄存器（DR）。暂存设备到内存或内存到设备的数据</li><li>数据寄存器（DC）。记录本次要传输的字（节）数</li></ul></li></ul></li><li><strong>通道控制方式</strong>：设置一个专门负责I/O的处理机，这个处理机就叫通道<ul><li>读写单位：一组数据块</li><li>优点：完全解放CPU，通道只需要接收CPU的I/O任务即可</li><li>缺点：实现复杂</li></ul></li><li>DMA与通道的区别：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302126090.png" alt=""></li></ul></li><li><p>I/O软件的层次结构<font color=blue>（了解）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108172209009.png" alt=""></p><ul><li>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。<ul><li>向上层提供统一的调用接口（如read/write系统调用）</li><li>设备的保护</li><li>差错处理</li><li>设备分配与回收</li><li>数据缓冲区管理</li><li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</li></ul></li><li>设备驱动程序<ul><li>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等</li></ul></li><li>中断处理程序</li></ul></li><li><p>设备控制器的组成<font color=blue>（了解）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302129560.png" alt=""></p></li><li><p>I/O调度：</p><ul><li>通过I/O调度改善系统整体性能，使得进程之间公平共享设备访问，减少I/O的平均等待时间</li><li>使用主存或者磁盘上的存储空间的技术，如：缓存、高速缓存、假脱机等改善计算机效率</li></ul></li><li><p>磁盘高速缓存和缓冲区<font color=blue>（重点！！！）</font>：</p><ul><li>磁盘高速缓存：<ul><li>逻辑上属于磁盘，物理上属于驻留在内存中的盘</li><li>在内存中的两种形式：<ul><li>在内存中开辟出一个单独的存储空间，大小固定</li><li>未利用的内存空间作为缓冲池，供请求分页系统和磁盘I/O共享</li></ul></li></ul></li><li>缓冲区：<ul><li>缓和CPU与I/O之间的速度差异矛盾、提高CPU与I/O的并行度、减少CPU中断的频率、解决基本数据单元大小不匹配问题</li><li>实现：<ul><li>硬件缓冲器（成本过高）</li><li>内存缓冲区</li></ul></li><li>分类：<ul><li>单缓冲：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302142194.png" alt=""><ul><li><code>T：I/O ➡ 缓冲区</code>，<code>M：缓冲区 ➡ 用户区</code>，<code>C：CPU处理</code></li><li>使用时间<code>MAX(C , T) + M</code></li></ul></li><li>双缓冲：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302145928.png" alt=""><ul><li>使用时间<code>MAX(C + M , T)</code></li></ul></li><li>循环缓存：包含多个大小相等的缓冲区，通过指针首位相连形成环状。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108172252635.png" alt=""></li><li>缓冲池：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302149489.png" alt=""><ul><li>缓冲区分为三个队列：空缓冲、输入缓冲、输出缓冲。</li><li>缓冲池包含四种缓冲区：收容输入、收容输出、提取输入、提取输出</li></ul></li></ul></li></ul></li><li>高速缓存和缓冲区的对比：<ul><li>相同点：速度都介于高速设备和低速设备之间</li><li>不同点：<ul><li>数据来源：高速缓存存放的是低速设备上的某些数据的复制；缓冲区存放的是低速设备传给高速设备的数据</li><li>数据目标：高速缓存放的是高速设备经常要访问的（低速设备）数据，若高速缓存中没有，高速设备就直接访问低速设备；高速设备和低速设备的双向通信都经过缓冲区，高速设备永远不会直接访问低速设备<ul><li>数据流向：<code>高速设备 ⬅ 高速缓存 ⬅ 低速设备</code>、<code>高速设备 ↔ 缓冲区 ↔ 低速设备</code></li></ul></li></ul></li></ul></li></ul></li><li><p>设备分配的数据结构<font color=blue>（了解、类比Windows的设备管理器！！！）</font>：</p><ul><li>设备控制表（DCT）：一个设备控制表对应一个设备，控制表是设备的各项属性<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302157427.png" alt=""></li><li>控制器控制表（COCT）：记录某个设备控制器的具体信息<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302159626.png" alt=""></li><li>通道控制表（CHCT）：记录某个通道设备的具体信息<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109302201205.png" alt=""></li><li>系统设备表（SDT）：记录已经连接到系统的所有物理设备的情况</li></ul></li><li><p>设备分配的策略（发挥效率，避免死锁）：</p><ul><li>静态：设备一次性分配给相应的作业，直到作业结束<ul><li>没有死锁，但设备利用率低</li></ul></li><li>动态：进程执行过程中根据需要进行分配<ul><li>设备利用率高，但算法不当会导致死锁</li></ul></li><li>独占设备一般静态分配，共享设备一般动态分配。</li></ul></li><li><p>设备分配的安全性：</p><ul><li>安全分配方式：进程发出I/O请求后立即阻塞（无条件），I/O完成后唤醒<ul><li>CPU和I/O设备串行工作</li></ul></li><li>不安全分配方式：进程发出I/O请求后继续运行，需要时发出第二个、第三个请求<ul><li>进程推进速度快，但可能产生死锁</li></ul></li></ul></li><li><p>假脱机技术（SPOLLing）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202108172224131.png" alt="假脱机技术"></p><ul><li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</li></ul><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</li></ol></li><li><p>设备分类：独占设备、共享设备、虚拟设备。</p><ul><li><strong>独占设备</strong>: 一个时段只能分配给一个进程（如打印机）</li><li><strong>共享设备</strong>: 可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li><li><strong>虚拟设备</strong>: 采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使<br>用（如采用SPOOLing技术实现的共享打印机）</li></ul></li></ol><h1>新考点</h1><ol><li>用户进程<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112150951671.png" alt=""></li><li>分层操作系统<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112150955141.png" alt=""><ul><li>便于维护,增加一层</li><li>难以定义层边界</li></ul></li><li>模块操作系统<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112150957787.png" alt=""> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112150958580.png" alt=""></li><li>外核<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151002193.png" alt=""></li><li>虚拟机<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151008724.png" alt=""><ol><li>第一类虚拟机管理程序: 内核态</li><li>虚拟机: 用户态(以为自己在内核态)</li><li>第二类虚拟机即我们常用的虚拟机软件,第一类虚拟机会直接管理硬件.第二类虚拟机管理程序运行在用户态</li></ol></li><li>操作系统引导: 运行RAM自举程序,将操作系统内核部分从磁盘加载到内存.</li><li>虚拟文件系统: 操作系统可能有多个文件系统,其调用的接口各不相同,因此引入虚拟文件系统VFS,用户进程只需使用VFS提供的接口,VFS负责文件操作和将结果返回给用户进程</li></ol><h1>tool</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;</span><br><span class="line">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;</span><br><span class="line">红:    &lt;font color=red&gt;&lt;/font&gt; </span><br><span class="line">绿:    &lt;font color=green&gt;&lt;/font&gt;</span><br><span class="line">蓝:    &lt;font color=blue&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">分割线:  </span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">表格:  </span><br><span class="line">|        |      |       |</span><br><span class="line">| ----- | --:  | :----: |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line"></span><br><span class="line">拼图</span><br><span class="line">&#123;% gi 2 2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endgi %&#125;</span><br><span class="line"></span><br><span class="line">便签：  </span><br><span class="line">&#123;% note success %&#125;  </span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">链接:  </span><br><span class="line">🔗</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络考研复习</title>
      <link href="/posts/a01c1709/"/>
      <url>/posts/a01c1709/</url>
      
        <content type="html"><![CDATA[<h1>第一章 - 网络体系结构</h1><ol><li><p>计算机网络的概念<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210701210733.png" alt="计算机网络概念"></p><ul><li>是一个将分散的、具有独立功能的计算机系统，通过<font color=red>通信设备与线路</font>连接起来，由功能完善的<strong>软件</strong>实现<font color=green>资源共享</font>和<font color=green>信息传递</font>的系统。</li><li><font color=blue>直观理解为“网”：点（终端、路由等）和线（物理线路、无线网络等）</font></li><li>计算机网络的3种不同定义<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109071950860.png" alt=""><ul><li><font color=blue>上图不需要记,只需要知道三者的侧重点即可</font></li><li>广义观点只侧重<strong>资源共享</strong>；资源共享观点则侧重<strong>独立、互联、共享</strong>；透明观点只侧重<strong>整体性/透明性</strong>，意指网络作为一个网状系统不被人感知。</li></ul></li></ul></li><li><p>计算机网络的功能：数据通信（<strong>最基本最主要的功能</strong>）、资源共享、分布式处理、可靠性、负载均衡。</p><ul><li>后两者可视为分布式处理的作用</li><li><font color=blue>选择题能选对就行</font></li></ul></li><li><p>计算机网路的组成：软件、硬件、协议（负责协调软硬件工作）。</p><ul><li><font color=blue>看看就行</font></li></ul></li><li><p>计算机网络的分类<font color=blue>（了解就行）</font></p><ul><li>按作用范围划分：广域网（WAN，几十公里~几千公里）、城域网（MAN，街区/城区）、局域网（LAN，公司）、个人区域网（PAN，家庭）。</li><li>传播技术划分：广播式网络（广播技术，如：局域网）、点对点网络（交换技术，如：广域网）。</li><li>拓扑结构划分：总线形、星形、环形、网状形<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210701211933.png" alt="网络拓扑结构"></li><li>其它的划分方法有（不重要）：<ul><li>按使用者分类： 公用网和专用网</li><li>按交换技术分类： 电路交换（电话）、报文交换（存储转发）、分组交换（切分报文，分组转发）</li><li>按传输介质分类： 有线（双绞线、同轴电缆）和无线（蓝牙、微波、无线电）</li></ul></li></ul></li><li><p>计算机网络标准化及其相关组织：  <font color=blue>新大纲已删除</font></p></li><li><p>计算机网络性能指标<font color=blue>（要会计算！！！）</font> :</p><ul><li>速率（bit/s）: 单位时间内通过的比特位数</li><li>带宽（bit/s）: 单位时间内<strong>最高</strong>可通过的比特位数<ul><li><em>注意是发射速率，要与传播速率区分开来，比如某设备间1s才允许传输1bit的数据，但其传播速率可能接近光速</em></li></ul></li><li>吞吐量: 单位时间内通过某个网络的数据量</li><li>时延<font color=blue>重点</font>: <code>发送时延 + 传播时延 + 排队时延 + 处理时延</code><ul><li>发送时延, 又叫<strong>传输时延,与传播时延一字之差,注意区分</strong>,发送一串数据到链路上的时间。</li><li>传播时延, 是一个比特从链路一端到达另一端所用的时间。</li><li>排队时延, 数据进入路由器后，需要在路由器的输入队列中等待处理，然后还要在输出队列中等待转发。</li><li>处理时延, 是检查数据完整性、找到数据出口所用的时间</li></ul></li><li>时延带宽积: <code>传播时延 × 带宽</code>，即某段链路最多有多少个比特</li><li>往返时延RTT: 从开始发送, 到发送方收到接收方的确认信息所用时间</li><li>利用率: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210701214826.png" alt="利用率"></li></ul></li><li><p>网络分层:</p><ul><li>分层原则<font color=blue>(不重要)</font></li><li>基本概念：<ul><li>实体：可以接收和发送信息的硬件或者软件进程。</li><li>不同机器上的同一层叫对等层，同一层的实体叫对等实体。</li><li>下次实现的功能为上层服务（从下往上1到n层）</li><li>SDU服务数据单元: 就是有效数据,本来要传输的那部分数据.</li><li>PCI协议控制信息: 就是规定了协议需要怎么操作的信息.</li><li>PDU协议数据单元: SDU + PCI, 对等层次之间传送的数据单位.</li></ul></li><li>分层含义<font color=blue>(理解)</font>：第一层（最底下）为第二层提供服务，第二层为第三层提供服务（第二层的功能实现依赖第一层），第三层为第四层提供服务（第三层的功能实现直接依赖第二层，间接依赖第一层）…以此类推。</li></ul></li><li><p>协议、接口、服务的概念<font color=blue>(重点！！！)</font>：</p><ul><li>协议：对等实体间的通信规则，结构上看是水平的。<ul><li><em>不对等实体间没有协议</em></li></ul></li><li>接口(也叫<strong>服务访问点</strong>)：同一计算机内相邻两层之间的通信规则，结构上看是垂直的。<ul><li><em>不能跨层定义接口</em></li></ul></li><li>服务：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109082024566.png" alt=""><ul><li>TCP：面向连接 &amp; 可靠</li><li>UDP：无连接 &amp; 不可靠</li><li>PPP：面向连接 &amp; 不可靠</li><li>无连接 &amp; 可靠：在UDP基础上实现</li></ul></li></ul></li><li><p>OSI参考模型<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702152844.png" alt="OSI"></p><ul><li><strong>除物理层外,都逐层需要添加控制信息</strong></li><li>端到端和点到点<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211210757.png" alt=""></li><li>物理层<ul><li>传输单位：比特流</li><li>协议：EIA-232C、EIA/TIA RS-449、CCITT的X2.1等（大于五个字母…）</li></ul></li><li>数据链路层<ul><li>传输单位：帧</li><li>需要完成：组帧、差错控制、流量控制、传输管理（后三个都理解为对帧的控制）</li><li>协议：SDLC、HDLC、PPP、STP、帧中继</li></ul></li><li>网络层：<ul><li>传输单位：数据报</li><li>IP数据报在下层数据链路层被拆分组装成帧</li><li>比链路层后三个多了拥塞控制，因为网络层需要考虑网络波动问题</li><li>协议：IP、IPX、ICMP、ARP、RARP、OSPF</li></ul></li><li>传输层：<ul><li>传输单位：报文段（TCP）或者用户数据报（UDP）</li><li>资源子网与通信子网的桥梁</li><li>协议：TCP、UDP</li></ul></li><li>会话层：<ul><li>负责建立、管理、撤销会话</li><li><strong>使用校验点可实现断线续传</strong></li></ul></li><li>表示层：<ul><li>负责数据压缩、加密、解密、数据格式变换。</li></ul></li><li>应用层：<ul><li>为特定网络应用提供访问OSI环境的手段</li><li>协议：FTP、SMTP、HTTP</li></ul></li></ul></li><li><p>TCP/IP参考模型<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702155201.png" alt=""></p></li><li><p>TCP/IP和OSI的区别<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702155258.png" alt="异同"></p><ul><li>网络层是点到点，所以必需要无连接；而传输层是端到端，需要面向连接。</li><li>TCP/IP注重传输层,而OSI注重网络层</li></ul></li><li><p>考研通用模型<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702155705.png" alt="五层参考模型"></p></li><li><p>报文流与字节流的区别（面向连接且可靠）：报文流会区分边界，字节流不会。例如发送<code>1024B × 2</code>的报文数据，报文流会接收2个1024B的报文，字节流会把接收的2048B作为整体。</p></li><li><p>网桥、交换机（多接口网桥）都是链路层设备；路由器是网络层设备；中继器，集线器（多口中继器）是物理层设备。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210711202718.png" alt=""></p></li><li><p>因特网是广域网、以太网（采用CSMA/CD）是局域网。</p></li></ol><div class="note success flat"><p>习题：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109082110195.png" alt="16"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211135937.png" alt="A16"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702160353.png" alt="23"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702160632.png" alt="A23"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702162206.png" alt="17"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702162218.png" alt="A17"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702164259.png" alt="2"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702164927.png" alt="A2"></p></div><h1>第二章 - 物理层</h1><ol><li><p>物理层的特性<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210702170012.png" alt="物理层特性"></p></li><li><p>编码和信道</p><ul><li>编码：模拟信号➡数字信号；调制：数字信号➡模拟信号</li><li>信道：是信号的传输媒介，其有方向。所以一台物理线路往往包含两条信道（发送和接收）。<ul><li><code>信源、信道、信宿</code>➡<code>头、中介、尾</code></li></ul></li><li>数字信道上的传输（基带传输）、模拟信道上的传输（宽带传输，例子当然是宽带-光信号…）</li></ul></li><li><p>信道的三种通信方式：</p><ul><li>单工通信，只有一个方向的通信而没有反方向的交互。<strong>需要一条信道。</strong></li><li>半双工/双向交替通信，通信双方都能收发信息，但不能同时发送和接收。<strong>需要两条信道</strong>，信道是有方向的，所以是两条。</li><li>全双工/双向同时通信，通信双方可以同时发送和接收信息。<strong>需要两条信道。</strong></li></ul></li><li><p>奈氏准则（奈奎斯特定理）<font color=blue>(重点！！！)</font>：理想低通（无噪声、带宽有限）环境下，极限码元传输速率为2W波特，则极限传输速率为<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109082203384.png" alt=""></p><ul><li>注意区分带宽V和<strong>采样频率</strong>!!!采样频率不需要乘上2.</li></ul></li><li><p>香农公式<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109082205049.png" alt=""></p><ul><li>注意分贝表示的信噪比：<code>S/N = 100，10 * log(10,S/N) = 20dB = 20分贝</code></li></ul></li><li><p>数据编码方式<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109091911405.png" alt=""></p><ul><li>归零编码（RZ）：<ul><li>图中描述的是单极性归零码<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109091927540.png" alt=""></li><li>双极性归零码<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109091939281.png" alt=""></li></ul></li><li>非归零编码（NRZ）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109092002029.png" alt=""><ul><li>对于计算机网络，宁愿利用这根传输线传输数据信号，也不愿意用来传输时钟信号，因此，不归零编码存在时钟同步问题</li></ul></li><li>反向非归零编码（NRZI）<ul><li>信号翻转代表0，不变代表1</li><li>例如USB2.0采用NRZI编码</li></ul></li><li>曼彻斯特编码<ul><li>下沿表示1，上沿表示0</li><li>以太网使用</li></ul></li><li>拆分曼彻斯特编码<ul><li>前半个码元和上一个码元的后半部分不同就是1，相同就是0</li><li>局域网、抗干扰</li></ul></li><li>4B/5B编码<ul><li>发射5位（32种状态）数据，其中16种状态（4位映射到5位）是有效数据，其它16种状态是控制信号</li></ul></li></ul></li><li><p>数据调制方式<font color=blue>(重点！！！)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109092010179.png" alt=""></p><ul><li>混合调制方式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109092011430.png" alt=""><ul><li>习题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109092014145.png" alt=""></li><li><code>4 * 4 = 16</code>种状态，表示需要4个比特位，所以<code>速率 = 1200 * 4 = 4800bit/s</code></li></ul></li><li>PCM调制（却是编码、对音频信号编码）模拟信号编码为数字信号时，为了使信号不失真，<code>f采样频率 ≥ 2f信号频率</code></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109092020992.png" alt=""></li></ul></li><li><p>电路交换、报文交换、分组交换<font color=blue>(重要，但简单且没什么细节，暂时不重要)</font></p><ul><li>分组交换又分为：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211628975.png" alt=""><ul><li>数据报服务方式</li><li>虚电路服务方式</li></ul></li></ul></li><li><p>传输介质<font color=blue>(不重要)</font></p><ul><li>双绞线：绞合可以抗干扰<ul><li>距离过大时需要放大器放大衰减的信号，以及中继器整形失真的信号。</li></ul></li><li>同轴电缆：抗干扰、传输距离远，速率更高，也更贵</li><li>光纤</li><li>无线电波、微波、红外和激光、卫星</li></ul></li><li><p>物理层接口的特性：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109092152195.png" alt=""></p></li><li><p>中继器与集线器<font color=blue>重要</font>：</p><ul><li>中继器<ul><li>放大信号、延长网络长度</li><li>不能连接速率不同的局域网</li><li>5-4-3规则：互相串联的中继器个数不能超过4个，形成的5段通信介质中只有三段可以连接计算机，其它2段只能用作扩展通信范围。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109112037131.png" alt=""></li></ul></li><li>集线器（Hub）<ul><li>多口中继器；放大信号、延长网络长度</li><li>广播式、半双工</li><li>不能分割广播域和冲突域</li></ul></li></ul></li></ol><div class="note success flat"><p>习题<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210704212925.png" alt="例6"><br><font color=red size=4>解：</font></p><ul><li>发送延时<ul><li>源点发送延时：（（L/p）*（h+p））/ b；</li><li>中继节点发送延时：（h+p）/b * （k-1）；<font color=red size=4>注意在<strong>分组转发</strong>当中<strong>每个中继只延迟了一个分组</strong>的时间</font>。</li></ul></li><li>传播延时<ul><li>d * k</li></ul></li><li>连接建立时间<ul><li>s</li></ul></li><li>处理延时<ul><li>m *（k-1）</li></ul></li></ul><p><font color=red size=4>总时间相加即可</font></p><hr><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210704214241.png" alt="例3"></p><ol><li>传播时延 20*2 μs，处理时延 35 μs，发送时延 1000*2 μs，总 2075 μs。</li><li>发送时延（源点 1000 μs、中继 500 μs），传播时延 20*2 μs，处理时延 35 μs，总时延 1575 μs。</li></ol><hr><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211606429.png" alt=""></p><ul><li>没有波特率,无法用奈氏准则!!!</li></ul></div><h1>第三章 - 数据链路层</h1><ol><li><p>数据链路层为网络层提供：</p><ul><li>无确认的无连接服务：不建立链路、收到不确认、丢失不重发</li><li>有确认的无连接服务：不建立连接、受到确认、丢失重发</li><li>有确认的面向连接服务：建立链接、收到确认才能继续发下一帧</li></ul></li><li><p>帧定界、帧同步和透明传输<font color=blue>(不重要)</font>:<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705174614.png" alt=""></p><ul><li>帧定界：组帧时添加头尾部控制信息，也能确认帧的边界。</li><li>帧同步：接收方应能够确认<strong>二进制比特流</strong>中帧的始末。</li><li>透明传输：数据中可能出现刚好等于控制信息的二进制比特串，需要处理。</li></ul></li><li><p>组帧：<font color=blue>(重点！！！)</font>：</p><ul><li>字符计数法：头部信息中包含了帧的长度信息（错一个后面帧全错）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211721252.png" alt=""><ul><li>注意是字符(每个字符8位二进制位)</li></ul></li><li>字符填充的首尾定界符法：使用特定字符来界定（数据中的特殊字符前插入<strong>转义字符DEL</strong>标记）</li><li>零比特填充的首位标记法：用01111110标记始末（发送：数据中遇到5个1在后面添0；接收数据中遇到5个1在后面减0）</li><li>违规编码法：<ul><li>只适用于冗余编码，因为只有冗余编码有剩余位置表示违规编码（界定符）</li><li>例如曼彻斯特编码，高-低是1，低-高是0；违规编码1为高-高，0为低-低。</li><li>例如：局域网IEEE 802标准</li></ul></li><li>习题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211723233.png" alt=""><ul><li>答案<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109211723276.png" alt=""></li></ul></li></ul></li><li><p>差错控制<font color=blue>(重点！！！)</font>：</p><ul><li>差错由噪声干扰形成，内部噪声可以通过提高信噪比解决，外部噪声就必须要有差错控制</li><li>奇偶校验码：奇校验码（在比特串末添加一位0或1使得1的个数是奇数）、偶校验码（在比特串末添加一位0或1使得1的个数是偶数）</li><li>循环冗余码（CRC）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705194226.png" alt=""><ul><li><em>循环冗余码由纠错功能，但数据链路层仅实现了检错功能，检测到帧出错就丢弃。因此还不算“可靠传输”而是“确认传输”</em></li></ul></li><li>海明码：<ul><li>纠错能力1位、检错能力2位</li><li>校验码的长度r：<code>2^r ≥ m+r+1</code></li><li>例：发送数据D = 1100<ol><li><code>m=4</code>，算出<code>r=3</code></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705202354.png" alt=""></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705202601.png" alt=""><ul><li>对于x4来说，4、5、6、7的值分别是x4、0、1、1,采用偶校验则x4应当是0；</li><li>同理x2是0，x1是1。</li></ul></li><li>检错<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705203612.png" alt=""></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705203754.png" alt=""></li></ul></li></ol></li></ul></li></ul></li><li><p>流量控制<font color=blue>(重点！！！)</font>：</p><ul><li>ARQ：自动重传请求。停止-等待ARQ、后退N帧ARQ、选择重传ARQ。</li><li>停止-等待协议：每次传输一帧，只有收到确认信号之后才能发送下一帧<ul><li>相当于窗口大小为1的滑动窗口协议</li><li>发送一个帧后发送方不能马上丢弃（出错时方便重传），所以需要一个帧缓冲区存放尚未确认帧的副本。</li></ul></li><li>滑动窗口控制协议：<br>-滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为<strong>发送窗口</strong>；同时，接收方也维持了一个连续的允许接收的帧的序号，称为<strong>接收窗口</strong>。<ul><li>发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。</li><li>不同的滑动窗口协议窗口大小一般不同。</li><li>发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705214154.png" alt="滑动窗口协议-发送"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705214655.png" alt="滑动窗口协议-接收"></li><li>在<strong>发送端</strong>，每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接受方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送。</li><li>在<strong>接受端</strong>，当收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接受窗口之外则一律丢弃。</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705215031.png" alt="协议"></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210705215142.png" alt="知识点"></li></ul></li><li>后退N帧协议（GBN）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210706152648.png" alt="GBN"><br><font color=“#4D79C0” size=4><em>具体实现步骤见上面的滑动窗口协议</em></font><ul><li>发送方发送<code>0</code>，然后接收方收到<code>0</code>后发送一个确认帧，并且接收方的接收窗口向后一位，最后发送方收到确认帧后也向后一位。</li><li><strong>设想一种特殊情况，即接收窗口收到了<code>1、2、3</code>并发送了确认帧，但<code>1、2</code>号确认帧延迟了，这时发送方收到了<code>3</code>的确认帧，这时不需要等待<code>1、2</code>确认帧，直接将发送窗口移到数据<code>3</code>之后即可</strong>。这种情况叫做<font color=red size=5>累计确认</font>。</li><li><strong>如果超时，会发送所有尚未被确认且已发送的帧，如接着上面这种情况，确认<code>3</code>之后窗口从数据<code>4</code>开始，这时发送窗口发送了<code>4,5,6,7,0,1</code>数据，且收到了<code>6</code>号帧,窗口开始位移动到7,此时发送超时时间,就要重传未确认的已发送的<code>7,0,1</code></strong></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210706160637.png" alt="总结"></li></ul></li><li>选择重传协议（SR）<ul><li>与GBN不同的是，GBN的接收端按序确认，虽然可以连续接收然后才确认，但假如前面的帧出错，后面的帧都要丢弃；<br>而SR则只重传出错的帧，但这就需要一个额外的缓冲区暂存未按序接收的数据帧。</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210706173049.png" alt="总结"></li></ul></li><li>窗口大小：<ul><li>无论GBN还是SR，其<code>发送窗口大小 + 接收窗口大小 = 2^n</code></li><li>GBN:<code>接收窗口1，发送窗口(2^n)-1</code></li><li>SR:<code>接收窗口 = 发送窗口 = 2^(n-1)</code></li></ul></li></ul></li><li><p><strong>信道划分</strong>介质访问控制<font color=blue>(重点！！！)</font>：</p><ul><li>介质访问控制（MAC）子层：用于决定广播信道中信道分配</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109112241763.png" alt=""></li><li>信道划分介质访问控制：频分复用（FDM）、时分复用（TDM）、波分复用（WDM）、码分复用（CDM，采用不同编码方式区分各路原始信号）<ul><li>码分多址(Code Division Multiple Access. CDMA)<ul><li>每比特时间被分成农个更短的时间槽,称为码片(Chip)</li><li>每个站点被指定一个唯一的和位代码或码片序列。</li><li>发送1时,站点发送码片序列;发送0时,站点 发送码片序列的反码。</li><li>为从信道中 分离出各路信号,要求各个站点的码片序列相互正交。</li><li><strong>例子</strong><ul><li>站点 A、B 同时发送给 C</li><li>码片由计算机分配（题目中给出）</li><li>若 A 站点的芯片序列为 (-1 -1 -1 +1 +1 -1 +1 +1)，发送这个比特串就表示发送1，发送其反码就是0</li><li>且 B 站点的芯片序列为 (-1 -1 +1 -1 +1 +1 +1 -1)，发送这个比特串就表示发送1，发送其反码就是0</li><li>验证正交：A ∙ B = sum(Ai * Bi) = (1 + 1 - 1 -1 + 1 - 1 + 1 - 1) = 0，只有只有正交的码片才能同时发送。</li><li>当 A 在链路中发送数据时，发送 1 (-1 -1 -1 +1 +1 -1 +1 +1) ，B 发送 0 (+1 +1 -1 +1 -1 -1 -1 +1)<strong>反码</strong>；</li><li>则，在链路中的信号叠加为 (0 0 -2 2 0 -2 0 2);</li><li>当 C 收到这个叠加的序列后，想获得 A 的数据，则将收到的序列与A的序列点积，得 1。（因为是计算机给出码片，所以A和B的码片，C都知道）</li><li>同理，想获得 B 的数据时，点积B的序列获得 -1 ，代表0。</li></ul></li></ul></li><li>统计时分复用（STDM）：<ul><li><em>是TDM的一种改进,它采用STDM帧,STDM帧并不固定分配时隙,而按需动态地分配时隙,当终端有数据要传送时,才会分配到时间片,因此可以提高线路的利用率。</em></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210706185005.png" alt="统计时分多路复用"></li></ul></li></ul></li></ul></li><li><p>随机访问介质访问控制<font color=blue>(超重点！！！)</font>：</p><ul><li>ALOHA协议: 想发就发，不检测线路，发生冲突（一段时间没收到确认就认为冲突）就重发。<strong>冲突后等待一段时间才重发</strong>。<ul><li>时隙ALOHA协议：时间片同步，规定只有每个时隙开始时才能发送一个帧<ul><li>一个时隙发送完一个帧，防止像纯ALOHA协议一样上个帧还在线路传输过程中就发送从而碰撞。</li></ul></li></ul></li><li>CSMA协议（Carrier Sense Multiple Access、载波侦听多路访问）：<ul><li>1-坚持CSMA：<ol><li>先检测线路（信道）</li><li>空闲则发送帧</li><li>忙则<strong>持续侦听</strong>，同时<strong>一直侦听线路直到空闲</strong></li><li>发生冲突则<strong>随机</strong>等待一段时间再发送<ul><li>A发出帧还未到达目的地，B会检测到空闲而发帧，从而冲突。</li><li>忙时A、B等待，空闲时A、B同时侦听到空闲，同时发送帧，从而冲突。</li></ul></li></ol></li><li>非坚持CSMA：<ol><li>先检测线路</li><li>空闲则发送帧</li><li>忙则<strong>放弃侦听</strong>，<strong>等待一段随机时间后再侦听线路</strong></li><li>发生冲突则<strong>随机</strong>等待一段时间再发送</li></ol></li><li>p-坚持CSMA：<ol><li>先检测线路</li><li>空闲则以概率p发送数据，以1-p概率推迟到下一个时延</li><li>忙则<strong>持续侦听</strong>，直到空闲</li><li><strong>发生冲突会坚持把帧发完</strong>，然后<strong>随机</strong>等待一段时间再发送</li></ol></li></ul></li><li>CSMA/CD协议（CSMA with Collision Detection、载波侦听多路访问/碰撞检测）：<ul><li>适合总线型或半双工网络环境</li><li>思想：<ul><li>载波帧听：发送数据前先侦听是否空闲</li><li>碰撞检测：边发送数据边检测侦听（信道电压变化），<strong>发生冲突时帧的发送立即停止</strong></li></ul></li><li><strong>最小帧长</strong><ul><li><code>最小帧长 = 总线传播时延 * 数据传输率 * 2</code></li><li>A发送数据到B，最迟2倍传输时延即可检测出有没有碰撞。<strong>那么为了确保发送站在发送数据的同时能够检测到碰撞</strong>，则发送时延应该至少要2倍传输时延，然后推出上述公式。</li></ul></li><li>二进制指数退避算法解决碰撞<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709200833.png" alt="截断二进制指数规避算法"></li></ul></li><li>CSMA/CA协议CSMA with Collision Avoidance、载波侦听多路访问/碰撞避免）：<ul><li><font color=blue>王道的思维导图有问题！！！以书上为准</font></li><li><strong>用于无线网络，IEEE 802.11</strong></li><li><strong>并非完全避免碰撞，而是尽可能减少</strong></li><li>因为不采用碰撞检测（依然有信道忙检测），所以发送碰撞时帧会继续发送!</li><li>发送一帧，收到确认再发送下一帧。</li><li><strong>工作原理</strong>：<ol><li>发送数据前检测信道空闲。</li><li>空闲则发送RTS（Request to send，请求发送）帧，RTS包括源地址、目的地址、下一帧的发送持续时间等信息；忙则等待。</li><li>接收端收到RTS后，发送CTS（Clear to send）帧，告诉发送方准备好接收。</li><li>发送端收到CTS，开始发送数据帧（同时预约信道，发送方告诉所有其它站点自己要发多久，避免冲突）<ul><li>与CD协议不同！！！CD协议只有冲突时才使用退避算法，CA协议除了发送第一个数据帧以外都需要等待一个时隙然后使用退避算法</li></ul></li><li>接收端收到数据帧后，进行CRC检验，正确则发送ACK帧</li><li>发送方收到ACK帧后发送下一帧，超时未收到则重发到上限次数（发送推迟时间：二进制指数退避算法）</li></ol></li></ul></li><li>CD与CA协议的区别：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141357249.png" alt="CD/CA"></li></ul></li><li><p>轮询访问介质访问控制：</p><ul><li>轮询访问MAC协议<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709204205.png" alt="轮询协议思想"></li><li>令牌访问协议<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709204248.png" alt="令牌传递协议"></li></ul></li><li><p>局域网工作在OSI下两层,广域网工作在OSI下三层</p></li><li><p>局域网相关<font color=blue>(重点！！！)</font></p><ul><li>三种特殊局域网（实际生活中）<ul><li>以太网（逻辑总线形、物理星形或拓展星形）</li><li>令牌环网（逻辑环形、物理星形）</li><li>FDDI（光纤分布数字接口，IEEE802.5，逻辑环形、物理双环）</li></ul></li><li>IEEE 802协议<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709212516.png" alt="IEEE 802"></li><li>LLC子层和MAC子层（都是链路层子层）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709212649.png" alt="链路层子层"><ul><li>区分：看功能是向上层（网络层）提供服务还是使用下层（物理层）的功能。</li></ul></li><li>以太网（IEEE 802.3）<ul><li>局域网的一种</li><li>逻辑总线形、物理星形</li><li>无连接，不可靠（尽最大努力交付、纠错由上层完成）</li><li>传输介质<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141507525.png" alt="传输介质"></li><li>10Base-T以太网<font color=blue>(超重点！！！)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709213817.png" alt="10BASE-T以太网"></li><li>MAC地址：48位，前24位代表厂家；后24位厂家自己指定，常为6个16进制数，如<code>02-60-8c-e4-b1-21</code></li><li>以太网的MAC帧<font color=blue>(超重点！！！)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141528399.png" alt=""><ul><li>地址（6字节、48bit）、类型（2字节，指定数据交由哪个协议实体）、数据（46~1500；46：CSMA/CD的最短帧长为64B，首尾部占18B；1500：规定如此，没有为什么）、填充（0~46B，防止帧太短，达不到最短帧长）、校验码FCS（4B，CRC校验，校验除自身的整个MAC帧，不校验物理层加的前导码）</li><li>MAC帧的发送有时隙，所以不需要帧结束定界符（有帧开始定界符，物理层加上），但不是没有尾部，数据链路层既要加首部也要加尾部。</li><li>其与IEEE 802.3的区别在于：<ul><li>802.3的第三个字段是<strong>长度/类型</strong>。</li></ul></li></ul></li></ul></li><li>高速以太网：<ul><li>100BASE-T以太网：<ul><li>100Mb/s、使用CSMA/CD协议（半双工）、支持全双工和半双工、802.3 MAC帧</li></ul></li><li>吉比特以太网<ul><li>1Gb/s、使用CSMA/CD协议（半双工）、支持全双工和半双工、802.3 MAC帧</li></ul></li><li>10吉比特以太网<ul><li>10Gb/s、光纤、只支持全双工（因此不使用CSMA/CD）、802.3 MAC帧</li></ul></li></ul></li><li>无线局域网（IEEE 802.11、WIFI）<ul><li>有固定基础设施的无线局域网：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709221942.png" alt="有固定基础设施无线局域网"><ul><li>最小构件是基本服务集BSS</li><li>一个基本服务集包含一个基站和若干移动站</li><li>所有站在本BSS内可以直接通信，BBS外通过本BBS基站转发</li></ul></li><li>无固定基础设施的无线局域网<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709222125.png" alt="无固定基础设施移动自组织网络"><ul><li>移动站地位平等，自组织起的临时网络；中间节点都是转发结点，都有路由功能</li><li>具有自己特定的路由选择协议，不与因特网相连</li></ul></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112182040909.png" alt=""><ul><li>去头发中尾补(目的,源,AP)</li></ul></li></ul></li><li><font color=blue>(已删！！！)</font> <s>令牌环网（IEEE 802.5）</s> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141606093.png" alt="令牌环网"><ul><li>令牌环网的每一站都与环接口干线耦合器（TCU）相连，帧由TCL转发。</li><li>空闲时转发令牌，需要发送数据时（有令牌）将令牌变为数据帧发送出去。</li><li>发送完数据后，发送站重新产生一个令牌。</li></ul></li><li><font color=blue>(新增！！！)</font>VLAN基本概念与基本原理：（待补）</li></ul></li><li><p>广域网</p><ul><li>PPP拨号协议：<ul><li>串行直连（点对电）线路、面向字节、以SLIP协议为基础</li><li>只支持全双工、不可靠（帧无编号、确认）</li><li>支持同步、异步线路</li><li>组成：<ul><li>链路控制协议(LCP): 一种扩展链路控制协议,用于建立、配置、测试和管理数据链路。</li><li>网络控制协议(NCP)。PPP协议<strong>允许同时采用多种网络层协议</strong>,每个不同的网络层协议要用一个相应的NCP来配置,为网络层协议建立和配置逻辑连接。</li><li>—个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分,这个信息部分的长度受最大传送单元(MTU)的限制。</li></ul></li><li>PPP帧格式<font color=blue>(重点！！！)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141619652.png" alt=""><ul><li>标志字段：规定7E，前后各一个字节；地址字段：一个字节，规定为0xFF；控制字段一个字节，规定为0x03；协议字段：2B，说明信息部分运载的是什么分组（0x0021表示IP数据报）；校验字段：2B，校验地址、控制、协议、信息字段（没有头尾部标志字段）</li><li>点对点传输，不需要介质访问控制（相当于专用线路），所以不采用CSMA/CD协议，<strong>信息字段自然也没有最小帧长限制</strong></li><li>信息字段歧义字符处理：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141632948.png" alt="歧义字符处理"></li></ul></li></ul></li><li><font color=blue>(已删！！！)</font> <s>HDLC协议</s><font color=blue><s>(重点！！！)</s></font><ul><li>面向比特、全双工、可靠传输（帧有编号和确认）</li><li><strong>主站、从站、复合站</strong></li><li>响应方式：<ul><li>正常响应方式。这是一种非平衡结构操作方式,即主站向从站传输数据,从站响应传输,但从站只有在收到主站的许可后,才可进行响应。<ul><li>非平衡（响应）：一主一从</li></ul></li><li>异步平衡方式。这是一种平衡结构操作方式。在这种方式中,每个复合站都可以进行对另一站的数据传输。<ul><li>平衡：两端结点平等</li></ul></li><li>异步响应方式。这是一种非平衡结构操作方式。在这种方式中,从站即使未受到主站的允许,也可进行传输。</li></ul></li><li>HDLC帧：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210711184341.png" alt="HDLC的帧格式"><ul><li><em>帧的字段不一定要记, 但帧格式的这三种类型一定要背下</em></li></ul></li></ul></li></ul></li><li><p>广域网、局域网、因特网、以太网、互联网<font color=blue>(重点！！！)</font>：</p><ul><li><code>互联网 = 广域网 + 局域网</code><ul><li>局域网可以连接不同类型的网络，广域网不能</li></ul></li><li>因特网：全球最大的互联网</li><li>以太网是局域网的一种</li></ul></li><li><p>网桥和交换机<font color=blue>(重点！！！)</font></p><ul><li><strong>两个或多个以太网通过网桥连接后，就成了覆盖范围更大的以太网，原来的以太网就叫做网段</strong></li><li>网桥工作在MAC子层，可以隔离冲突域（A网段的冲突不会影响B网段）</li><li>支持不同协议（在网桥进行协议转换）；具有缓冲功能。</li><li>工作原理：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141707360.png" alt="工作原理"><ol><li>计算机A发送数据到B：采用广播方式（总线形），B会收到，网桥B1也会收到；但B1发现目的地址和源地址网段相同，因此丢弃信息，只有B能收到。</li><li>计算机A发送数据到E：广播信息到网桥B1，B1根据网桥表转发数据到下一个网段，然后数据帧到达B2，B2根据网桥表发送给下一个网段，然后到达E。</li><li>计算机A发送数据到B，同时B发送数据到A或者E，发生冲突。</li><li>计算机A发送数据给B，同时C发送数据给D，因为所属不同网段所以不会发生冲突。</li></ol></li><li>网桥的<strong>路径选择</strong>算法：<ul><li>透明网桥（转发路径由网桥确定，只负责下一站），通过自学习实现局部最佳。<ul><li>思想：站A发出的帧从网桥的某个端口到达某个网桥，那么沿反方向，帧从该端口发出一定能到A。</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141726324.png" alt=""></li></ul></li><li>源路由网桥（由发送数据的源站负责选择路径，网桥只根据帧控制信息对帧进行接收和转发）<ul><li>源站以广播方式发送一个发现帧到目的站，根据经过的结点生成最佳路径</li></ul></li></ul></li><li>交换机（多口网桥）：<ul><li>全双工、无碰撞（不同端口之间被分为不同网段，同一端口通过集线器连接的不同计算机会发送碰撞）</li><li>两种交换模式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109141732299.png" alt=""></li><li>其它特点和网桥类似。</li></ul></li></ul></li><li><p>冲突域和广播域<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210711202718.png" alt="冲突域&amp;广播域"></p></li></ol><div class="note success flat"><p>习题<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210711221305.png" alt="18"><br>接收时延当然是包括在<code>发送时延 + 传播时延当中的</code>,但<strong>确认帧的发送相当于又一次的发送时延</strong><br>所以发送时延是<code>第一次,发送数据帧用时800ms,第二次.发送确认数据帧用时800ms</code>.<br>传播时延是来去共400ms.<br>所以总效率40%</p><hr><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210711222720.png" alt="15"><br>这里不是停等协议,而是滑动窗口协议,故总时间不能简单的<code>传播延时250 + 总发送时延X(所有窗口发送的时延)</code>,因为当第一个确认帧到达时,后面的数据还没发送,不能算入发送时延.<br>应当考虑的是<strong>在第一个窗口发送时到第一个窗口确认帧到达时</strong>这段时间里<strong>发送了多少数据</strong>.<br>所以时间T是<code>发送时延 + 传播时延 = 1000*8b / 128kb/s + 250ms</code>约为0.5625 s<br>设发送的数据量为L,则发送数据用时t为 L/128k s<br>所以<code>t / T</code>应当≥0.8,得B.</p><hr><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109221741945.png" alt=""></p><ul><li>半双工的交换机，意味着一个端口进，另一个端口出，满速10Mb/s需要占用两个端口。</li></ul></div><h1>第四章 - 网络层</h1><ol><li><p>网络层的功能：</p><ul><li>向上层提供<strong>异构网络互联</strong><ul><li>异构：不同协议的网络</li></ul></li><li>路由选择与路由转发</li><li>拥塞控制<ul><li>流量控制与拥塞控制的区别：流量控制是抑制发送端的速率，以便接收端来得急接收；而拥塞控制是子网能够承受并发送流量的问题，是一个全局性的问题</li><li>拥塞控制方法：<ul><li>开环控制（静态）：设计网络时就考虑好产生拥塞的因素，力求网络在工作中不产生拥塞</li><li>闭环控制（动态）：事先不考虑拥塞因素，采用动态检测网络系统的方式</li></ul></li></ul></li></ul></li><li><p>路由算法：<font color=blue>(超重点！！！)</font></p><ul><li>自治系统AS：同一技术管理下的一组路由器，他们使用相同的路由选择协议，一般是一家公司、一所大学、一个政府部门等。</li><li>静态路由算法（非自适应路由算法）：网络管理员手工配置路由信息</li><li>动态路由算法（自适应路由算法、同一自治系统AS内）：通过相互连接的路由器之间彼此交换信息来优化路由表<ul><li>距离-向量路由算法（代表：RIP协议）：<ul><li>RIP协议不支持不同子网掩码的转发</li><li>“好消息”传得快、”坏消息“传得慢（网络故障需要数分钟才能传到所有路由器）</li><li>原理：<strong>所有结点定期把他们的整个路由表发给所有与之相邻的结点</strong></li><li>工作流程<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109142045869.png" alt=""><ul><li>修改R4发来的路由表项（距离+1，下一跳均改为R4）；即数据从R6发出去到目的地要经过R4，所以距离加一，修改后的R4（要合并到R6的路由表）目的地均为R4。</li><li>遍历修改后的R4路由表：<ul><li>R6中没有表项，直接加上去</li><li>R6中有表项，且R6中表项的下一跳是：<ul><li>下一跳是R4，立即用收到的R4修改版替换（路径更新，这里不一定距离减少，更新是因为老路径和新路径同样是R6到R4，说明原路径失效）</li><li>下一跳不是R4，若R4修改版距离更近就更新，否则不作处理</li></ul></li></ul></li><li>180s还没收到某路由器X发来的路由表，就标记为X不可达。</li></ul></li></ul></li><li>链路状态路由算法（代表：OSPF协议）：<ul><li>开放最短路径优先算法OSPF协议，链路状态路由算法中使用Dijkstra的最短路径算法SPF。</li><li>分布式的链路状态协议</li><li>收敛速度快（路由状态的更新快）</li><li>工作原理：<ol><li>向网络中的所有路由发送信息，这里使用泛洪法，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<ul><li>最终整个区域内的所有路由器都得到了这个信息的副本</li></ul></li><li>发送的信息是本路由<strong>相邻的所有路由的链路状态</strong>，包括：本路由的相邻路由统计、到相邻路由的代价（费用、距离、时延或者带宽）</li><li>只有<strong>当链路状态发生变化时</strong>，才泛洪发送路由信息。</li><li>最后所有路由器都能建立起一个<strong>链路状态数据库</strong>，即<strong>全网拓朴图</strong></li></ol></li></ul></li></ul></li><li>外部网关协议（代表：BGP、不同自治系统AS间）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109142146838.png" alt=""><ul><li>BGP采用的是路径向量路由选择协议、基于TCP</li><li>BGP原理与RIP类似（采用路径向量路由选择协议），只不过交换的信息是：<strong>到达某个网络所要经过的一系列AS</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109142147372.png" alt=""><ul><li>如自治系统AS2的BGP 发言人通知主干网AS1的BGP 发言人：“要到达网络N1、N2、N3 和 N4 可经过 AS2。“</li><li>主干网还可发出通知：“要到达网络N5、N6 和N7 可沿路径（AS1, AS3）。”</li></ul></li><li>BGP支持CIDR</li><li>BGP协议的四种报文<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109142150190.png" alt=""></li></ul></li><li>三种协议比较<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109142153144.png" alt=""></li><li><font color=blue>RIP（应用层）、OSPF（网络层）、BGP协议（应用层）</font></li></ul></li><li><p><font color=blue>(新增！！！)</font>SDN基本概念：（待补）</p></li><li><p>IPv4<font color=blue>(能记就记，首部长度、总长度、片偏移一定要记住)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714214407.png" alt="IP数据报"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714214525.png" alt="IP数据报格式"></p><ul><li>分组格式：<ul><li>版本：指IP的版本,目前广泛使用的版本号为4</li><li>首部长度：<strong>本身占4位</strong>。以4B为单位，即若该字段四位全1即<code>1111</code>，表示长度为<code>15x4B = 60B</code>,也即最大值为60B ( 15x4B)，且<strong>规定最小值为20B（5×4）</strong>。最常用的首部长度是最小值20B。</li><li>区分服务（期望获得哪种类型的服务）</li><li>总长度（本身16位。指<strong>首部和数据之和</strong>的长度,单位为1字节,因此数据报的最大长度为2^16-1 = 65535B，数据量过大会被分组）</li><li>标识（占16位。它是一个计数器,每产生一个数据报就加1,并赋值给标识字段。当一个数据报的长度超过网络的MTU时,必须分片,此时每个数据报片都复制一次标识号,以便能正确重装成原来的数据报。）</li><li>标志（3位。标志字段的最低位为MF(More Fragmaent), MF = 1表示后面还有分片,MF = 0表示最后一个分片。标志字段中间的一位是DF,只有当DF = 0时才允许分片。）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714223245.png" alt="标志字段"></li><li>片偏移（占13位。以 8B 为偏移单位,它指出较长的分组在分片后,某片在原分组中的相对位置。）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714223430.png" alt="片偏移"></li><li>生存时间TTL（占8位。IP分组的保质期。经过一个路由-1，变成0则丢弃）</li><li>协议（占8位。数据部分的协议。<strong>其中值为6表示TCP,值为17表示UDP</strong>。）</li><li>首部校验和（只检验首部）</li><li>源IP地址和目的IP地址（32位）</li></ul></li><li>IP数据报的分片<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109161627820.png" alt=""><ul><li>同一数据报的分片使用相同标识<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714222731.png" alt="分片"></li><li>分片例题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714223609.png" alt="分片"></li></ul></li></ul></li><li><p>IPv4地址与NAT<font color=blue>(超重点！！！)</font>：</p><ul><li>分类的IP地址按照哈夫曼编码<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714231459.png" alt="分类的IP地址"> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109161641066.jpg" alt=""></li><li><font color=green size=5>特殊IP地址</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714231723.png" alt="特殊IP地址"><ul><li>网络号全0必为0.X.X.X（0.0.0.0表示本网络上的本主机。）</li><li>主机号全为1表示本网络的广播地址，又称直接广播地址，如202.98.174.255。<ul><li>只能“收”不能“发”</li></ul></li><li>主机号全为0表示本网络本身，如202.98.174.0表示202.98.174.X这个网络<ul><li>除0.0.0.0外，不能“收”也不能“发”</li></ul></li><li>127.X.X.X保留为环回自检( LoopbackTest) 地址,此地址表示任意主机本身,目的地址为环回地址的IP数据报永远不会出现在任何网络上（发出去的数据会被自己接收）。</li><li>32位全为1,即255.255.255.255表示整个TCP/IP网络的广播地址,又称受限广播地址。</li><li>实际使用时,由于路由器对广播域的隔离,255.255.255.255等效为本网络的广播地址。</li></ul></li><li><font color=green size=5>私有IP地址</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714232557.png" alt="私有IP地址"><ul><li><strong>私有地址也是可分配地址！</strong></li><li>只用于LAN,不用于WAN连接</li><li>路由器对目的地址是私有地址的数据报一律不转发。</li><li>因此私有IP地址不能直接用于Internet,必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet</li></ul></li><li>各类网可用<strong>网络</strong>数<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210714233120.png" alt="网络类别"><ul><li>A类：0.X.X.X（本网络的某个特定主机，只能作为“发”不能作“收”；其中0.0.0.0表示本网所有主机），127.X.X.X（环回自检地址，发出去的会被自己收到，可“发”可“收”）</li><li>B类：128.0.X.X（保留地址、但其实已经被分配出去一部分了，教材还没改）</li><li>C类：192.0.0.X(保留地址、目前还没分配出去)</li><li>可用主机数：-2（全0/1）</li></ul></li></ul></li><li><p>NAT（Network Address Translation）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715142558.png" alt="NAT"></p><ul><li>普通路由器在转发IP数据报时,不改变其源IP地址和目的IP地址。而NAT路由器在转发IP数据报时,一定要更换其IP地址(转换源IP地址或目的IP地址)。</li><li>普通路由器仅工作在网络层,而NAT路由器转发数据报时需要查看和转换传输层的端口号。</li></ul></li><li><p>子网划分<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715143632.png" alt="子网划分2"></p><ul><li>子网划分<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715143915.png" alt="子网划分3"><ul><li>从主机号借用若干比特作为子网号,当然主机号也就相应减少了相同的比特。</li><li>三级IP地址的结构如下:IP地址={〈网络号〉,〈子网号〉,〈主机号&gt;}。</li><li>凡是从其他网络发送给本单位某台主机的IP数据报,仍然是根据IP数据报的目的网络号, 先找到连接到本单位网络上的路由器。然后该路由器在收到IP数据报后,按目的网络号 和子网号找到目的子网。最后把IP数据报直接交付给目的主机。</li></ul></li><li>子网掩码：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715144034.png" alt="子网划分4"><ul><li>子网掩码用来表达借位，一定是一串1接一串0</li><li>A、B、C类地址的默认子网掩码分别为255.0.0.0、255.255.0.0、255.255.255.0。</li></ul></li><li>习题1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715145355.png" alt="习题"></li><li>习题2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715150215.png" alt="习题"><ul><li><code>IP地址 &amp; 子网掩码 = 180.80.X.0</code>,其中X为<code>252 &amp; 77 = 11111100 &amp; 01001101 = 01001100 = 76</code>,即所在子网<code>180.80.76.0</code></li><li>子网掩码前面的1表示网络号和子网号,后面的0表示主机号(不可能01交替).</li><li>广播地址是主机号全1,所以子网内广播地址是<code>180.80.Y.255</code>,其中Y为<code>(010011 | 01) -&gt; (010011 | 11)</code>即<code>79</code></li><li>故答案为<code>180.80.79.255</code></li></ul></li></ul></li><li><p>CIDR（无分类编址）<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715160554.png" alt="地址块"></p><ul><li>思想是：如果一个单位需要2000块地址，就给他分配一个2048地址的块（8个连续的C类地址）</li><li>IP地址的无分类两级编址为：IP::={&lt;网络前缀&gt;,&lt;主机号&gt;}。<ul><li>对于128.14.32.5/20这个地址,它的掩码是20个连续的1和后续12个连续的0,通过逐位相“与“的方法可以得到该地址的网络前缀</li></ul></li><li><font color="#2E75B6" size=4>CIDR的主机号可以<strong>全0或者全1</strong></font></li><li>路由转发时多个子网匹配的问题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715162344.png" alt="构最长前缀匹配"><ul><li>例题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715163630.png" alt="构最长前缀匹配"><ol><li><code>132.0.0.0/8</code>, 前8位1匹配<code>132.19.237.5</code>成功</li><li><code>132.0.0.0/11</code>, 前8位1匹配<code>132.19.237.5</code>成功，<code>19所在字节: 0001xxxx &amp; 11100000</code>也匹配成功</li><li><code>132.19.232.0/22</code>, 前22位1匹配为<code>237所在字节: 11101101 &amp; 11111100 = 11101100 = 236</code>, 不匹配</li><li><code>0.0.0.0/0</code>是默认路由, 全都不匹配时才起作用</li></ol></li></ul></li></ul></li><li><p>超网<font color=blue>(看看就行)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715161557.png" alt="构成超网"></p><ul><li>R2路由的两个端口连接的网络，其地址前缀有16位相同，到第17位不同，所以合体网络地址应是<code>206.1.0.0/16</code></li><li>习题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715162039.png" alt="习题"></li></ul></li><li><p>ARP协议（地址解析协议）<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210715172115.png" alt="发送数据的过程"></p><ul><li>）<font color=blue>图看看就好，不用记</font></li><li><strong>IP协议帧携带的是IP地址，但最终需要使用MAC地址（硬件地址）</strong></li><li>因此每台主机都有ARP缓存，用来存放{IP : MAC}的映射表</li><li>工作原理：<ol><li>IP协议帧在数据链路层被加上MAC地址信息</li><li>发出去后有四种情况：<ol><li>收发方都是主机，且在同一网段：直接在ARP缓存里找到“收”方主机的硬件地址</li><li>收发方都是主机，且在不同网段：也就是要通过路由器转发，这时需要在ARP缓存里找到本网络任何一个路由器的硬件地址</li><li>发送方是路由器，和目的主机在同一网段：直接在路由器的ARP缓存里找到目的主机的硬件地址</li><li>发送方是路由器，和目的主机在不同网段：也就是要通过另一个路由器转发，这时需要在ARP缓存里找到本网络另外一个路由器的硬件地址，把工作交给下一个路由器</li></ol></li></ol></li></ul></li><li><p>DHCP协议（动态主机配置协议、用来动态分配IP）<font color=blue>(图是重点)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210717170223.png" alt="DHCP协议"></p><ul><li><font color=blue>下面的看看,了解就行</font></li><li>第一步客户端使用广播方式是因为客户端不知道服务器的IP地址</li><li>第二步服务器也使用广播是因为服务器还没给客户端配置IP，客户端还没有IP地址</li><li>第三步确认采用广播而不是单播（通过第一次确认已经知道服务器IP地址）是因为这样可以同时告知其它DHCP服务器，已经得到了IP，原预分配IP可以收回。</li><li>第四步还是用广播则是因为IP分配还没得到确认（只是预分配）</li><li>在没有IP的情况下因为处于同一网段，所以可以使用MAC地址找到对方。</li></ul></li><li><p>ICMP协议（网际控制报文协议）<font color=blue>(重点！！！)</font>：</p><ul><li>为了提高IP数据报交付成功的机会，提供ICMP协议使主机和路由器能够<strong>报告差错和异常信息</strong></li><li>ICMP询问报文和ICMP差错报文：<ul><li>ICMP的五种差错报文：<ul><li>终点不可达报文：目的地址无法送达</li><li>源点抑制报文：发送过快，造成拥塞</li><li>时间超过报文：路由器或主机收到超时的数据报后发送，告诉源点超时了，重发</li><li>参数问题报文：路由器或主机收到首部字段有问题的的数据报后发送，告诉源点出错了，重发</li><li>改变路由（重定向）报文：路由器发给源点，告诉源点有更好的路径</li></ul></li><li><strong>不应该发送差错报文的情况</strong>：<ol><li>对于差错报文不发送差错报文</li><li>对第一个分片的数据报片的所有后续数据报片不发送</li><li>对有组播地址的数据报不发送</li><li>对有特殊地址（127.0.0.0或0.0.0.0）的数据报不发送</li></ol></li><li>ICMP询问报文<font color=blue>(有1和2印象就行)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109162158640.png" alt=""></li><li>ICMP的应用<font color=blue>(了解就行)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109162159675.png" alt=""></li></ul></li></ul></li><li><p>IPv6：地址增大到了128位</p><ul><li>表示法<font color=blue>(重点！！！)</font>：<ul><li>每4位用一个十六进制数 表示,并用冒号分隔每 16 位,如<code>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</code>。</li><li>缩写成更紧凑的形式<ul><li>当16位域的开头有一些0时,可以采用一种缩写表示法,但在域中必须至少有一个数字。例如,可以把地址<code>4BF5:0000:0000:0000:BA5F:039A:000A:2176</code> 缩写为<code>4BF5:0:0:0:BA5F:39A:A:2176</code>。</li><li>当有相继的0值域时,还可以进一步缩写。这些域可以用双冒号缩写(::)。如<code>4BF5::BA5F:39A:A:2176</code>。<strong>但双冒号只能替换一次</strong></li></ul></li></ul></li><li>IPv6数据报的目的地址可以是以下三种基本类型地址之一:<ul><li>单播。单播就是传统的点对点通信。</li><li>多播。多播是一点对多点的通信,分组被交付到一组计算机的每台计算机。</li><li>任播。这是IPv6增加的一种类型。任播的目的站是一组计算机,但数据报在交付时只交付其中的一台计算机,通常是距离最近的一台计算机。</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210718155030.png" alt="三种基本类型地址"><ul><li>某台主机要想多播（可广播，可组播），就将多播地址放入IPv6地址中的目的地址即可。</li></ul></li></ul></li><li>与IPv4对比<font color=blue>(重点！！！)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210718153534.png" alt="与IPv4对比"></li><li>IPv4到IPv6：<ul><li>双协议栈：一台设备上同时装有IPv4和IPv6协议栈，使之同时支持IPv6和IPv4</li><li>隧道技术：将IPv6数据报封装到IPv4数据报的数据部分，使之能在IPv4网络中传输</li></ul></li></ul></li><li><p>IP组播<font color=blue>(重点！！！)</font>：让计算机一次发送的单个分组可以抵达用一个组地址标识的若干设备，组播仅用于UDP</p><ul><li>目的地址是一个D类地址，组播地址也只能用作目的地址，源地址总是一个单播地址。</li><li>需要路由器支持</li><li>IGMP与组播路由算法<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210719184427.png" alt="IGMP"><ul><li>IGMP协议（因特网组管理协议），是TCP/IP的一部分</li><li>组播路由算法<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109171102142.png" alt=""></li></ul></li></ul></li><li><p>移动IP</p><ul><li>三个功能实体<ul><li>移动结点：具有永久IP地址的移动设备</li><li>归属代理（本地代理）：在一个网络环境中，一个移动结点的永久“居所”叫做<em>归属网络</em>。而<em>归属代理</em>就负责在归属网络中代表移动结点执行移动管理功能，其根据移动用户的转交地址，采用隧道技术转发移动节点的数据包</li><li>外部代理：在外部网络中帮助移动结点完成移动管理功能的实体</li></ul></li><li>移动IP通信流程<ol><li>移动结点在本地网时,按传统的TCP/IP方式进行通信(在本地网中有固有的地址)。</li><li>移动结点漫游到一个外地网络时,仍然使用固定的IP地址进行通信。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109171136515.png" alt=""></li><li>为了能够收到通信对端发给它的IP分组,移动结点需要向本地代理注册当前的位置地址,这个位置地址就是转交地址</li><li>本地代理接收来自转交地址的注册后,会构建一条通向转交地址的隧道,将截获的发给移动结点的IP分组通过隧道送到转交地址处。</li><li>在转交地址处解除隧道封装,恢复原始的IP分组,最后送到移动结点,这样移动结点在外网就能够收到这些发送给它的IP分组。</li><li>移动结点在外网通过外网的路由器或外部代理向通信对端发送IP数据包。</li><li>移动结点来到另一个外网时,只需向本地代理更新注册的转交地址,就可继续通信。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109171137303.png" alt=""></li><li>移动结点回到本地网时,移动结点向本地代理注销转交地址,这时移动结点又将使用传统的TCP/IP方式进行通信。</li></ol></li><li>主机A与主机B进行通信：<ol><li>若A和B在同一个归属网络内，直接通信即可</li><li>若A和B在不同归属网络内，A在外部网络的外部代理注册一个转交地址，然后将转交地址注册到本地代理</li></ol><ul><li>当A给B发送数据报时，本地代理会截断数据报进行再封装(隧道技术)，就是再原来的数据报外面再添加一个首部，新添加首部的目的地址是转交地址，然后发送给外部代理，外部代理再将数据报发送给主机A</li></ul></li></ul></li><li><p>路由器补充：</p><ul><li>可连接异构网络</li><li>路由表的结构<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210719190451.png" alt="路由转发"></li></ul></li><li><p>路由器、交换机（网桥）、集线器（中继器）<font color=blue>(重点！！！)</font>：</p><ul><li>集线器（Hub）：速率必须相等。<ul><li><strong>两个网段在“XX”层进行互联：“XX“层及”XX“层以下协议必须相等，”XX“层以上协议可以不同</strong></li></ul></li><li>交换机（Switch）：不同物理层协议，不同MAC子层协议（相同LLC子层）及不同速率以太网</li><li>路由器（Router）：物理层、数据链路层和网络层协议都不同，网络层以上协议必须相同</li></ul></li></ol><div class="note success flat"><p>习题<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109222048578.png" alt=""></p><ol><li>R3检测到X（201.1.2.0/25）不可达，说明R3与X原本是直连的</li><li>得到R1路由表<code>X 2</code>，R2路由表<code>X 2</code>，R3路由表<code>X 16</code>（注意！！！”坏消息“是慢收敛！！！也就是说不是一下变成16的，情况很复杂，可能R2给R3的信息也到了，让R3误以为可以通过R2到。总之看成慢慢加到16的就行）</li><li>不管如何，R2收到R1（X，2）和R3（X，&gt;2，因为R3开始只发了R2，所以距离至少+1）</li><li>选择后得到R2（X，3），更新。</li></ol></div><h1>第五章 - 传输层</h1><ol><li><p>传输层功能<font color=blue>(看看就行)</font>：</p><ul><li>复用和分用：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109181106222.png" alt=""></li><li>传输层需要进行差错检测（首部和数据部分）</li><li>提供面向连接的TCP和无连接的UDP协议</li></ul></li><li><p>传输层的寻址与端口：<font color=blue>(了解)</font>：</p><ul><li>端口：标识进程，传输层使用的是软件端口<ul><li>软件端口：协议栈层间抽象的协议端口，相当于信息交互时的一种地址</li><li>硬件端口：硬件设备接口</li></ul></li><li>端口号<font color=blue>（65535 = 2^16）</font>：<ul><li>服务端端口号：<ul><li>熟知端口号（0~1023）：指派给TCP/IP最重要的一些应用进程<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722203025.png" alt="寻址和端口"></li><li>登记端口号（1024~49151）：指派给一些熟知的应用，需要在IANA登记防止重复</li></ul></li><li>客户端端口号：（49152~65535）：临时端口，进程结束后端口会回收等待分配给其它应用进程</li></ul></li><li>套接字（Socket）：如<code>127.0.0.1:8080</code></li></ul></li><li><p>TCP/IP协议族：TCP（面向连接、可靠）、UDP（无连接、不可靠）</p></li><li><p>IP数据报和UDP数据报的区别：</p><ol><li>IP数据报在网络层要经过路由的存储转发</li><li>UDP数据报<strong>逻辑上</strong>是在传输层的端到端逻辑信道上传输，实际上被封装成IP数据报在网络层上传输，UDP数据报信息对于路由来说不可见</li></ol></li><li><p>TCP和网络层虚电路的区别：</p><ol><li>TCP在传输层抽象逻辑信道上传输，对路由不可见</li><li>虚电路经过的中间节点都需要保存虚电路状态信息</li><li>网络层若采用虚电路，则无法提供无连接服务</li><li>传输层使用TCP，但也可以使用网络层提供的无连接服务</li></ol></li><li><p>UDP协议<font color=blue>(重点！！！)</font>：UDP协议基于IP协议，在IP服务之上增加了“复用和分用”以及“差错检测（尽最大努力交付）”</p><ul><li>特点<ul><li>UDP常为数据量小的传输协议提供服务（如DNS、SNMP）</li><li>尽最大努力交付但不保证可靠传输、可靠传输的实现在上层</li><li>UDP是面向报文的</li></ul></li><li>UDP首部格式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722203628.png" alt="UDP首部格式"><ul><li>源端口：16位（因为端口号最多16位，即65535）</li><li>目的端口：16位（同上）</li><li>UDP长度：16位（单位1B，最小值是8，即8B，仅有首部）</li><li>UDP校验和：16位（不想校验时就全0）</li></ul></li><li><strong>如果接收方UDP发现端口号找不到（不在运行），就丢弃报文，由ICMP回馈“不可达”差错报文</strong></li><li><strong>UDP校验</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722204952.png" alt=""><ul><li>UDP的校验和检查首部和数据部分</li><li>UDP校验和校验出错误时，可以丢弃，也可以交付，但要发送错误报告</li><li>在计算校验和时,要在UDP数据报之前增加12B的伪首部,伪首部并不是UDP的真正首部。只是在计算校验和时,临时添加在UDP数据报的前面,得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。</li><li>校验方法<font color=blue>(不可能大题，算到猴年马月去)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722205439.png" alt="UDP校验方法"></li></ul></li></ul></li><li><p>TCP协议<font color=blue>(超重点！！！)</font>：</p><ul><li>特点：<ul><li>TCP协议是在不可靠的IP层上实现了可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。</li><li>TCP面向字节流（TCP传送时逐个字节传送，但注意！！！TCP报文并不是只有1B的数据部分，而是一整个TCP数据报被逐个字节发送出去，例如一段100B的TCP报文段，被逐个字节地通过滑动窗口协议发送给目的地址）</li></ul></li><li>TCP报文段首部格式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722210855.png" alt="TCP报文段首部格式"><ul><li>源端口、目的端口：各16位（2B）</li><li>序号（seq）：4B，范围0 ~ (2^32)-1<ul><li>例如：一段报文的第一个字节序号字段值是301，报文段共携带100B数据，则本报文段下一个字节序号301，最后一个字节序号400，下一个报文段的序号应该是401开始</li></ul></li><li>确认号（ack小写）：4B，期望收到对方下一个报文段的第一个数据字节的序号，若确认号N，则表示N-1和之前的数据都已经正确收到<ul><li>例如：B正确收到了A发来的一个报文段，序号字段501，数据长度200B，这表明B正确收到了包含501~700序号的数据的TCP报文（这个报文被逐字节发送接收），于是B在发给A的确认报文中将确认号置为701.</li></ul></li><li>数据偏移（首部长度）：4位，单位是4B，不是IP数据报那个数据偏移，而是首部长度（因为首部有变长的选项字段）。最大长度15*4=60B</li><li>保留：6位，保留为今后使用，目前置0</li><li>紧急位URG：为1时是紧急数据，因尽快传送（不用排队/不入缓存）</li><li><strong>确认位ACK</strong>：ACK=1时上面的确认号才能用，表明这是个确认报文<ul><li>连接建立后所有报文段都是ACK=1</li></ul></li><li>推送位PUSH：PUSH=1时应该尽快交付（≠传送，是已经接收并放到缓存里了），不用等缓存满了才交付<ul><li><ul><li>注意<strong>紧急位URG</strong>是在<strong>发送方中不用排队,不入缓存</strong>,紧急交付;而<strong>推送位PSH</strong>则是在<strong>接收方缓存中尽快交付,不等缓存满即交付</strong></li></ul></li></ul></li><li>复位位RST：RST=1时，表示TCP连接出现严重差错，必须释放连接，重新建立连接</li><li><strong>同步位SYN</strong>：SYN=1表示这是个连接请求或连接接收报文。<ul><li>SYN=1，ACK=0表示这是个连接请求报文，对方正确收到就应回复SYN=1，ACK=1</li></ul></li><li>终止位FIN：FIN=1时用来释放连接</li><li><strong>窗口字段</strong>：2B，对方的窗口数量，表示允许对方发送的数据量</li><li>校验和：2B，包括首部和数据部分</li><li>紧急指针字段：2B，单位1B，表示紧急数据共有多少字节（紧急数据在数据部分的最前面）</li><li>选项：长度可变，TCP只规定了一种选项（最大报文段长度）</li><li>填充字段，使首部长度是4B的整数倍</li></ul></li></ul></li><li><p>TCP的连接<font color=blue>(超重点！！！)</font>：</p><ul><li>连接的建立（三次握手🤝）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722213715.png" alt="TCP连接建立"><ol><li>客户端向服务器发送一个请求连接报文（SYN=1，ACK=0，seq=X）<ul><li>客户端为自己选择一个初始号X</li></ul></li><li>服务器收到请求连接报文后，如同意，就回确认报文（SYN=1，ACK=1，ack=X+1，seq=Y），并为TCP连接准备资源（服务器）<ul><li>服务器端为自己选择一个初始号Y</li></ul></li><li>客户端收到确认报文后还要给服务器一个确认（ACK=1，ack=Y+1，seq=X+1），并为TCP连接准备资源（客户端）</li></ol></li><li>连接的释放（四次挥手👋）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722215028.png" alt="TCP连接释放"><ol><li>客户端向服务器发送一个连接释放报文（FIN=1，seq=U）<ul><li>U是上次客户端发给服务器的数据的最后字节的序号+1</li><li>TCP客户端进入FIN-WAIT-1状态，等待服务器发送FIN=1（客户端：“我说完了”）</li></ul></li><li>服务器收到连接释放报文后发送确认（ACK=1，ack=U+1，seq=V）<ul><li>V是上次服务器端发给客户端的数据的最后字节的序号+1</li><li>服务器进入CLOSE-WAIT状态，发送最后一些数据（服务器：“好的，我还有一点要讲”）</li></ul></li><li>服务期通知客户端释放连接（FIN=1，ACK=1，ack=U+1，seq=W）<ul><li>为什么seq不是V+1？因为2到3之间可能服务器又发了些数据</li><li>服务器进入LASt-ACK状态，等待客户端确认（服务器：“我也讲完了”）</li></ul></li><li>客户端收到连接释放报文后，发出确认（ACK=1，ack=W+1，seq=U+1）<ul><li>客户端进入CLOSED关闭状态（客户端：“好的🆗”）</li></ul></li></ol></li><li>SYN泛洪攻击，不停发送连接请求报文（SYN=1），等服务器同意后发送确认报文，故意不回确认，这样这个TCP连接就被挂起，如果收到大量的TCP请求就会崩溃</li></ul></li><li><p>TCP可靠传输的实现：序号、确认号、重传</p></li><li><p>TCP流量控制<font color=blue>(了解)</font>：滑动窗口协议<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109181558492.png" alt=""></p></li><li><p>TCP拥塞控制<font color=blue>(重点！！！)</font>：</p><ul><li>最大报文段长度MSS</li><li>慢开始算法：先让拥塞窗口cwnd=1，每收到一个新的报文确认就增大拥塞窗口<ul><li>如：A发B，发送方cwnd=1，A收到B关于第一个报文段（非字节）的确认cwnd=2，A收到B关于第二个报文段（非字节）的确认cwnd=4，上限16.</li></ul></li><li>拥塞避免算法：让拥塞窗口缓慢增大<ul><li>如：每经过一个往返时延RTT就让拥塞窗口cwnd+1</li></ul></li><li><strong>慢开始和拥塞避免算法结合</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722224715.png" alt=""><ul><li>传输轮次: A发送一个报文段<code>m1</code>给B,直到收到来自B的<code>m1</code>的确认的时间段即第一个轮次; 然后A发送两个报文段<code>m2、m3</code>给B,直到收到来自B的<code>m3</code>的确认的时间段即第二个轮次;</li></ul></li><li>快重传和快恢复算法：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210722225926.png" alt=""><ul><li>快重传：A发送0到5，B收到<code>0、1、3、4、5</code>，B收到3时会发送ack=2提醒A2号没到，同理4、5，则3次ack确认后A即使还没到超时时间也会立即发2.</li><li>快恢复：发生快重传时cwnd=N；一旦发生快重传，就将慢开始的阈值降低到发生快重传时的一半即N/2；且重新开始慢开始</li></ul></li><li><strong>不管哪种方法，发送窗口的大小由拥塞窗口和接收窗口的最小值决定</strong></li></ul></li><li><p>TCP协议首部20B,IP协议首部20B.</p></li></ol><h1>第六章 - 应用层</h1><ol><li><p>网络应用模型<font color=blue>(了解)</font>：</p><ul><li>客户端/服务器模型<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725194734.png" alt="客户/服服务器模型"></li><li>P2P模型<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725194820.png" alt="P2P模型"></li></ul></li><li><p>域名系统（DNS）<font color=blue>(了解)</font>：将便于记忆的网址（<a href="http://www.google.com">www.google.com</a>）转变为方便计算机处理的IP地址</p><ul><li>协议运行在UDP，使用53端口</li><li>域名服务器层次<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725203004.png" alt=""><ul><li><strong>根域名服务器</strong><ul><li>最高层次服务器，<strong>所有根域名服务器都知道所有顶级域名服务器的IP</strong></li><li>最重要的域名服务器，<strong>本地域名</strong>服务器在无法解析一个域名时，首先求助于根域名服务器</li><li>用来管辖顶级域(如：com)，一般不直接转化为IP，而是告知应该去哪个顶级域名服务器查询</li></ul></li><li><strong>顶级域名服务器</strong><ul><li>负责管理在该顶级域名服务器注册的所有二级域名</li><li>收到DNS查询请求时, 就给出相应的回答</li></ul></li><li><strong>权限域名服务器</strong><ul><li>二级及以下的域名服务器</li><li>每台主机（网站服务器的主机）都必须在授权域名服务器处登记。</li><li>实际上,许多域名服务器都同时充当本地域名服务器和授权域名服务器。</li><li>授权域名服务器总能将其管辖的主机名转换为该主机的IP地址。</li></ul></li><li>本地域名服务器<ul><li>每个因特网服务提供者(ISP),或一所大学,甚至一所大学中的各个系,甚至计算机内都可以拥有一个本地域名服务器。</li><li>当一台主机发出DNS查询请求时,这个 查询请求报文就发送给该主机的本地域名服务器。</li></ul></li></ul></li><li>域名的层次<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725202146.png" alt="域名层次"></li></ul></li><li><p>域名解析过程</p><ul><li>域名解析是指把域名映射成为IP地址或把IP地址映射成域名的过程。前者称为正向解析, 后者称为反向解析。</li><li>当客户端需要域名解析时,通过本机的DNS客户端构造一个DNS请求报文, 以UDP数据报方式发往本地域名服务器。</li><li>查询方式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725203111.png" alt=""><ul><li>递归查询：本机去本地域名服务器查询，本地服务器查不到，将任务转交给根域名服务器，再根域名➡顶级域名➡权限域名一级一级直到查到再返回</li><li>迭代查询：本地域名查不到，由本地域名服务器分别依次去根域名服务器、顶级域名服务器、权限域名服务器查询（根域名告知去哪个顶级域名服务器查询，以此类推，直到查到）。</li></ul></li></ul></li><li><p>文件传输协议FTP<font color=blue>(重要)</font></p><ul><li>特点:<ul><li>FTP采用客户/服务器的工作方式,它使用TCP可靠的传输服务</li><li>一个FTP服务器进程可同时为多个客户进程提供服务</li><li>可匿名方式提供公共文件共享</li></ul></li><li>工作原理：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109202030726.png" alt=""><ul><li>使用两个并行的TCP连接(都是服务器上打开的端口)：<ul><li>控制连接（端口21）：<ul><li>服务器监听21端口，等待客户端连接请求；</li><li>控制信息都以7为ASCⅡ格式发送；</li><li>控制连接整个会话期间都打开</li></ul></li><li>数据连接（端口20）：<ul><li>控制进程收到请求后，就创建数据连接子进程负责该客户端进程的传输</li><li>传送完毕后关闭数据连接子进程</li></ul></li></ul></li></ul><ol><li>打开21端口(控制),使客户进程能够连接上</li><li>等待客户进程发连接请求</li><li>FTP启动从属进程来处理客户端进程发来的请求.主进程和从进程并发执行,从属进程处理完客户进程的请求立即终止</li><li>回到等待状态,继续接收其它客户基础发来的请求</li></ol></li></ul></li><li><p>电子邮件📧<font color=blue>(了解)</font><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725211257.png" alt="组成构件"></p><ul><li>组成部分：<ol><li>用户代理（UA）：用户与电子邮件系统的接口</li><li>邮件📧服务器：负责发送接收邮件和跟踪邮件状态</li><li>协议：SMTP（发送协议，负责用户代理UA发给邮件服务器或邮件服务器之间的发送）、POP3（接收协议，负责UA从邮件服务器读取邮件📧）</li></ol></li><li>电子邮件📧的收发过程：<ol><li>【发】发信人攥写邮件📧。用户代理UA通过STMP发送邮件📧到<strong>发送方</strong>的邮件服务器</li><li>【存】发送方邮件服务器将邮件📧放入缓存队列</li><li>【连】发送方服务器发现缓存队列的邮件后，向接收方的SMTP服务器发起TCP连接。</li><li>【发】（邮件服务器的）<strong>TCP</strong>连接建立后，STMP客户进程开始向远程STMP服务器进程发送邮件📧，发完后关闭TCP连接。</li><li>【存】接收方STMP服务器收到邮件，放入用户邮箱（暂存）</li><li>【取】收信人使用UA调用POP3（或IMAP）将邮件从接收方邮件服务器中的用户邮箱取回</li></ol></li><li>邮件格式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109202056988.png" alt=""><ul><li>”To“和”From“是必需的</li></ul></li><li>多用途网际邮件扩充（MIME）：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109202101068.png" alt=""><ul><li>STMP只支持ASCⅡ码，对非英文用户极不友好，也无法传输二进制文件（图片、压缩包等附件）</li></ul></li></ul></li><li><p>SMTP 和 POP3 和 IMAP<font color=blue>(看看就行)</font>：</p><ul><li>STMP：<ul><li>连接建立、邮件传送、连接释放</li><li>依赖TCP</li></ul></li><li>POP3：<ul><li>UA运行POP客户端程序、邮件服务器运行POP服务器程序</li><li>依赖TCP</li><li>两种工作方式：<ul><li>下载并保留</li><li>下载并删除</li></ul></li></ul></li><li>IMAP（因特网报文存取协议）：<ul><li>只有存取，即邮件接收协议，比POP复杂</li><li>为用户提供：<strong>创建文件夹、不同文件夹间移动邮件、远程文件夹查看邮件、查看邮件报文的部分内容</strong>功能</li><li>需要维护会话用户状态信息</li></ul></li></ul></li><li><p>基于万维网的电子邮件📧<font color=blue>(看看就行)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725214232.png" alt="基于万维网的电子邮件📧"></p><ul><li>直接使用网页发送</li><li>从<strong>发送方到邮件📧服务器</strong>和从<strong>邮件📧服务器到接收方</strong>使用的是HTPP协议</li></ul></li><li><p>万维网和HTTP协议<font color=blue>(了解)</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109202115396.png" alt=""></p><ul><li>万维网一般使用超文本传输协议（HTTP）将资源（一般是HTML）发给使用者</li></ul></li><li><p>HTTP协议<font color=blue>(超重点！！！)</font>：</p><ul><li>特点：<ul><li>无状态（第二次访问页面时和第一次访问，其服务器响应相同）</li><li>无状态特性意味着对于不同客户端的同一页面请求，可以返回相同的响应，<strong>使服务器支持大量并发HTTP请求</strong></li><li>使用cookie和数据库来跟踪用户活动</li><li>使用TCP作为传输层协议，可靠</li><li>持久连接和非持久连接</li></ul></li><li>工作原理：<ol><li>每个站点背后都有一个服务器进程，不断地监听TCP端口80（默认）</li><li>服务器监听到连接请求就与客户端建立连接</li><li>TCP连接建立后，浏览器向服务器发送获取某个Web页面的HTTP请求</li><li>服务器收到HTTP请求后，将构建Web页的必需信息（渲染文件路径、内容文件路径等），通过HTTP响应返回给浏览器</li><li>浏览器解释执行，显示Web页，TCP连接释放</li></ol></li><li>两种报文：HTTP请求报文、HTTP响应报文</li><li>用户单击鼠标后所发生的事件按顺序如下（以访问清华大学的网站为例）<font color=blue>(看看就行)</font>：<ol><li>浏览器分析链接指向页面的URL(<a href="http://www.tsinghua.edu.cn/chn/index.htm">http://www.tsinghua.edu.cn/chn/index.htm</a>)</li><li>浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址。</li><li>域名系统DNS解析出清华大学服务器的IP地址。</li><li>浏览器与该服务器建立TCP连接（默认端口号为80)。</li><li>浏览器发出HTTP请求：<code>GET /chn/index.htm</code></li><li>服务器通过HTTP响应把文件index.htm发送给浏览器。</li><li>释放TCP连接。</li><li>浏览器解释文件index.htm,并将Web页显示给用户。</li></ol></li><li>持久连接和非持久连接<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210725221406.png" alt="连接方式"><ul><li>非持久连接（静态加载）：每个网页元素对象(如JPEG图形、Flash等)的传输都需要单独建立一个TCP连接</li><li>持久连接（动态加载）：是指万维网服务器在发送响应后仍然保持这条连接,使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文<ul><li>持久连接又分为非流水线和流水线两种方式。</li><li><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求。</li><li><strong>流水线方式</strong>：<ul><li>HTTP/1.1的默认方式是使用流水线的持久连接。</li><li>如果所有的请求和响应都是连续发送的,那么所有引用的对象共计经历1个RTT延迟,而不是像非流水线方式那样,每个引用都必须有1个RTT延迟。</li><li>一个对象引用就立即发出一个请求;因而客户可以逐个地连续发出对各个引用对象的请求。</li></ul></li></ul></li></ul></li><li><strong>状态码</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202109202141531.png" alt=""></li></ul></li></ol><h1>新考点</h1><ul><li>SDN：路由选择算法不再运行在每台路由器上，由一台远程控制器负责进行路由选择，路由仅进行转发。<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151102494.png" alt=""><ul><li>网络范围状态管理层负责实现自定义路由选择协议</li><li>向上（北）网络控制应用程序/软件。向下（南）受控网络设备/路由器</li></ul></li><li>VLAN：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151117698.png" alt=""> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151119904.png" alt=""> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202112151123790.png" alt=""></li></ul><h1>tool</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;</span><br><span class="line">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;</span><br><span class="line">红:    &lt;font color=red&gt;&lt;/font&gt;</span><br><span class="line">绿:    &lt;font color=green&gt;&lt;/font&gt;</span><br><span class="line">蓝:    &lt;font color=blue&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">分割线:  </span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">便签：  </span><br><span class="line">&#123;% note success %&#125;  </span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>参考资料</h1><p>王道参考书 &amp; <a href="https://github.com/AFutureD/How-to-learn-408/blob/master/Computer_Networks">GitHub: How-to-learn-408</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="/posts/5c8ae43f/"/>
      <url>/posts/5c8ae43f/</url>
      
        <content type="html"><![CDATA[<h2 id="算法思想">算法思想</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210621193440.png" alt=""><br>如图序列,我们先设置一个基准,假设基准是第一个元素49,每次扫描都将序列变成<code>[比49小的...49...比49大的]</code>这种形式,然后在分别递归地对49左右两边的<br>序列进行相同操作,相当于递归的每次调用都确定了一个元素的相对位置(<strong>基准</strong>),所有元素的相对位置都确定了下来,则序列就排好了序.</p><p>现在假设两根指针(标记,其实不是指针)分别指向头和尾, 设基准元素为low指向元素.</p><ol><li>先让high移动直到找到比基准元素49(0)小的元素,即27(6);将其移到low所指位置即0,原来的元素49已经保存在基准当中;<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210621195045.png" alt=""></li><li>再让low移动直到找到比基准元素49大的元素,即65(2);将其移动到high所指位置即6,该位置已经空出;</li><li>1、2步交替进行, 直到low与high指针相遇,<strong>此时将基准元素放到该位置</strong>; 然后进入递归下一层,即分别对基准元素<strong>左右序列进行上述操作直到子序列长度为1</strong>.</li></ol><h2 id="C-实现">C++实现</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210621203133.png" alt=""><br>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> *L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high&lt;=low)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=low,h=high;</span><br><span class="line">    <span class="type">int</span> cp = L[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L[high]&gt;=cp)</span><br><span class="line">            --high;</span><br><span class="line">        L[low]=L[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L[low]&lt;cp)</span><br><span class="line">            ++low;</span><br><span class="line">        L[high]=L[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = cp;</span><br><span class="line">    <span class="built_in">quickSort</span>(L,l,low<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(L,high+<span class="number">1</span>,h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(NULL);</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="built_in">up</span>(n)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">quickSort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">up</span>(n)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python实现">Python实现</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210621210237.png" alt=""><br>Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 6/21/2021 20:32 PM</span></span><br><span class="line"><span class="comment"># @Author  : Chen0495</span></span><br><span class="line"><span class="comment"># @Email   : 1346565673@qq.com|chenweiin612@gmail.com</span></span><br><span class="line"><span class="comment"># @File    : test.py.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">L, low, high</span>):</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high): <span class="keyword">return</span></span><br><span class="line">    l = low</span><br><span class="line">    h = high</span><br><span class="line">    point = L[low]</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high):</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high <span class="keyword">and</span> L[high] &gt;= point): high -= <span class="number">1</span></span><br><span class="line">        L[low] = L[high]</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high <span class="keyword">and</span> L[low] &lt;= point): low += <span class="number">1</span></span><br><span class="line">        L[high] = L[low]</span><br><span class="line">    L[low] = point</span><br><span class="line">    quickSort(L, l, low - <span class="number">1</span>)</span><br><span class="line">    quickSort(L, low + <span class="number">1</span>, h)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="type">List</span> = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    quickSort(<span class="type">List</span>, <span class="number">0</span>, <span class="built_in">len</span>(<span class="type">List</span>) - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">List</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论笔记</title>
      <link href="/posts/f8bc8215/"/>
      <url>/posts/f8bc8215/</url>
      
        <content type="html"><![CDATA[<h1>古典概型</h1><ul><li>逐个检查: 一个一个查完所有.</li></ul><h1>一维变量及其分布</h1><ul><li>F(x)能作分布函数的充分必要条件<ul><li>非降性;</li><li>有界性,F(+∞)=1,F(-∞)=0;</li><li>右连续,F(x) = F(x+0);</li></ul></li><li>伯努利分布可加性: x1与x2独立,$$x_1 ~ B(i_1,p),x_2 ~ B(i_2,p) \Rightarrow x_1+x_2 ~ B(i_1+i_2,p)$$</li><li>泊松分布可加性: x1与x2独立,$$x_1 ~ P(λ_1),x_2 ~ P(λ_2) \Rightarrow x_1+x_2 ~ P(λ_1+λ_2)$$</li></ul><h1>多维随机变量</h1><ol><li>给联合,求边缘:<ol><li>对$$(+∞ \to -∞)$$求积分</li><li>画出积分区域</li><li>求x积y,求y积x</li><li>在积分区域内求导,其它0</li></ol></li><li>已知边缘、条件分布等相关条件，求联合用<strong>乘法公式</strong>：$$f(x,y)=f_{x|y}(x|y)f_x(x)$$</li><li>求<code>X±Y、XY、X/Y</code><ul><li>分布函数法<ol><li>将z视为常数，画出积分区域（积域含z）</li><li>根据不同z的取值计算积分，即得到F(Z)</li></ol></li><li>卷积公式法：<ol><li>X+Y：$$f_z(z)=\int_{-∞}^{+∞} f(x,z-x), {\rm d}x$$或者$$f_z(z)=\int_{-∞}^{+∞} f(z-y,y), {\rm d}y$$</li><li>X-Y：$$f_z(z)=\int_{-∞}^{+∞} f(x,x-z), {\rm d}x$$或者$$f_z(z)=\int_{-∞}^{+∞} f(z+y,y), {\rm d}y$$</li><li>XY：$$f_z(z)=\int_{-∞}^{+∞} |y|f(yz,y), {\rm d}y$$</li><li>X/Y：$$f_z(z)=\int_{-∞}^{+∞} \frac{1}{|y|}f(z/y,y), {\rm d}y$$或者$$f_z(z)=\int_{-∞}^{+∞} \frac{1}{|x|}f(y,z/x), {\rm d}x$$</li></ol></li></ul></li><li><strong>X,Y独立</strong>$$X~N(μ_1,σ_1^2),Y~N(μ_2,σ_2^2) \Rightarrow (X±Y)~Y~N(μ_1±μ_2,σ_1^2±σ_2^2)$$</li></ol><h1>数字特征</h1><ol><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(XY)=E(X)E(Y)-cov(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p></li><li>多维随机变量的均值:$$E(Z)=\int_{-∞}^{+∞} \int_{-∞}^{+∞} z(x,y)f(x,y), {\rm d}x {\rm d}y$$</li><li>一些公式<ol><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mi>E</mi><mi>X</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mi>E</mi><msup><mi>X</mi><mn>2</mn></msup><mo>−</mo><mo stretchy="false">(</mo><mi>E</mi><mi>X</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">D(X) = E(X-EX)^2 = EX^2-(EX)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo>±</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>±</mo><mn>2</mn><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(X±Y) = D(X) + D(Y) ± 2cov(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mi>E</mi><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>Y</mi><mo>−</mo><mi>E</mi><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mi>X</mi><mi>E</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">cov(X,Y) = E[(X-EX)(Y-EY)] = E(XY) - EXEY</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">[(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">EX</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">EXE</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">cov(X,X) = DX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>a</mi><mi>X</mi><mo>+</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mi>Y</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>c</mi><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cov(aX+b,cY+d) = (ac)cov(X,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p></li><li><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>o</mi><mi>v</mi><mo stretchy="false">(</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cov(X+Y,Z) = cov(X,Z)+cov(Y,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span></span></p></li></ol></li><li>切比雪夫不等式估计概率(<strong>D(X)存在</strong>):$$P{|X-EX|≥ε} ≤ \frac{D(X)}{ε^2}$$<ul><li>独立抽样X,其均值EX,则X与EX的差值大于某个极小数的概率小于D(X)/(ε^2)</li></ul></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110092041768.png" alt=""></li></ol><h1>大数定理和中心极限定理</h1><ol><li>依概率收敛<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110101050075.png" alt=""></li><li>大数定律(大样本)<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110101052200.png" alt=""></li><li>三大抽样分布<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110101123632.png" alt=""><ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110101152875.png" alt=""></li></ul></li></ol><h1>参数估计</h1><ol><li>矩估计</li><li>最大似然估计</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线代笔记</title>
      <link href="/posts/cfa485f3/"/>
      <url>/posts/cfa485f3/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><div class="note success flat"><p>此页面公式渲染器由mathjax更改为katex。katex测试：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">A{A^*} = E|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span></span></span></span></p></div><p>测试katex：</p><p><strong>尚不熟悉考点</strong>：</p><ul><li>副对角线三角行列式的值</li><li>负对角线元素要留心！（分块、伴随…）</li><li>区分矩阵加乘法（对应元素）与行列式加乘法（对应某一行列）</li><li>分块矩阵的逆</li></ul><h1>行列式、矩阵</h1><h2 id="行列式">行列式</h2><ol><li>证|A| = 0<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210624163843.png" alt="A"></li><li>爪形行列式：利用2、3、4…行轮流最第一行进行处理</li><li>三对角行列式：<ul><li>法1：利用2、3、4…行轮流最第一行进行处理（化成三角行列式）</li><li>法2：按行/列展开用递推公式</li></ul></li><li>数学归纳法<ul><li>法一:<ul><li>验证n=1时,命题正确;</li><li>设n=k时,假设结论;</li><li>验证n=k+1时,假设依然成立.</li></ul></li><li>法二:<ul><li>验证n=1,n=2;</li><li>设n&lt;k时,成立;</li><li>验证n=k时,成立.</li></ul></li><li>归纳法的选择<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201348786.png" alt="归纳法"></li></ul></li><li>范德蒙行列式：例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201350471.png" alt="例1"></li><li>某一行代数余子式或余子式的和就等于用1替换掉那一行,然后计算行列式，例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201400550.png" alt="例1"></li></ol><h2 id="矩阵">矩阵</h2><ol><li>分块矩阵：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201409416.png" alt="分块"><ul><li><strong>分块矩阵划分要匹配!!!</strong></li><li>只要划分得当，就把分块当初元素计算就行（除逆、伴随相关）</li></ul></li><li>等价矩阵：A经过初等变换变为B，A等价B</li><li>转置矩阵性质：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201413919.png" alt="转置"></li><li>行（列）向量的重要性质<font color=blue>（重要！！！）</font>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mi>T</mi></msup><mi>β</mi><mo>=</mo><mi>β</mi><msup><mi>α</mi><mi>T</mi></msup><mo>=</mo><mi>t</mi><mi>r</mi><mo stretchy="false">(</mo><mi>α</mi><msup><mi>β</mi><mi>T</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\alpha ^T}\beta  = \beta {\alpha ^T} = tr(\alpha {\beta ^T})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，一般用来计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><msup><mi>β</mi><mi>T</mi></msup><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">{(\alpha {\beta ^T})^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201426157.png" alt="例1"></li></ul></li><li>伴随矩阵：<ul><li>伴随矩阵是转置排列的</li><li>对于二阶矩阵：主对角线互换、副对角线变号</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">A{A^*} = E|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span></span></span></span></li><li>某个元素乘上不是其对应的那个代数余子式,值为0</li></ul></li><li>逆矩阵<font color=blue>（重要！！！）</font>：<ul><li>性质：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201436057.png" alt="性质"></li><li>求逆矩阵：伴随矩阵法、增广矩阵法</li></ul></li><li>矩阵中“*”、“^k”、“T”均可以两两替换,其中只有“*”不能恢复,即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">(</mo><msup><mi>A</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><mo>=</mo><mi mathvariant="normal">∣</mi><mi>A</mi><msup><mi mathvariant="normal">∣</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mi>A</mi><mtext>  </mtext><mrow><mo stretchy="false">(</mo><mi>k</mi><mi>A</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><mo>=</mo><msup><mi>k</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">{({A^ * })^ * } = |A{|^{n - 2}}A{\rm{\;}}{(kA)^ * } = {k^{n - 1}}{A^ * }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord"><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.2778em;"></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">A</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span></li><li>【题型】证明抽象矩阵可逆并求逆矩阵<font color=blue>（求谁提取谁）</font>：<ol><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201450441.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201452682.png" alt="例2"></li><li><strong>例3</strong><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201459107.png" alt="例3"></li></ol></li><li>【题型】A的伴随和A的逆矩阵相关<font color=blue>（死守AA^(*) = |A|A^(-1)）</font>：<ol><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201504469.png" alt="例1"></li><li>抽象型，例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201514640.png" alt="例2"></li></ol></li><li><strong>矩阵及其秩</strong><font color=blue>（A、B中有一个可逆，r(AB)的值等于另一个的秩）</font>：<br>$\eqalign{   &amp; r(AB) \le \min (r(A),r(B))  \cr    &amp; r(A + B) \le r(A) + r(B)  \cr    &amp; r(A,B) \le r(A) + r(B)  \cr    &amp; r(A,B) \ge \max (r(A),r(B))  \cr    &amp; AB = 0 \Rightarrow r(A) + r(B) \le n \cr} $</li><li>方阵A的秩为r(A),则必有n-r(A)个0特征值</li><li><strong>正交矩阵</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup><mi>A</mi><mo>=</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">A^TA=E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li><li>即使不是方阵也行,对于&quot;|AB|=E&quot;求B: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>A</mi><mi mathvariant="normal">∣</mi><mi>E</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>E</mi><mi mathvariant="normal">∣</mi><mi>B</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} A | E \end{bmatrix} = \begin{bmatrix} E | B \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></li></ol><h1>线性方程组、向量</h1><h2 id="向量">向量</h2><ol><li>两个向量组可以互相表出,即等价</li><li>相关性七大定理<ol><li>【充要条件】（相关）至少一个向量可由其它向量线性表出<ol><li>逆否【充要条件】：（无关）任何一个向量都不能由其它向量线性表出</li></ol></li><li>线性无关，加一个β线性相关，则β可由α唯一线性表出</li><li>以少表多，多的相关（被表示的线性无关，则一定是少）<ol><li>被表示的秩不大</li></ol></li><li>【充要条件】列向量组（线性相关），其齐次方程组一定有非零解</li><li>β可由α线性表示 ↔ 非齐次方程组αX=β有非零解 ↔ r(α)=r(α^+)</li><li>部分相关，整体必相关</li><li>原来无关，延长必无关；原来相关，缩短必相关。</li></ol></li><li>正交矩阵的各个行向量是单位向量</li><li><strong>例题</strong>:<ol><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201942330.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110202010833.png" alt="例2"><ul><li><strong>AB=0可推出r(A)+r(B)≤n</strong>n是A的列数量、B的行数量，又A与B的秩都至少为1，所以都不满秩，即1&lt;r(A)&lt;n,1&lt;r(B)&lt;n,所以A列相关、B行相关</li></ul></li><li>例3<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110202030551.png" alt="例3"><ul><li>只要A不是0矩阵就能用来两端相乘判别是否无关</li></ul></li></ol></li><li>向量空间<font color=blue>（重要！！！）</font>：<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110202134777.png" alt=""></li><li>向量空间类比空间直角坐标系，基就是x、y、z轴上的单位向量，3维空间</li><li>基变换：类比成将空间直角坐标系转化为空间极坐标系</li><li>正交基（基向量两两正交）和规范正交基（基向量两两正交且都是单位向量）</li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110202152663.png" alt="例1"></li></ul></li></ol><h2 id="线性方程组">线性方程组</h2><ol><li>克拉默法则</li><li>特征值等于0所对应的特征向量是基础解系<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210709172530.png" alt=""></li><li>方程组解的情况:<ul><li>齐次有解(AX = 0):<ul><li>必有0解</li><li>若r(A)&lt;n,即约束条件少于未知数,则有非0解</li></ul></li><li>非齐次有解(AX = b):<ul><li><strong>只有r(A) = r(A+),即矩阵A的秩等于增广矩阵(加上b)的秩,才会有解</strong></li><li>r(A) = r(A+) &lt; n,约束条件少了,有无穷多解.</li><li>r(A) = r(A+) = n,约束条件刚刚好,只有唯一解.</li></ul></li><li>约束条件多了不一定有用,但少了一定会造成解变多.</li></ul></li><li>重要解的性质：<ul><li>A^(n+1)X=0的解必是A^nX=0的解</li><li>只要有|A|=0，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">AA^* = |A|E = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，就有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">AA^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>是AX=0的解</li><li>AB=0 ➡ B的列向量都是A的解</li></ul></li><li>习题<ol><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110081507336.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201548220.png" alt="例2"></li><li>例3<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201557658.png" alt="例3"></li><li>例4<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201616751.png" alt="例4"></li><li>例5<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201635478.png" alt="例5"></li><li>例6<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110201657589.png" alt="例6"></li></ol></li><li>A~∧⇔A有n个线性无关的特征向量</li><li>相似矩阵的<strong>秩、行列式、特征值、迹</strong>相同，相似矩阵的函数依然相同A^m~B^m,A^(-1)~B^(-1),f(A)~f(B)其中m可以是“*”、“-1”、“T”</li><li>三角矩阵(主对角线)的特征值就是主对角线上元素.</li><li>对角矩阵特征值就是对角线元素</li><li>同解方程组<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>A</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>B</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(A) = r(B) = r(\begin{bmatrix}A \\B\end{bmatrix})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mclose">)</span></span></span></span></li></ol><h1>特征值特征向量、二次型</h1><h2 id="特征值特征向量">特征值特征向量</h2><ol><li>特征值<ul><li>k重特征值至多只有k个线性无关的特征向量</li><li>不同特征值的特征向量线性无关</li><li>同一特征值的特征向量的线性组合还是其特征向量</li><li><strong>特征值乘起来等于行列式</strong>、<strong>特征值加起来等于迹（主对角线元素和）</strong></li><li>AX=0，则必有0是A的特征值；有几个0特征值，秩就减多少</li><li>特征值与特征向量<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110202203973.png" alt="特征值"></li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110202220905.png" alt="例1"></li></ul></li><li>相似:<ul><li>充分条件：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110210959310.png" alt=""></li><li>充要条件：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110211007948.png" alt=""><ul><li>可对角化：秩为n-λ的重数，也就是说如果矩阵A的特征值是<code>3、3、1</code>，那么必有3E-A的秩是1，这样3E-A才有两个不相关的解</li></ul></li><li>n个不同特征值必相似于对角阵、实对称矩阵必相似于对角阵</li></ul></li><li><strong>求可逆矩阵P和相似矩阵∧</strong><ol><li>求特征值</li><li>对应特征向量<ul><li><strong>重根</strong>对应的特征向量可能相关,也可能不相关,但<strong>若相关,则不能相似对角化</strong></li><li>所以可以相似对角化的矩阵其重根对应特征向量必然无关,比如说3阶矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo>=</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>λ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">λ_1=3,λ_2=3,λ_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,则特征值3对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>λ</mi><mi>E</mi><mo>−</mo><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|λE-A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">λ</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">∣</span></span></span></span>必然有两个线性无关向量,只有一个基础解系</li></ul></li><li>可逆矩阵P就是特征向量组(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>α</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">α_1,α_2,α_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li><li>特征值按照顺序(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">λ_1,λ_2,λ_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)排在对角线上就是相似矩阵∧</li></ol><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110211110847.png" alt="例1"></li></ul></li><li><strong>求正交矩阵Q和相似矩阵∧</strong><ol><li>求特征值</li><li>对应特征向量</li><li>将α特征向量组<strong>正交化</strong>和<strong>单位化</strong>(如果原矩阵A是实对称,不同特征值对应特征向量已经正交,只需要管相同特征值对于特征向量即可)<ul><li>施密特正交化<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110211124499.png" alt="施密特"></li></ul></li><li>特征值排列成相似矩阵∧</li></ol></li><li>实对称矩阵<ul><li>不同特征值的特征向量一定<strong>正交</strong>,<strong>相同</strong>特征值对应向量<strong>可能正交可能无关</strong><ul><li>普通矩阵不同特征值对应特征向量是线性无关</li><li>普通矩阵<strong>相同</strong>特征值对应特征向量<strong>可能相关可能无关</strong></li></ul></li><li>必有相似对角阵,且可用正交矩阵Q相似对角化</li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110231627110.png" alt="例1"></li></ul></li></ol><h2 id="二次型">二次型</h2><ol><li>二次型矩阵就是实对称矩阵，所以其正交变换和上一章一样，只不过多了一步<ol><li>求特征值</li><li>对应特征向量</li><li>将α特征向量组<strong>正交化</strong>和<strong>单位化</strong></li><li>特征值排列成相似矩阵∧</li><li>得到的∧就是<strong>标准型</strong>矩阵<ul><li>根据题目要求化规范型</li></ul></li></ol></li><li>配方法求可逆线性变换（求可逆矩阵P^-1或Q^-1）：<ol><li>直接将某一平方项（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo separator="true">,</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">x_1^2,x_2^2,\ldots,x_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>）与其混合项组成一个完全平方项，配完即可，例如<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><mn>2</mn><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mn>2</mn><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>−</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>−</mo><mn>2</mn><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>−</mo><msubsup><mi>x</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>−</mo><mn>4</mn><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>−</mo><mn>2</mn><msubsup><mi>x</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mn>4</mn><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>−</mo><mn>4</mn><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>2</mn><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}f(x) &amp; = x_1^2 + 2x_1x_2 + 2x_1x_3 - x_2^2 - 2x_2x_3 - x_3^2 \\  \\&amp; = (x_1 + x_2 + x_3)^2 - 2x_2^2 - 4x_2x_3 - 2x_3^2 \\  \\&amp; = (x_1 + x_2 + x_3)^2 - 2(x_2 + x_3)^2 + 4x_2x_3 - 4x_2x_3 \\  \\&amp; = (x_1 + x_2 + x_3)^2 - 2(x_2 + x_3)^2\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:10.5964em;vertical-align:-5.0482em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.5482em;"><span style="top:-7.6841em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-6.1841em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.6359em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-0.1359em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:1.3882em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5.0482em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.5482em;"><span style="top:-7.6841em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.6359em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:1.3882em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5.0482em;"><span></span></span></span></span></span></span></span></span></span></span></li><li>得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>D</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">Y=DX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>,D即上面的系数矩阵,于是有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>Y</mi></mrow><annotation encoding="application/x-tex">X=D^{-1}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>,<strong>D的逆就是所求</strong></li></ol><ul><li>配方法得到的∧的对角线元素不一定是特征值,而寻常方法得到的一定是特征值</li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110231708507.png" alt="例1"></li></ul></li><li>合同<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110231641867.png" alt=""><ul><li>现在对于实对称矩阵A有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi>T</mi></msup><mi>A</mi><mi>C</mi><mo>=</mo><mi>B</mi><mtext> </mtext><mo>&amp;</mo><mtext> </mtext><msup><mi>P</mi><mo>−</mo></msup><mn>1</mn><mi>A</mi><mi>P</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C^TAC = B \, \And \, P^-1AP = B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">&amp;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,P和C的交集就是C是正交矩阵,则：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110232029746.png" alt=""></li><li>性质：<ul><li>合同矩阵 ↔ A与B的正负惯性指数相同</li><li>A与B合同，则A逆与B逆、A转置与B转置也合同</li><li><strong>实对称矩阵</strong>相似必合同</li><li>合同秩相等</li></ul></li></ul></li><li>正定二次型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mi>T</mi></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">x^TAx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">A</span><span class="mord mathnormal">x</span></span></span></span>(<strong>充要</strong>条件):<ul><li>正惯性系数为n,即系数全正</li><li>存在可逆矩阵D,使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>D</mi><mi>T</mi></msup><mi>D</mi></mrow><annotation encoding="application/x-tex">A = D^TD</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></li><li><strong>特征值全大于0</strong>(普通方法求出∧对角线就是特征值)</li><li><strong>顺序主子式全大于0</strong></li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110232001389.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110232021766.png" alt="例2"></li></ul></li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110231715796.png" alt="例1"></li></ol><h1>tool</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;</span><br><span class="line">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;</span><br><span class="line">红:    &lt;font color=red&gt;&lt;/font&gt; </span><br><span class="line">绿:    &lt;font color=green&gt;&lt;/font&gt;</span><br><span class="line">蓝:    &lt;font color=blue&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">分割线:  </span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">表格:  </span><br><span class="line">|        |      |       |</span><br><span class="line">| ----- | --:  | :----: |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line"></span><br><span class="line">便签：  </span><br><span class="line">&#123;% note success %&#125;  </span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">公式：</span><br><span class="line"># 矩阵符号</span><br><span class="line">- 矩阵中括号:\begin&#123;bmatrix&#125; \end&#123;bmatrix&#125;</span><br><span class="line"># 逻辑符号</span><br><span class="line">- 小于等于 \le</span><br><span class="line">- 大于等于 \ge</span><br><span class="line">- 右箭头 \Rightarrow</span><br><span class="line">- 相似~ \sim</span><br><span class="line"># 积分</span><br><span class="line">- -N到N,e^x的积分 \int_&#123;-N&#125;^&#123;N&#125; e^x\, &#123;\rm d&#125;x</span><br><span class="line"># 其它</span><br><span class="line">- 省略号 \ldots</span><br><span class="line"></span><br><span class="line">链接:  </span><br><span class="line">🔗</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 线代 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 线代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树的插入与调整</title>
      <link href="/posts/865e512f/"/>
      <url>/posts/865e512f/</url>
      
        <content type="html"><![CDATA[<h2 id="平衡二叉树相关概念">平衡二叉树相关概念</h2><ul><li><strong>平衡二叉树(AVL)</strong>: 树上任一节点的左子树与右子树高度之差不超过1.</li><li>节点的<strong>平衡因子</strong>: 节点的左子树与与右子树高度之差.</li><li><strong>最小不平衡子树</strong>: 平衡树中插入一个新节点后出现了不平衡的现象,从该新插入节点所在分支进行回溯,找到第一个不平衡的节点,以该节点为根的子树叫<strong>最小不平衡子树</strong>.</li><li>只要将最小不平衡子树调整到平衡状态,插入节点所影响的所有祖先节点的平衡因子也会恢复正常.</li></ul><div class="fj-gallery"><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528195844.png" alt="平衡二叉树"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528200420.png" alt="非平衡二叉树"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528200829.png" alt="最小不平衡子树"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528201032.png" alt="平衡树的恢复"></p>          </div><h2 id="平衡二叉树的恢复">平衡二叉树的恢复</h2><p>平衡二叉树的平衡被破坏的情况可分为以下四种.其恢复操作也不尽相同.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528201244.png" alt=""></p><h3 id="LL平衡旋转-右单旋转">LL平衡旋转(右单旋转)</h3><p>即在最小不平衡树的根节点A的左孩子的左树上插入导致的不平衡.此处注意A是结果而非提前知道.<br>如下图:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528202100.png" alt="LL_0"><br><font color=green size=4>我们在BL上插入新节点,导致A第一个不平衡,这意味着A的原平衡因子是1,B的平衡因子是0,于是我们假设BL、BR、AR的高度相等且都为H.</font><br>之后的情况也与之同理,不再重复.<br>于是我们可以得到<code>BL &lt; B &lt; BR &lt; A &lt; AR</code>.插入之后BL高度变为H+1,B和A的平衡因子也加一.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528204105.png" alt="LL恢复"><br>恢复手段是将其拆分并重新组合(不失顺序,且不能用BL,AR为根,因为可能高度为0即均没有节点),将B作为根节点,A作为B的右树,B原右树作为A的左树.<br><strong>教科书上则用旋转来描述</strong>: 令节点A的左孩子B<font color=red size=4>右上旋</font>替代A作为根节点,并将A节点向右下旋成为B的右子树的根节点,而B的原右子树作为A节点的左子树.</p><h3 id="RR平衡旋转-左单旋转">RR平衡旋转(左单旋转)</h3><p>即在最小平衡树的根节点A的右孩子的右树上插入导致的不平衡.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528204355.png" alt="RR"><br>我们得到序列<code>AL &lt; A &lt; BL &lt; B &lt; BR</code>.恢复手段是拆分组合,将B作为根节点,A作为B的左树,B原来的左树作为A的右树.<br>下面是王道树上的解释: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528204900.png" alt="RR平衡旋转"></p><h3 id="LR平衡旋转-左右双旋">LR平衡旋转(左右双旋)</h3><p>即在最小平衡树的根节点A的左孩子的右子树上插入导致的不平衡.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528205211.png" alt="LR"><br>序列<code>BL &lt; B &lt; BR &lt; A &lt; AR</code>.<strong>发现以A,B为根均无法得到序列相同的平衡二叉树,于是我们思考有没有可能用其它节点做根</strong>.BL与AR可能为空不能做根,但<br>BR则新加入了一个节点必不为空,用新入节点做根也不现实,其大小在BR的范围内,做根的话可能与BR内元素序列的顺序关系冲突.<br>于是我们想让BR的根节点C作为新的根,这样不管新插入节点是不是BR的唯一元素,也不会产生上面说的冲突.<br>从BR中将C拆分出来后作为根节点,B、A分别作为其左右孩子,C拆分剩下的CL,CR则分别插入B、A.而新插入节点在CL还是CR则不重要,题目要求再细分即可.<br>王道书上的另一种角度:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528211414.png" alt="LR恢复-文字版"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528211427.png" alt="LR恢复-图例"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528212257.png" alt="LR恢复-细分"></p><h3 id="RL平衡旋转-右左双旋">RL平衡旋转(右左双旋)</h3><p>思想同上,以新插入节点所在树拆分出来的根节点C作为新的根,A、B极其子树作为孩子,C拆剩下的CL,CR补进A、B当中.<br>王道书:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528212038.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528212110.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210528212126.png" alt=""></p><h2 id="参考资料-4">参考资料</h2><p>《2022年数据结构考研复习指导》极其配套课件.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/posts/2da0528d/"/>
      <url>/posts/2da0528d/</url>
      
        <content type="html"><![CDATA[<h2 id="算法思想-2">算法思想</h2><h3 id="暴力优化">暴力优化</h3><p>给定主串S和模式串P:<br>S:<code>BBC ABCDAB ABCDABCDABDE</code><br>P:<code>ABCDABD</code></p><p>暴力算法就是一个一个地匹配,失配了就模式串P整体后移一位,从头开始与主串S的失配字符的下一个字符开始匹配.<br>如图: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519201204.png" alt=""></p><p>暴力算法做了太多无用功,如下图所示: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519201250.png" alt=""><br><code>D</code>与空格失配后,失配字符前的<code>ABCDAB</code>字串显然是配对的,换言之我们已经知道失配字符前的所有字符,那我们可以根据这些已知字符来跳过一些不可能的情况.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519201732.png" alt=""><br>如上图,<font color="#c678dd" size="4">失配字符<code>D</code></font>之前的字串<code>ABCDAB</code>具有相同且最大的前后缀<code>AB</code>,故我们可以直接跳转使得<strong>失配字符前的字串</strong>的前缀(即模式串的前缀)与后缀(即主串的后缀)相对应.</p><p>也就是说,我们从头到尾假设每个字符失配,得到失配字符前的字串中相同的前缀和后缀,并记录下来,即可省略一大批步骤.那么怎么得到这个相同前后缀呢?</p><h3 id="KMP步骤">KMP步骤</h3><ol><li>寻找前后缀最长公共元素长度<ul><li>对于字串<code>P = P[0] P[1] P[2] ... P[j-1] P[j]</code>,找其最长公共前后缀.</li><li>如果有<code>P[0] P[1] ... P[k] = P[j-k] P[j-k+1] ... P[j]</code>即某条公共前后缀,那么对于一条包含这个公共前后缀的字串T来说,其<strong>最大</strong>公共前后缀长度是<strong>k+1</strong>,当然也可能是0…</li><li>举例说明: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519203848.png" alt=""></li></ul></li><li>求next数组<ul><li>为了更好进行计算机计算,引入next数组,即失配发生后模式串P需要移动到哪个位置.</li><li>其值是将第一步中的最大公共元素长度整体右移一位,并令初值为-1.</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519204311.png" alt=""></li></ul></li><li>根据next数组进行匹配<ul><li>匹配失败,<strong>令j = next[j]</strong>.<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519204733.png" alt=""></li><li>即当模式串字串<code>P[0] P[1] ... P[j-1]</code>与主串字串<code>... S[i-1]</code>匹配失败,i与j匹配失败时, next[j] = k, 故将k移动到j位置, 让P[\k]与S[i]继续匹配.</li></ul></li></ol><h3 id="机算next数组">机算next数组</h3><ol><li>对于值k,已经有<code>P[0] P[1] ... P[k-1]</code>与<code>P[j-k] P[j-k+1] ... P[j-1]</code>,即next[j] = k.</li><li>怎么求next[j+1]?<ul><li>若P[k] == P[j], 那么公共长度可以加一, 即 next[j+1] = k + 1.</li><li>若P[k] ≠ P[j]:<ul><li>若P[next[k]] == P[j], 则next[j+1] = next[k] + 1.</li><li>若P[next[k]] ≠ P[j], 继续递归前缀索引k = next[k], 重复此过程知道条件成立. <strong>这个过程相当于</strong>: 在字符P[j+1]前不存在长度k+1的前后缀相同, 那么是否有某个长度更小的前后缀相同呢?<br>如果存在, 那么为什么是next[k]呢?</li></ul></li></ul></li><li>递归解释<ul><li>如下图所示,已知next[k] = 2(直接看出),那么因为P[k] == P[j], 故next[k+1] = 2 + 1 = 3.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519211730.png" alt=""></li><li>再如下图,P[k] ≠ P[j], 显然因为C不同于D, 所以ABC 跟 ABD不相同, 即字符E前的模式串没有长度为k+1的相同前缀后缀, 也就不能再简单的令：next[j + 1] = next[j] + 1 .所以,咱们只能去寻找长度更短一点的相同前缀后缀.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519212111.png" alt=""></li><li>那么为何要递归呢? 其实就是C与D不同, 但其前面相同(AB == AB, 这里假设是 ABAB = ABAB, 即 <strong>ABABC</strong> 与 <strong>ABABD</strong> 进行匹配), 那么只能是前缀AB(A)与后缀AB(D)匹配, 故要递归向前找长度更小的前缀.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519212402.png" alt=""></li></ul></li><li>代码:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">char</span> *P,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(P);</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;     <span class="comment">//模式串类指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;      <span class="comment">//主串类指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模式串与主串相同 </span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || P[k] == P[j]) <span class="comment">//匹配成功,双双后移并记录当前模式串(即前缀)位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++k;     <span class="comment">// 模式串后移</span></span><br><span class="line">            ++j;     <span class="comment">// 主串后移</span></span><br><span class="line">            next[j] = k;   <span class="comment">// 记录当前模式串(即前缀)位置,即失配时需要移动到的位置.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];  <span class="comment">// 回溯长度更小的前缀.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">up</span>(length)cout&lt;&lt;next[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="next数组优化-nextval">next数组优化(nextval)</h3><p>如下图,b和c失配后,模式串右移2,b和c又失配,这显然是算法缺陷.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519213641.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519213725.png" alt=""><br>问题出在不该出现P[j] = P[next[j]]<br>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNextVal</span><span class="params">(<span class="type">char</span> *P,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(P);</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;     <span class="comment">//模式串类指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;      <span class="comment">//主串类指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模式串与主串相同 </span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; length<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || P[k] == P[j]) <span class="comment">//匹配成功,双双后移并记录当前模式串(即前缀)位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++k;     <span class="comment">// 模式串后移</span></span><br><span class="line">            ++j;     <span class="comment">// 主串后移</span></span><br><span class="line">            <span class="keyword">if</span>(P[j] != P[k]) next[j] = k;</span><br><span class="line">            <span class="keyword">else</span> next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];  <span class="comment">// 回溯长度更小的前缀.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">up</span>(length)cout&lt;&lt;next[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手算next数组">手算next数组</h3><p>考研不需要机算,故使用如下方法,在失配字符前画一条线,然后一步一步后退直到匹配或者过线.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519205540.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210519213310.png" alt=""><br>串的下标从1开始.<br>下标0的位置是留给-1的,只要在下标0的位置加上0就是以-1开头,串下标从0开始计算的next数组.<br>计算nextval数组:  <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210523201045.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">from</span> <span class="number">2</span> to end:</span><br><span class="line">    <span class="keyword">while</span> p[j] == P[<span class="built_in">next</span>[j]]:</span><br><span class="line">        <span class="built_in">next</span>[j] = <span class="built_in">next</span>[<span class="built_in">next</span>[j]] </span><br></pre></td></tr></table></figure><p>因为我们只利用了失配元素之前的元素, 但其实失配元素也能利用起来, 也就是说失配元素失配后, 再下次跳转匹配时若还是相同元素就不可能匹配成功.<br>即当前元素若失配, 跳转到next对应元素, 若还是相同元素, 就应该继续跳到更短的公共前后缀对应位置.</p><p>通俗说就是在当前元素(从2到最后), 如果其next值对应的元素与当前元素相等, 就令当前next值等于对应元素的next值, 重复直到不相等(如当前坐标11,对应next=5,坐标5还是a,继续跳到坐标3依然是a,直到跳到坐标0不相等,所以next[11]=0).</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微分方程求解</title>
      <link href="/posts/645157d/"/>
      <url>/posts/645157d/</url>
      
        <content type="html"><![CDATA[<h2 id="可分离变量方程">可分离变量方程</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517152939.png" alt=""><br>例1:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517154052.jpg" alt=""><br>例2:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517154058.jpg" alt=""></p><h2 id="齐次方程">齐次方程</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517154320.png" alt=""><br>例1:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517155357.jpg" alt=""><br>例2:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517160155.jpg" alt=""></p><h2 id="一阶齐次线性方程-一阶非齐次线性方程">一阶齐次线性方程&amp;一阶非齐次线性方程</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517160510.png" alt=""><br>例1,例2:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517161902.jpg" alt=""><br>例3:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517161907.jpg" alt=""><br>例4:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517161913.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数知识点(持续更新ing...)</title>
      <link href="/posts/992a10c1/"/>
      <url>/posts/992a10c1/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><div class="note success flat"><p>此页面公式渲染器由mathjax更改为katex。katex测试：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">A{A^*} = E|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span></span></span></span></p></div><p>快速关键词定位<code>ctrl + f</code>.<br><strong>尚不熟悉考点</strong>：</p><ul><li>变换求偏导</li><li>非齐次微分方程的特解形式</li><li>中值定理证明题</li><li>级数收敛判别方法中的积分法</li><li>交错级数收敛需要a_n递减</li></ul><h1>曲线面积分及重积分</h1><ol><li><p>第一类曲线积分:</p><ul><li>一投二代三计算<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110040914832.png" alt="第一类曲线积分1"></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051423415.png" alt="第一类曲线积分2"></li></ul></li><li><p>第一类曲面积分</p><ul><li>一投二代三计算<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051427189.png" alt="第一类曲面积分1"></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051428614.png" alt="第一类曲面积分2"></li><li>对称性: 积分区域关于X/Y/Z对称,若被积函数也关于X/Y/Z对称则双倍,若奇函数则0(看被积函数是否对称或奇函数可以代入(X和-X)或(Y和-Y)…</li></ul></li><li><p>三重积分</p><ul><li>先一后二(投影法)</li><li>先二后一(旋转体):<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051416983.png" alt="三重积分"></li><li>球面坐标系(对应极坐标法)</li><li>积分交换次序<ol><li>画出积分区域.</li><li>先对谁积分就画一条直线平行与该轴,移动这条直线穿越积分区域.</li><li>交换积分次序.</li></ol></li></ul></li><li><p>第二类曲线积分</p></li></ol><ul><li>一投二代三计算(化二重积分)<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051502112.png" alt="第二类曲线积分"></li><li>格林公式</li><li>斯托克斯公式(二型曲线积分化一型面积分)<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202111100948751.png" alt=""></li><li>挖孔(针对分母不能为0)</li><li>重积分时,曲线曲面且严格等号,才能代换被积函数</li></ul><ol start="5"><li><p>第二类曲面积分</p><ul><li>一投二代三计算<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051555932.png" alt="第二类曲面积分"></li><li>对称性:与重积分不同,关于Y轴对称即<code>Q(X,Y,Z) = Q(X,-Y,Z)</code>,反而是0;</li><li>高斯公式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110051557515.png" alt="高斯公式"></li></ul></li><li><p>摆线:<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210516150600.gif" alt="摆线"></p></li></ol><h1>极限计算</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>有理函数的极限</li><li>无理函数的极限及推广（0/0、∞/∞、∞-∞、0×∞）</li><li>等价无穷小、洛比达、泰勒求极限</li><li>单侧极限问题</li><li>含参变量极限（分段、注意参变量取值）</li><li>数列极限（连续化、夹逼、单调有界、定积分化）</li></ol></div><ol><li>泰勒公式与等价无穷小<font color=blue>（背！）</font>：sinx、cosx、arcsinx、tanx、arctanx、ln(1+x)、e^x、(1+x)^α</li><li>复合函数的无穷小比阶<font color=blue>（秒杀！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110180938319.png" alt="无穷小比阶"><br>$\matrix{<br>{\matrix{<br>{f(x) \sim a{x^m},g(x) \sim b{x^n} \Rightarrow f[g(x)] \sim a{b^m}{x^{mn}}&gt;}  \cr<br>{f(x) \sim g(x) \Rightarrow \smallint _0^xf(t),{\rm{d}}t \sim \smallint _0^xg(t),{\rm{d}}t}  \cr</li></ol><p>} }  \cr<br>} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3.</mn><mtext>常见单侧极限（看到要注意，要会画图！）</mtext><mo separator="true">,</mo><mtext>根据</mtext><mi>a</mi><mtext>和</mtext><mi>x</mi><mtext>的取值极限不同</mtext><mo stretchy="false">!</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>m</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>n</mi><mn>0495.</mn><mi>t</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">/</mi><mi>C</mi><mi>h</mi><mi>e</mi><mi>n</mi><mn>0495</mn><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>p</mi><mi>i</mi><mi>c</mi><mi>g</mi><mi>o</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>m</mi><mi>g</mi><mi mathvariant="normal">/</mi><mn>202110181003263.</mn><mi>p</mi><mi>n</mi><mi>g</mi><mo stretchy="false">)</mo><mn>4.</mn><mtext>常见不等式</mtext><mo>&lt;</mo><mi>f</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>=</mo><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>&gt;</mo><mtext>（常识！）</mtext><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>f</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mtext>：</mtext><mo stretchy="false">!</mo><mo stretchy="false">[</mo><mtext>常见不等式</mtext><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>m</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>n</mi><mn>0495.</mn><mi>t</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">/</mi><mi>C</mi><mi>h</mi><mi>e</mi><mi>n</mi><mn>0495</mn><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>p</mi><mi>i</mi><mi>c</mi><mi>g</mi><mi>o</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>m</mi><mi>g</mi><mi mathvariant="normal">/</mi><mn>202110180947910.</mn><mi>p</mi><mi>n</mi><mi>g</mi><mo stretchy="false">)</mo><mn>5.</mn><mtext>极限运算技巧</mtext><mn>1.</mn><mtext>泰勒</mtext><mi>y</mi><mi>y</mi><mi>d</mi><mi>s</mi><mtext>！！！</mtext><mn>2.</mn><mtext>洛比达：分母无穷（推广）、分子分母同时趋于无穷或同时趋于</mtext><mn>03.</mn><mi mathvariant="normal">∞</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∞</mi><mtext>型（含根号）：分子分母同除最高次幂，例：</mtext><mo stretchy="false">!</mo><mo stretchy="false">[</mo><mi mathvariant="normal">∞</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">∞</mi><mtext>型</mtext><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>m</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>n</mi><mn>0495.</mn><mi>t</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">/</mi><mi>C</mi><mi>h</mi><mi>e</mi><mi>n</mi><mn>0495</mn><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>p</mi><mi>i</mi><mi>c</mi><mi>g</mi><mi>o</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>m</mi><mi>g</mi><mi mathvariant="normal">/</mi><mn>202110180956252.</mn><mi>p</mi><mi>n</mi><mi>g</mi><mo stretchy="false">)</mo><mn>4.</mn><mtext>含</mtext></mrow><annotation encoding="application/x-tex">3. 常见单侧极限（看到要注意，要会画图！）,根据a和x的取值极限不同![](https://img.chen0495.top/Chen0495/newpicgo/img/202110181003263.png)4. 常见不等式&lt;font color=blue&gt;（常识！）&lt;/font&gt;：![常见不等式](https://img.chen0495.top/Chen0495/newpicgo/img/202110180947910.png)5. 极限运算技巧    1. 泰勒yyds！！！    2. 洛比达：分母无穷（推广）、分子分母同时趋于无穷或同时趋于0    3. ∞/∞型（含根号）：分子分母同除最高次幂，例：![∞/∞型](https://img.chen0495.top/Chen0495/newpicgo/img/202110180956252.png)    4. 含</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3.</span><span class="mord cjk_fallback">常见单侧极限（看到要注意，要会画图！）</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">根据</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">的取值极限不同</span><span class="mclose">!</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ttp</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">//</span><span class="mord mathnormal">im</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">0495.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">0495/</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">wp</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">o</span><span class="mord">/</span><span class="mord mathnormal">im</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">/202110181003263.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mord">4.</span><span class="mord cjk_fallback">常见不等式</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">（常识！）</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">：</span><span class="mclose">!</span><span class="mopen">[</span><span class="mord cjk_fallback">常见不等式</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ttp</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">//</span><span class="mord mathnormal">im</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">0495.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">0495/</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">wp</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">o</span><span class="mord">/</span><span class="mord mathnormal">im</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">/202110180947910.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mord">5.</span><span class="mord cjk_fallback">极限运算技巧</span><span class="mord">1.</span><span class="mord cjk_fallback">泰勒</span><span class="mord mathnormal" style="margin-right:0.03588em;">yy</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord cjk_fallback">！！！</span><span class="mord">2.</span><span class="mord cjk_fallback">洛比达：分母无穷（推广）、分子分母同时趋于无穷或同时趋于</span><span class="mord">03.∞/∞</span><span class="mord cjk_fallback">型（含根号）：分子分母同除最高次幂，例：</span><span class="mclose">!</span><span class="mopen">[</span><span class="mord">∞/∞</span><span class="mord cjk_fallback">型</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">ttp</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">//</span><span class="mord mathnormal">im</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">0495.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">0495/</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">wp</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">o</span><span class="mord">/</span><span class="mord mathnormal">im</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">/202110180956252.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mord">4.</span><span class="mord cjk_fallback">含</span></span></span></span>{1 \over }<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo separator="true">,</mo><mtext>用</mtext><mi>t</mi><mtext>替换</mtext><mn>6.</mn><mtext>等价无穷小的替换：</mtext><mo>−</mo><mtext>乘除随便替换</mtext><mo>−</mo><mtext>只要出现加减就不能随便替换，应该考虑泰勒展开到合适项！</mtext><mn>7.</mn><mtext>洛比达求不出（消不去、求出无穷、死循环）的情况，极限不一定不存在，应该考虑其它办法</mtext><mn>8.</mn><mo>∗</mo><mo>∗</mo><mtext>极限函数</mtext><mo>∗</mo><mo>∗</mo><mo>&lt;</mo><mi>f</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>=</mo><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>&gt;</mo><mtext>（一般是分段函数，特别注意！）</mtext><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>f</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mtext>：找</mtext></mrow><annotation encoding="application/x-tex">,用t替换6. 等价无穷小的替换：    - 乘除随便替换    - 只要出现加减就不能随便替换，应该考虑泰勒展开到合适项！7. 洛比达求不出（消不去、求出无穷、死循环）的情况，极限不一定不存在，应该考虑其它办法8. **极限函数**&lt;font color=blue&gt;（一般是分段函数，特别注意！）&lt;/font&gt;：找</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">用</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">替换</span><span class="mord">6.</span><span class="mord cjk_fallback">等价无穷小的替换：</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">乘除随便替换</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">只要出现加减就不能随便替换，应该考虑泰勒展开到合适项！</span><span class="mord">7.</span><span class="mord cjk_fallback">洛比达求不出（消不去、求出无穷、死循环）的情况，极限不一定不存在，应该考虑其它办法</span><span class="mord">8.</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">极限函数</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">（一般是分段函数，特别注意！）</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">：找</span></span></span></span>{a^n},{x^n},{n^x},{a^{g(n,x)}}$,判断分段点！例：<br>- 例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181012992.png" alt="例1"><br>- x&lt;1,x=1,x&gt;1的极限不同！！！<br>- 例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181014681.png" alt="例2"><br>- x^2和e的大小决定了谁占了主导地位！<br>- 例3<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181016313.png" alt="例3"><br>9. 数列极限问题：连续化、夹逼定理、单调有界准则、定积分化（提1/n,凑i/n）<br>- <strong>夹逼定理技巧</strong><font color=blue>（重要！）</font>：<br>- 老大说了算<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181025370.png" alt="老大说了算"><br>- 人多力量大<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181026568.png" alt="人多力量大"><br>3. 0^0 = 1<br>4. lnx趋于0和趋于∞的速度都远远不如x<br>5. 区间再现<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210626164210.png" alt="区间再现!"></p><h1>求导计算</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>显函数求导</li><li>隐函数求导（常规、对数求导法、参方程）</li><li>变限积分求导</li><li>分段函数求导（注意断点）</li><li>高阶导数求导（归纳法、分解法、莱布尼兹公式、幂函数/泰勒展开）</li></ol></div><ol><li>根据给定极限式判断导数是否存在<font color=blue>（“凑”导数定义式）</font>，例：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181034780.png" alt="“凑”导数定义式"></li><li>求导工具<font color=blue>（部分）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181038379.png" alt="求导工具"></li><li>反函数求导<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181051707.png" alt="反函数求导"></li><li>显函数、隐函数求导、参方程求导（简单）</li><li>变限积分求导：注意通过代换把被积函数化成只含t的函数即可（dt，对t积分）</li><li>高阶导数求导：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181057651.png" alt="高阶导数求导"><ol><li>归纳法：上述公式均可归纳得出</li><li>分解法：例<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181104747.png" alt="分解法"></li><li>莱布尼兹公式：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181105452.png" alt="莱布尼兹公式"></li><li>幂函数/泰勒展开<font color=blue>（重要！）</font>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mo>∗</mo><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">{f^{(n)}}({x_0}) = {a_n}*n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6153em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span></li></ol></li><li>分段函数求导<font color=blue>（重要！）</font>：:<ol><li>必须先判断断点的连续性！</li><li>连续部分直接求导</li><li>断点单独按定义求导</li></ol></li></ol><h1>不定积分</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>第一类换元法</li><li>第二类换元法</li><li>分部积分法</li><li>有理函数积分：分项积分</li></ol></div><ol><li>积分工具<font color=blue>（部分）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181115178.png" alt="积分工具"></li><li>第一类换元法<font color=blue>（多练自然熟）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181141731.png" alt="第一类换元法"></li><li>第二类换元法<font color=blue>（重要！）</font>：<ul><li>根式替换：无理➡有理<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181143646.png" alt="根式替换"></li><li>三角函数替换：化简<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181144662.png" alt="三角函数替换"></li><li>倒代换：分母次数高<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181144045.png" alt="倒代换"></li></ul></li><li>分部积分法：<ul><li>一积一导</li><li>（x^a）* {e^x, lnx, 三角, 反三角}必然可用分部积分</li><li>e^(ax) * {cos(bx), sin(bx)}必然可用分部积分</li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181150725.png" alt="分部积分法"></li></ul></li><li>华罗庚分项法：分子分母只有(sin_x,cosx)型<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210510203458.png" alt="华罗庚分项法1"></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210510205629.png" alt="华罗庚分项法2"></li></ul></li><li>有理函数的积分：<ul><li>假分式（分子阶数比分母高）：分解为“多项式+真分式”</li><li>真分式（分母阶数比分子高），因式分解<font color=blue>（重要！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181156525.png" alt="真分式"><ul><li>例：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181157748.png" alt="例"></li></ul></li></ul></li><li><strong>分段函数不定积分</strong><font color=blue>（重要！）</font>，例：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181201333.png" alt="分段函数不定积分"></li></ol><h1>定积分</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>特殊定积分重要公式</li><li>广义积分及其判敛</li><li>借助定积分特殊公式计算定积分</li></ol></div><ol><li>特殊积分工具<font color=blue>（必背！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181206746.png" alt="特殊积分工具"></li><li>华里士公式<font color=blue>（必考！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181306575.png" alt="华里士公式"></li><li>周期函数<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181307406.png" alt="周期函数"></li><li>广义积分及其判敛<ul><li>正常积分(积分区间有限、被积函数f(x)连续或只有有限间断点)</li><li>反常积分判敛<font color=blue>（重要！）</font>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181317953.png" alt="反常积分判敛"></li></ul></li><li>欧拉函数<font color=blue>（重要！！！）</font>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181319043.png" alt="欧拉函数"></li><li>瑕积分（区间有限、无穷间断点(不是无穷个间断点)）：<ul><li>从有定义的那一端接近，例如(a,b]，a点趋于无穷：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181328159.png" alt="瑕积分"></li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181331063.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181341724.png" alt="例2"></li></ul></li><li>变限积分计算（区分<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mi>x</mi><mn>0</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi><mtext>  </mtext><mi mathvariant="normal">&amp;</mi><mtext>  </mtext><msubsup><mo>∫</mo><mi>x</mi><mn>0</mn></msubsup><mi>x</mi><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi mathvariant="normal">d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\int_x^0 f (x){\mkern 1mu} {\rm{d}}x\;\&amp; \;\int_x^0 x f(t - x){\mkern 1mu} {\rm{d}}t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3648em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.009em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord"><span class="mspace" style="margin-right:0.0556em;"></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">&amp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.009em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord"><span class="mspace" style="margin-right:0.0556em;"></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span></span><span class="mord mathnormal">t</span></span></span></span>，一般用分部积分计算）<font color=blue>（重要！）</font><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181347118.png" alt="例1"></li></ul></li></ol><h1>二重积分</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>定义</li><li>性质<ul><li>一个中值定理</li><li>对称性(必考):关于x、y、x=y、原点、轮换对称性</li><li>积分换序</li></ul></li><li>积分法<ul><li>直面坐标系</li><li>极坐标</li></ul></li></ol></div><ol><li>二重积分本质上是个三维问题<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181408584.png" alt="二重积分"><ul><li>f(x,y)是D正上方定义的三维曲面，求柱体的面积</li><li>f(x,y)dσ就是一小块长条的体积</li></ul></li><li>二重积分中值定理<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181713961.png" alt="二重积分中值定理"><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181713170.png" alt="例1"></li></ul></li><li>对称性<font color=blue>（必考！！！）</font>:<ul><li>关于y=x对称：$\mathop \int!!!\int \nolimits_D f(x,y){\mkern 1mu} {\rm{d}}\sigma  = \mathop \int!!!\int \nolimits_D f(y,x){\mkern 1mu} {\rm{d}}\sigma $</li><li>关于y轴对称：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181720989.png" alt="关于y轴"></li><li>关于x轴对称：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181721238.png" alt="关于x轴"></li><li>关于原点对称：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181726538.png" alt="关于原点对称"></li><li>轮换对称性：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181726046.png" alt="轮换对称性"><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181735579.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110181737476.png" alt="例2"></li></ul></li></ul></li><li>积分法<font color=blue>（重点！）</font><ul><li>直角坐标法：<strong>后积先定限，限内画条线；先交写下限，后交写上限。</strong><ul><li>内部、右部先积，外部、左部后积</li></ul></li><li>极坐标法：<ul><li>原点坐标系：<img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207271949714.png" alt=""></li><li>相对/平移坐标系：<img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207271949742.png" alt=""></li><li>口诀依然适用</li></ul></li></ul></li><li>积分换序<font color=blue>（注意dxdy必须大于0）</font><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182112734.png" alt="例"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182118102.png" alt="例"> <img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182119640.png" alt="例"></li></ul></li><li>积分换序的场景<font color=blue>（重要！）</font>：<ul><li>积不出：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182120826.png" alt="积不出"><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182121215.png" alt="例"></li></ul></li><li>变限积分求导问题：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182123672.png" alt="变限积分求导"><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182122385.png" alt="例"></li></ul></li></ul></li></ol><h1>多元函数微分学</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>定义（极限、可偏导、可微、连续可偏导）</li><li>重要关系图</li><li>计算求偏导<ul><li>显函数</li><li><strong>复合函数求偏导</strong></li><li><strong>隐函数求偏导</strong></li><li>变换求偏导</li></ul></li><li>代数应用（无条件极值、条件极值）</li></ol></div><ol><li>极限的存在性：从<strong>各个方向</strong>接近，其极限相等<ul><li>否定极限存在：找到两个方向的极限不一致即可</li></ul></li><li>区分二重极限与累次极限：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182132482.png" alt="区分"></li><li>极限的连续性<font color=blue>（简单了解）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182136199.png" alt="极限的连续性"></li><li>偏导数<font color=blue>（必考！）</font></li><li>可(全)微分性（重要！！！）：<img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207272020455.png" alt=""></li></ol><ul><li>只要能写出这种形式必然可微！</li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182146143.png" alt="例"></li></ul><ol start="6"><li>判断连续可偏导<font color=blue>（重要！！！）</font>：<ol><li>定义法求偏导</li><li>公式法求偏导</li><li>若定义法与公式法所求一致，则f(x,y)连续可偏导</li></ol><ul><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182154740.png" alt="例"></li></ul></li><li><strong>复合函数求导</strong><font color=blue>（重要！！！）</font>：链式法则（画图）<ul><li>复合函数无论对谁求导，都具有相同的复合结构（链式法则的图相同）</li><li>识别“几元”、“几个”方程：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182206613.png" alt="识别"><ul><li>每有一个约束方程，少一个自由变量</li></ul></li></ul></li><li><strong>隐函数求导</strong><font color=blue>（重要！！！）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110182219157.png" alt="隐函数求导"></li><li><strong>变换求偏导</strong><font color=blue>（重要！！！注意复合函数求偏导后依然有相同复合结构!）</font>：<ul><li>型一：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110190957670.png" alt="型一"></li><li>型二：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110190958339.png" alt="型二"></li><li><strong>解答</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191000156.png" alt="解答"></li><li>例1：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191001895.png" alt="例1"></li><li>例2：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191002308.png" alt="例2"></li></ul></li><li>多元函数代数应用<font color=blue>（非条件极值和条件极值，重要！！！）</font>：<ul><li>非条件极值（区域，不算边界）<ol><li>找偏导为0的点（驻点）</li><li>若所求为最值，全部带入求最值即可</li><li>若所求为极值，求二次偏导验证极值：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191058345.png" alt="极值"></li></ol></li><li>条件极值（边界）<ul><li>拉格朗日法<ol><li>化f(x,y)+λg(x,y)=0</li><li>分别对x，y，λ求偏导并令其为0求出值<ul><li>实在求不出结果就随便写几个数…</li></ul></li></ol></li><li>参数方程法：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191104015.png" alt=""></li></ul></li><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191119494.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191126582.png" alt="例2"></li></ul></li></ol><h1>微分方程</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型！！！</center></font></p><ol><li>概念（微分方程、阶数、通解、解的结构）</li><li>一阶微分方程求解<ul><li>可分离变量型</li><li>齐次型</li><li>一阶线性型</li><li>可降阶的二阶微分方程</li></ul></li><li>高阶微分方程求解（齐次、非齐次）</li></ol></div><ol><li>解的性质<ul><li>齐次解的线性组合还是齐次解</li><li>非齐次解系数加和为0的解是齐次解，系数加和为1的是非齐次解<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191341443.png" alt="解的性质"></li><li>齐次解+非齐次解=非齐次解</li></ul></li><li>一阶微分方程求解<ol><li>变量可分离型：所有x和dx一边、y和dy一边，分别积分。例：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191344319.png" alt="例"></li><li>齐次型：凑成<code>dy/dx,y/x</code>，例：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191346321.png" alt="例"></li><li>一阶线性微分方程：用公式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191349669.png" alt=""></li><li>可降阶的高阶微分方程</li></ol></li><li>高阶微分方程<font color=blue>（重要！！！）</font>：<ol><li>求齐次通解<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191415737.png" alt="齐次通解"></li><li>求非齐次特解<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191416630.png" alt="非齐次特解"></li></ol></li></ol><h1>中值定理</h1><div class="note success flat"><p><font color=blue size=4><center>必会!!!</center></font></p><ol><li>罗尔、拉格朗日、柯西中值定理</li><li>泰勒公式(拉格朗日余项一般用于证明、皮亚诺余项用于计算)<ol><li>拉格朗日余项的n阶泰勒公式：<img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207272021284.png" alt=""></li><li>皮亚诺余项的n阶泰勒公式：<img src="https://img.chen0495.top/Chen0495/qiniu/img2022/202207272022960.png" alt=""></li></ol></li><li>积分中值定理\mathop \smallint \nolimits_a^b f(x){\mkern 1mu} {\rm{d}}t = f(\xi )(b - a){\mkern 1mu} \xi  \in [a,b]</li><li>积分中值定理推广(需要证明)\mathop \smallint \nolimits_a^b f(x){\mkern 1mu} {\rm{d}}t = f(\xi )(b - a){\mkern 1mu} \xi  \in (a,b)<ul><li>证明<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191434617.png" alt=""></li></ul></li><li>柯西不等式<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192131379.png" alt="柯西不等式"></li></ol></div><ol><li>“找原函数” + “折腾区间”（阶数不同、有不是f(ξ)、f’(ξ)或f’'(ξ)的）</li><li><strong>例1</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191500217.png" alt="例1"><ul><li>分析<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191458493.png" alt="分析"></li></ul></li><li><strong>例2</strong>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191511225.png" alt="例2"><ul><li>分析<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191516327.png" alt="分析"></li></ul></li><li>辅助函数分析法<font color=blue>（重要！！！）</font>：<ul><li>型一<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191531613.png" alt="型一"></li><li>型二<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191531398.png" alt="型二"></li><li>型三<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191532090.png" alt="型三"></li><li>型四<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191538621.png" alt="型四"></li></ul></li></ol><h1>级数</h1><div class="note success flat"><p><font color=blue size=4><center>必会题型!!!</center></font></p><ol><li>数项级数的判敛</li><li>幂级数的收敛域</li><li>幂级数的展开和求和</li></ol></div><ol><li>p级数和几何级数<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110191547381.png" alt=""></li><li>正项级数：只能通过和函数有无上界判敛</li><li>交错级数：a_n<strong>递减</strong>并趋于0就收敛</li><li>判别法：<ol><li>比较判别法及其极限形式（用另一个简单级数比较判别）</li><li>幂函数：比值和根值判别法（等于1失效），此处要带x计算（一般是个具体值）</li><li>积分法：连续化后直接积分（数列收敛，其子数列也收敛）</li></ol></li><li>任意项级数的绝对收敛和条件收敛：<ul><li>绝对值、括号增加发散性，交错增加收敛性</li><li>绝对收敛 × 收敛 = 绝对收敛.</li></ul></li><li>幂级数的收敛域：<ol><li>用比值法或根值法（此处不带具体值）<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192022852.png" alt="收敛域"></li><li>然后单独对收敛区间的边界进行判定</li></ol><ul><li>性质：<ul><li>幂级数逐项 求导/积分 后的级数,其收敛半径仍是R,但收敛域可能不同</li></ul></li></ul></li><li>幂函数的展开和求和<font color=blue>（重要！！！）</font>：<ul><li>工具<font color=blue>（必背）</font>：<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192024823.png" alt="工具"></li><li>逐项可导性和逐项可积性，例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192035241.png" alt="例1"></li><li>求和函数:<ol><li>先写✍收敛域</li><li>先导后积|先积后导</li></ol></li></ul></li><li>例题<ol><li>例1<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192039389.png" alt="例1"></li><li>例2<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192112091.png" alt="例2"></li><li>例3<img src="https://img.chen0495.top/Chen0495/newpicgo/img/202110192118625.png" alt="例3"></li></ol></li></ol><h1>拾遗</h1><ol><li>充分和必要<ul><li>充分和必要条件: B包含A,A包含于B,那么发生A一定发生B,称B是A的必要条件,A是B的充分条件.</li><li>小范围是充分条件(相对于大范围), 大范围是必要条件(相对于小范围).</li><li>小范围是大范围的充分条件, 大范围是小范围的必要条件.</li></ul></li><li>三角函数<ul><li>三角函数的反函数嵌套: arcsin(sin_x)=x, arctan(tan_x)=x, arccos(cos_x)=x.</li><li>三角函数的倒数: 1/sin_x = csc_x, 1/cos_x = sec_x, 1/tanx = cot_x.</li><li>特殊三角函数导数记忆: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210510193541.png" alt=""></li><li>反三角函数关系: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210517104153.png" alt=""></li></ul></li><li>周期函数：<ul><li><strong>周期函数的原函数是周期函数的充要条件是其在周期上的积分为0</strong>.</li><li><strong>奇函数求导必是偶函数,偶函数求导必是奇函数;奇函数积分必是偶函数,偶函数积分不一定是奇函数(除非积分在0处是0)</strong>.</li></ul></li><li>极值点不能在端点</li><li>取绝对值不破坏连续性,但会破坏可导性.</li></ol><h1>参考</h1><p>《Kira 高数葵花宝典 2017（修订版）》、《李永乐高数复习全书-数一》</p><h1>tool</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;</span><br><span class="line">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;</span><br><span class="line">红:    &lt;font color=red&gt;&lt;/font&gt;</span><br><span class="line">绿:    &lt;font color=green&gt;&lt;/font&gt;</span><br><span class="line">蓝:    &lt;font color=blue&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">分割线:  </span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拼图</span><br><span class="line">&#123;% gi 2 2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endgi %&#125;</span><br><span class="line"></span><br><span class="line">便签：  </span><br><span class="line">&#123;% note success %&#125;  </span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用栈实现表达式的中后缀转换</title>
      <link href="/posts/bcf7b8cf/"/>
      <url>/posts/bcf7b8cf/</url>
      
        <content type="html"><![CDATA[<h2 id="背景-2">背景</h2><p><strong>中缀表达式</strong>,运算符在操作数的中间,即一般的表达式;<br><strong>后缀表达式</strong>,运算符在操作数的后面;<br><strong>前缀表达式</strong>,运算符在操作数之前.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210508175357.png" alt=""></p><p>下面我们实现由一般的中缀表达式到后缀表达式的转换.</p><h2 id="手算">手算</h2><p>举例说明: <code>a+b*c+(d*e+f)*g</code></p><ul><li>将其按照<strong>先乘除后加减</strong>以及<strong>从左到右</strong>的原则添加上括号<code>((a + (b * c)) + (((d * e) + f) * g))</code>,熟练了该步可以省去,添加括号反而增加麻烦.</li><li>根据括号由内向外将表达式转换为后缀形式<code>a bc* + de* f+ g* +</code>.</li></ul><p>得到最终结果,但此法不适用于计算机.<br>但我们可以从中看出一些规律,这对设计计算机算法有所裨益.<br>例如:</p><ul><li>操作数之间的相对顺序并未改变.</li><li>内层的运算符总是比外层的运算符先输出.</li><li><code>a+b*c</code>中<code>*</code>要先运算;而<code>a*b+c...</code>中也是<code>*</code>先运算,但到<code>+</code>时意味着前面的运算已经影响不到后面的运算了(除非有括号),也就是说在没有括号参与的情况下,低运算级(+,-)前面的高运算级(+,-,*,/)可以输出了.</li><li>接上条,在括号内部的运算总是优先的,于是我们可以将右括号<code>)</code>视为一个括号运算的结束,那么怎么找到与之对应的左括号呢?我们很自然的想到括号匹配问题中使用的<strong>栈</strong>.</li></ul><p>基于以上几条我们可以设计一个适用于计算机的转换算法.</p><h2 id="机算">机算</h2><p>算法思想:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 遇到操作数直接输出;  </span><br><span class="line">2. 遇到左括号&#x27;(&#x27;进栈,直到遇到右括号&#x27;)&#x27;代表该括号内已经运算完毕, 直接一个个输出栈内元素直到匹配到&#x27;(&#x27;或者栈空.  </span><br><span class="line">3. 遇到运算符, 如果是 +,- 则其前面的 +,-,*,/ 已经运算完毕, 全部输出直到栈空或者遇到&#x27;(&#x27;; 如果是 *,/ 则后面可能还有运算, 应该将其先入栈. 这里 +,-,*,/ 也可用优先级表示.  </span><br></pre></td></tr></table></figure><p>实际运算:</p><ol><li>遇到<code>a</code>,输出.<br>输出: <code>a</code><br>栈: <code> </code></li><li>遇到<code>+</code>,入栈.<br>输出: <code>a</code><br>栈: <code>+</code></li><li>遇到<code>b</code>,输出.<br>输出: <code>ab</code><br>栈: <code>+</code></li><li>遇到<code>*</code>,优先级比栈顶元素高,入栈.<br>输出: <code>ab</code><br>栈: <code>+-</code></li><li>遇到<code>c</code>,输出.<br>输出: <code>abc</code><br>栈: <code>+*</code></li><li>遇到<code>+</code>,优先级比栈顶低,输出栈直到空或’(',最后当前运算符入栈.<br>输出: <code>abc*+</code><br>栈: <code>+</code></li><li>遇到<code>(</code>,入栈.<br>输出: <code>abc*+</code><br>栈: <code>+(</code></li><li>遇到<code>d</code>,输出.<br>输出: <code>abc*+d</code><br>栈: <code>+(</code></li><li>遇到<code>*</code>,栈顶’(',故入栈.<br>输出: <code>abc*+d</code><br>栈: <code>+(*</code></li><li>遇到<code>e</code>,输出.<br>输出: <code>abc*+de</code><br>栈: <code>+(*</code></li><li>遇到<code>+</code>,输出栈直到空或者’(',最后当前运算符入栈.<br>输出: <code>abc*+de*</code><br>栈: <code>+(+</code></li><li>遇到<code>f</code>,输出.<br>输出: <code>abc*+de*f</code><br>栈: <code>+(+</code></li><li>遇到<code>)</code>,输出直到匹配到左括号,括号不输出.<br>输出: <code>abc*+de*f+</code><br>栈: <code>+</code></li><li>遇到<code>*</code>,优先级高,入栈.<br>输出: <code>abc*+de*f+</code><br>栈: <code>+*</code></li><li>遇到<code>g</code>,输出.<br>输出: <code>abc*+de*f+g</code><br>栈: <code>+*</code></li><li>遍历完,输出所有栈内元素.<br>输出: <code>abc*+de*f+g*+</code><br>栈: <code> </code></li></ol><p>完成,结果为<code>abc*+de*f+g*+</code></p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prior</span><span class="params">(<span class="type">char</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x==<span class="string">&#x27;*&#x27;</span>||x==<span class="string">&#x27;/&#x27;</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">type_element</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; x&lt;=<span class="string">&#x27;9&#x27;</span>)||(x&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;z&#x27;</span>)||(x&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;(&#x27;</span>||x==<span class="string">&#x27;&#123;&#x27;</span>||x==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">&#x27;)&#x27;</span>||x==<span class="string">&#x27;&#125;&#x27;</span>||x==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">prior</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pairElement</span><span class="params">(<span class="type">char</span> x,<span class="type">char</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x==<span class="string">&#x27;(&#x27;</span>&amp;&amp;y==<span class="string">&#x27;)&#x27;</span>)||(x==<span class="string">&#x27;&#123;&#x27;</span>&amp;&amp;y==<span class="string">&#x27;&#125;&#x27;</span>)||(x==<span class="string">&#x27;[&#x27;</span>&amp;&amp;y==<span class="string">&#x27;]&#x27;</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">verdict</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; S;</span><br><span class="line">    <span class="type">int</span> lens = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="built_in">up</span>(lens)</span><br><span class="line">    &#123;   <span class="type">int</span> t = <span class="built_in">type_element</span>(str[i]);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,str[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)S.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">char</span> tmp=S.<span class="built_in">top</span>();</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">type_element</span>(tmp)!=<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,tmp);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pairElement</span>(tmp,str[i]))<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">char</span> tmp=S.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">type_element</span>(tmp)==<span class="number">2</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">prior</span>(tmp)&gt;=t)&#123;</span><br><span class="line">                    S.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            S.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,S.<span class="built_in">top</span>()),S.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(NULL);</span></span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="built_in">verdict</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考-2">参考</h2><p><a href="https://www.cnblogs.com/wkfvawl/p/12864789.html">🔗数据结构——中缀转后缀表达式🔗</a><br><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95">🔗中缀表示法-Wikipedia🔗</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数与出栈顺序数</title>
      <link href="/posts/c1af42a4/"/>
      <url>/posts/c1af42a4/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>卡特兰数是组合数学中一个常在各种计数问题中出现的数列。以比利时的数学家欧仁·查理·卡特兰（1814–1894）命名。历史上，清朝数学家明安图（1692年－1763年）在其《割圜密率捷法》中最先发明这种计数方式，远远早于卡特兰。有中国学者建议将此数命名为“明安图数”<br>或“明安图-卡特兰数”。-- by Wikipedia<br>其一般公式为:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210503112249.png" alt="卡特兰数"></p><h2 id="问题">问题</h2><p>n个不同元素依次入栈,问有多少种合法的出栈顺序?</p><h2 id="思路">思路</h2><p>有A、B两个元素,入栈顺序AB,则出栈情况有两种:</p><ol><li>入A, 出A, 入B, 出B.</li><li>入A, 入B, 出B, 出A.</li></ol><p>现在假设f(n)为 &quot; n 个不同元素依次入栈, 出栈顺序的种类数&quot;. 显然f(1)=1,f(2)=2.<br>现在按照<strong>第一个入栈元素,在出栈序列中的位置</strong>进行<strong>分类</strong>讨论, 假设入栈序列ABCD:</p><ol><li>A第一个出栈时,A先进,然后马上出栈.这种情况下,共有“BCD出栈顺序的种类数”种方案.也就是f(n-1)种.</li><li>A第二个出栈时,A先进,B再进,之后B需要马上出来(这样才能确保A排第二),此时共有f(n-2)种方案.</li><li>A第三个出栈时,A先进,之后只要确保排在A后面两个的元素比A先出即可.此时共有f(2)*f(n-3)种方案.f(2)是指“BC入栈出栈顺序的种类数”,f(n-3)是指”D入栈出栈的种类数”.</li><li>A第四个出栈时,A先进,只需确保排在A后面的三个元素比A先出即可,即f(n-1)种.</li></ol><p>此时可得:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210503114431.png" alt=""></p><p>上式中,f(0)=1.<br>这个实际上就是卡特兰数的递推式:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210503114722.png" alt=""><br>其通项公式即:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210503114841.png" alt=""><br>也可以表示为:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210503112249.png" alt=""></p><p>所以元素A、B、C、D依次进栈,其所有可能的出栈序列,应该有14种情况<br>A第一个出栈：ABCD;ACBD;ACDB;ABDC;ADCB;<br>A第二个出栈：BACD;BADC;<br>A第三个出栈：CBAD;BCAD;<br>A第四个出栈：BCDA;CBDA;CDBA;BDCA;DCBA.</p><h2 id="参考">参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0">🔗卡塔兰数-维基百科🔗</a><br><a href="https://blog.csdn.net/akenseren/article/details/82149145">🔗n个数依次入栈，出栈顺序有多少种？🔗</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深搜与广搜</title>
      <link href="/posts/ea6d86f8/"/>
      <url>/posts/ea6d86f8/</url>
      
        <content type="html"><![CDATA[<h2 id="深搜">深搜</h2><p>例: 求1到n这n个数的全排列<br>如图:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424204815.png" alt=""><br>相当于前序遍历<code>根 -&gt; 左 -&gt; 右</code>的顺序,将一个子树遍历到底再回溯.<br>注意回溯需要保存和还原现场!!!<br>即<code>12_ -&gt; 123</code>操作完成之后从子节点回溯到父节点需要还原现场:<code>123 -&gt; 12_</code>.<br>用栈.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424211930.png" alt=""><br>代码之后补…</p><h2 id="广搜">广搜</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424212032.png" alt=""></p><h2 id="参考-3">参考</h2><p><a href="https://www.acwing.com/blog/content/672/">🔗DFS (弱弱 =》 深搜 =》神搜 =》大佬)🔗</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 深搜 </tag>
            
            <tag> 广搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法浅析</title>
      <link href="/posts/300f6cc8/"/>
      <url>/posts/300f6cc8/</url>
      
        <content type="html"><![CDATA[<h2 id="正文">正文</h2><p>简单介绍下迪杰斯特拉算法,一般用于寻找最短路.</p><ul><li>如图1到6的最短路是: <code>1 -&gt; 2 -&gt; 3 -&gt; 5 -&gt; 6</code><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424201424.png" alt=""></li><li>注意到在最短路径中,起点到中间节点比如 <code>1 -&gt; 3</code> 的最短路仍然包含在整个最短路径中 <code>1 -&gt; 2 -&gt; 3</code>,这很容易验证,如果起点到中间点有<br>更短的路径,那么起点到终点最短路径就不是上面那一条了,显然矛盾.</li><li>基于上述思想,我们可以找到<font color=red>一条从起点到终点的路径(最短路径)</font>,<font color=green>其起点到每一个中间节点的距离依然是这两者的最短距<br>离<font>,于是我们只需要找到离当前节点最近的节点作为当前路径的下一个目的地,直到到达终点或者遍历完所有可到达点为止.</li></ul><p>基本流程:</p><ol><li>建立<strong>存储矩阵</strong>,存放点到点的距离,初值默认<strong>无穷大</strong>:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424201431.png" alt=""></li><li>创建<strong>最短距离数组</strong>,存放起始点到各个点的距离,初值默认<strong>无穷大</strong>:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424201436.png" alt=""></li><li>创建<strong>标记数组</strong>,标记该点是否已访问,初值默认False.</li><li><ol><li>标记起点.</li><li>从起点开始,访问离起点最近的值(此处为2)并标记,更改<strong>最短距离数组</strong>中节点2的值.</li><li>找离 2 最近的点(此处为4),访问并标记,更改<strong>最短距离数组</strong>中节点4的值.</li><li>…</li><li>到达终点或遍历完所有可到达节点,结束.</li></ol></li></ol><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210424201441.png" alt=""></p><h2 id="参考文献">参考文献</h2><p><a href="Dijkstra%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3">🔗Dijkstra算法图文详解🔗</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ACM]Python素数打表的方法</title>
      <link href="/posts/521f484e/"/>
      <url>/posts/521f484e/</url>
      
        <content type="html"><![CDATA[<p>总而言之就是</p><ul><li>2筛出4;<code># ×2</code></li><li>2,3筛出6,9;<code># ×3</code></li><li>2,3筛出8;<code># ×4,4%2==0,直接跳出,故不计3×4=12,又因为2是4的最小素因子,所以4*3=(2*2)*3=2*(2*3)=2*6=12,即12会被6筛出,此处不需要多此一举</code></li><li>2,3,5筛出10,15,25;<code># ×5</code></li><li>2,3,5筛出12,18,30;<code># ×6,同理,6%2==3,后面的3,5不需要算了,因为6*5=(2*3)*5=2*(3*5)=2*15=30被15筛出,此处若计算3,5将多出大量无用计算</code></li><li><font color=red size=5>是否跳过多余计算比较:</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210423223047.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20210423223236.png" alt=""></li></ul><p>Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8-*-</span></span><br><span class="line">maxl = <span class="number">1000000</span>  <span class="comment"># 筛选范围</span></span><br><span class="line">count = <span class="number">0</span>       </span><br><span class="line">ss = []    <span class="comment"># 素数</span></span><br><span class="line">check = [] <span class="comment"># 0代表素数，1代表合数。全部初始化为素数。</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, maxl+<span class="number">1</span>):</span><br><span class="line">check.append(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 筛选出 2~10^6 所有素数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, maxl):</span><br><span class="line"><span class="comment"># 如果是素数就存起来</span></span><br><span class="line"><span class="keyword">if</span> check[i] == <span class="number">0</span>:</span><br><span class="line">ss.append(i)</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"><span class="comment"># 循环存起来的素数</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, count):</span><br><span class="line"><span class="comment"># 素数的i倍，肯定是一个合数</span></span><br><span class="line"><span class="keyword">if</span> ss[j]*i &gt; maxl:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="comment"># 将素数的i倍标注为合数，这儿将所有素数视为最小素数，那么最小素数对应的所有合数都会被标注。</span></span><br><span class="line">check[ss[j]*i] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 循环素数列表，如果被筛选的数能被列表中某个数整除，由于列表中的素数是有序的，所以该素数就是被筛选数的最小素因子。</span></span><br><span class="line"><span class="comment"># 我们知道上一句代码就是用来筛选出素因子对应合数的，既然合数 i 对应的最小素因子已经在素数列表中了，那么合数 i 肯定</span></span><br><span class="line"><span class="comment"># 会被改素数给筛选出，所以结束当前循环，没必要用其他素数去筛选 i </span></span><br><span class="line"><span class="keyword">if</span> i%ss[j] == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(ss[:<span class="number">100</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式期末复习</title>
      <link href="/posts/7e85d4a5/"/>
      <url>/posts/7e85d4a5/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-分布式计算概述">第一章 - 分布式计算概述</h2><ol><li><p>分布式计算、并行计算的概念<br>分布式计算指在☞分布式系统上运行的计算, 它是将一个大型计算任务分成很多部分分别交给其他的计算机处理, 并将所有的计算结果合并为原问题的一种计算方式.<br>并行计算是指同时使用多种计算资源解决计算问题的过程，是提高计算机系统计算速度和处理能力的一种有效手段。它的基本思想是用多个处理器来协同求解同一问题，即将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算.</p></li><li><p>一个典型的分布式系统构成<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201223151046.png" alt=""></p></li><li><p>分布式系统的特征<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201223151215.png" alt=""></p></li><li><p>CAP理论</p></li></ol><div class="fj-gallery"><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201223152128.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201223152105.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225124623.png" alt=""></p>          </div><ol start="5"><li><p>分布式计算的核心技术<br><font size=4 color=red>进程间通信</font>: (interprocess communication，IPC)，即在互相独立的进程（进程是程序的运行时表示）间通信及共同协作以完成某项任务的能力。</p></li><li><p>分布式存储系统分为哪两个层次<br>文件级和数据库系统</p><ul><li><em>ps: 存储还能咋存, 只有文件和数据库了</em></li></ul></li><li><p>分布式计算系统<br>批处理分布式计算、流处理分布式计算、混合计算<br><a href="https://www.zhihu.com/question/306242771/answer/825668022">🔗流式计算与批量计算有什么区别？🔗</a></p></li></ol><h2 id="第二章-web框架实现">第二章 - web框架实现</h2><ol><li><p>流行的web框架采用mvc 模式（模式-视图-控制器）<br><a href="https://blog.csdn.net/liitdar/article/details/86685880">🔗MVC模式简介🔗</a><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201223154609.png" alt=""></p></li><li><p>web框架的语言<br>常用的语言有PHP、java、perl、nods.js、go</p><ul><li><em>ps: PHP是世界上最好的语言</em></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201224105100.png" alt=""></li></ul></li><li><p>超文本传输协议HTTP<br>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议(TCP/IP Model)。HTTP是万维网的数据通信的基础。</p></li><li><p>HTTP请求消息结构</p></li></ol><ul><li>请求行（例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件）</li><li>消息头（例如Accept-Language: en）</li><li>空行(一定要隔开)</li><li>实体内容(其他消息体)</li></ul><ol start="5"><li>HTTP请求方法(8种):</li></ol><blockquote><p>GET</p><blockquote><p>获取一个URL指定的资源,即资源实体.</p></blockquote><p>HEAD</p><blockquote><p>获取一个指定资源的信息(元数据,即“关于该资源的信息”)</p></blockquote><p>POST</p><blockquote><p>向服务器提交数据</p></blockquote><p>PUT</p><blockquote><p>向服务器提交资源, 一般用于更新操作, 其与POST的区别在于: 多次调用同一 PUT 请求将始终产生相同的结果, 而重复调用 POST 请求具有多次创建同一资源的副作用.[^1]</p></blockquote><p>DELETE</p><blockquote><p>请求源服务器删除Request-URI标识的资源</p></blockquote><p>TRACE</p><blockquote><p>网络跟踪. 回显服务器收到的请求，主要用于测试或诊断。</p></blockquote><p>OPTIONS</p><blockquote><p>查询能力, 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p></blockquote><p>CONNECT</p><blockquote><p>与PROXY之间的连接管理</p></blockquote></blockquote><ol start="6"><li><p>响应状态码用于表示服务器对请求的各种不同处理结果和状态，它是一个三位的十进制数。响应状态码可归为5种类别，使用最高位为1到5来进行分类，如下所示：</p><ul><li>100~199<ul><li>信息，服务器收到请求，需要请求者继续执行操作</li></ul></li><li>200~299<ul><li>成功，操作被成功接收并处理</li></ul></li><li>300~399<ul><li>重定向，需要进一步的操作以完成请求。例如，请求的资源已经移动一个新地址。</li></ul></li><li>400~499<ul><li>客户端错误，请求包含语法错误或无法完成请求</li></ul></li><li>500~599<ul><li>服务器错误，服务器在处理请求的过程中发生了错误</li></ul></li><li>例如:<ul><li>200（正常）: 表示一切正常，返回的是正常请求结果。</li><li>206（部分内容）: 客户发送了一个带有Range头（要求服务器只返回文档中的部分内容）的GET请求，服务器按要求完成了这个请求。</li><li>302/307（临时重定向）: 指出被请求的文档已被临时移动到别处，此文档的新的URL在Location响应头中给出。</li><li>304（未修改）: 表示客户机缓存的版本是最新的，客户机应该继续使用它。</li><li>401（未经授权）: 表示客户机访问的是一个受口令和密码保护的页面，结合使用一个WWW-Authenticate响应头提示客户机应重新发出一个带有Authorization头的请求消息。</li><li>404（找不到） : 服务器上不存在客户机所请求的资源。</li><li>500（内部服务器错误） : 服务器端的CGI、ASP、JSP等程序发生错误。</li></ul></li></ul></li><li><p>WEB会话是指web客户端与服务器的一次连接、中间多次交互到最后断开的过程。由于HTTP协议是无状态的，因此需要会话跟踪技术管理客户端的多次请求的状态信息。会话（Session） 跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session</p></li><li><p>spring框架<br>控制反转概念、两种常见实现方式</p></li></ol><ul><li>控制反转:<ul><li><strong>概念</strong>: IOC(Inverse Of Control),即把创建对象的权力交给框架, 也就是指☞将对象的创建、对象的处理、对象的管理交给了spring容器. spring容器是spring中的一个核心模块, 用于管理对象.</li><li><strong>实现方式</strong>: <u>依赖注入</u>, <u>依赖查找</u>.</li></ul></li></ul><h2 id="第三章-反向代理与负载均衡">第三章 - 反向代理与负载均衡</h2><ol><li><p>代理有两种, 分别是前向代理和反向代理<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201224102939.jpeg" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201224102753.jpeg" alt=""></p></li><li><p>因为反向代理放置在web服务器之前，所以有下列作用</p><ul><li><strong>负载均衡</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201224103308.png" alt=""></li><li><strong>服务加速</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201224103341.png" alt=""></li><li><strong>请求鉴权</strong>: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201224103357.png" alt=""></li></ul></li><li><p>常用的负载均衡技术有: <u>DNS负载均衡</u>、<u>硬件负载均衡</u>、<u>软件负载均衡</u>.</p><ul><li><em>ps: 负载均衡是针对服务器的, 为了缓解服务器压力就需要从3个方面入手, 硬件就是服务器配置好坏, 软件就是通过服务器上专门处理负载的软件来管理, DNS就是在请求到达服务器之前分流到其他服务器处理</em></li></ul></li></ol><h2 id="第四章-分布式同步中间件">第四章 - 分布式同步中间件</h2><ol><li><p>常见的分布式计算模型有:<br>消息传递、客户-服务器、p2p模型、消息系统、远程过程调用、分布式对象、网络服务、移动代理、云服务.<br><a href="https://blog.csdn.net/u010926964/article/details/50985368">🔗五大分类九大范型🔗</a></p></li><li><p>比较消息传递模型和分布式对象模型</p></li></ol><div class="note info flat"><p>消息传递范型</p></div><p>消息传递范型是最基本的分布式计算范型，要求参与双方是紧耦合的，交互过程中，进程之间必须直接通信，如果进程之间的通信消息丢失（由于通信链路、系统或某个进程的失败），协作将失败；消息传递范型是面向数据的范型，适用于网络服务和简单网络应用，但是不适合包含大量混合请求和应答的复杂应用。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225125653.png" alt=""></p><div class="note info flat"><p>分布式对象范型</p></div><p>而分布式对象范型是在消息传递模型之上提供抽象的一种范型。与面向数据范型相比，分布式对象范型是面向行为的，它用分布式对象表示网络资源，注重于从网络资源请求服务，请求进程调用分布式对象的某个方法或操作，将数据作为方法参数传递。随后该方法在远程主机上执行，并将结果作为返回值回送给请求进程。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225125653.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225125808.png" alt=""></p><ol start="3"><li><p>分布式一致性协议<br>分为基于状态机的复制协议和基于主副本的复制协议:<br>基于<strong>状态机</strong>的复制协议的算法有<u>paxos、raft</u><br>基于<strong>主副本</strong>的复制协议的算法有<u>zab、两阶段提交协议</u></p></li><li><p>paxos和raft算法原理[^2]</p></li></ol><div class="note info flat"><p><strong>paxos</strong>:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225131844.png" alt="原理"><br>Paxos将节点进程分成&quot;<strong>发起者</strong>&quot;“<strong>接收者</strong>”“<strong>学习者</strong>&quot;三类, 论文称每个发起者发起的新的更新为&quot;<strong>提议</strong>”,<br>每个提议包含一个数字n和提议内容,算法实现见上图.<br>首先考虑一种特殊情况，如果在最开始的阶段，所有接收者没有收到任何&quot;提议&quot;，这时发起者发出的提议它们是会直接接受的。<br>然而每次更新过程中，可能存在多个发起者发送提议，那么初始阶段可能各个接收者接受不同的提议，进而无法达成一致。这就要求一个接收者能够接受不止一个&quot;提议&quot;。这么一来就可能存在多个&quot;提议&quot;被&quot;选择&quot;(被大部分接收者接受)。既然会出现多个&quot;提议&quot;同时被选择的情况，最终如何达成一致呢？把条件设严格一点，如果后面被&quot;选择&quot;的&quot;提议&quot;内容都和第一个一致，那么无论有多少&quot;提议&quot;，最终不就相当于只有一个被选择了嘛！问题又来了，如何使得后面被选择的&quot;提议&quot;内容都和第一个一致呢？很简单，再把条件设严格一些，如果已经有&quot;提议1&quot;被选择，那么后续发起者发送的新&quot;提议&quot;的内容必须与&quot;提议1&quot;一致.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发起者：</span><br><span class="line">    发送数字为n，内容为v的&quot;提议&quot;的预请求给所有接收者：</span><br><span class="line">        从回应中挑出数字小于n且数字最大的&quot;提议&quot;，并将提议内容赋给v</span><br><span class="line">        如果回应中没有&quot;提议&quot;，内容v由发起者指定</span><br><span class="line">    发送数字为n，内容为v的&quot;提议&quot;的接收请求给所有接收者</span><br><span class="line"></span><br><span class="line">接收者：</span><br><span class="line">    接收到预请求：</span><br><span class="line">        如果预请求的数字n小于已经接收过的预请求的数字n，continue</span><br><span class="line">        回应发起者，表明自己不会再接收数字小于n的请求以及收到的数字小于n且数字最大的&quot;提议&quot;</span><br><span class="line">    接收到接收请求：</span><br><span class="line">        如果没有收到数字比n大的预请求:</span><br><span class="line">            接受请求</span><br></pre></td></tr></table></figure><p>举个栗子(希腊城邦选举):<br>腊城邦选举的例子，帮助我们理解Paxos算法。城中的一些位高权重的人们(“发起者”)会提出新的&quot;法案&quot;，这些法案需要立法委员(“接收者”)达成一致即多数同意才能通过。于是权贵们会预先给立法委员一些金钱，让他们通过自己的法案，这对应的就是&quot;预请求&quot;，如果立法委员已经收到过更高贿赂的&quot;预请求&quot;，他们会拒绝，否则会同意。权贵们贿赂成功后，会告诉立法委员新的法案，在收到新法案之前，如果立法委员没有收到更高的贿赂，他们会选择接受这个法案，否则会拒绝。很关键的一点是，不要忘了我们是一致性协议，不是真正的立法，因此很关键的一点是如果立法委员在接收到更高的贿赂时已经接受了某个法案，那他会告诉贿赂的权贵这个法案的内容，权贵会将自己发起的法案改成该法案的内容，这样才能够迅速达成一致性。</p></div><div class="note info flat"><p><strong>Raft</strong>:<br>Raft的算法逻辑主要可以分成两个部分，一个是选举部分，另一个是log传输部分。和Paxos部分不同的是，这里的log是连续并且按序传输的。Raft中定义了一个叫term概念，一个term实际上相当于一个时间片，如下图所示，这个时间片被分成两个部分，第一部分是选举部分，第二部分是传输部分。由此Raft的逻辑也可以分成选举和传输前后两个方面进行讲解。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225133118.png" alt=""><br>算法逻辑:<br>在Raft中可以存在多个server，其中每一个server都有机会成为leader，但是真实有效的leader只有一个。于是这个leader的产生需要所有的server去进行竞争。在每个term开始的阶段，众多server需要进行竞选，选出一个有效的leader。每个server被设置了一个300-400ms之间随机的timeout，在如果在timeout内没有收到某一个leader发来的心跳信息，那么这个server就会发起竞选，将自己的term值加一，成为candidate，并寻求其他server的投票。当且仅当某一个candidate收到超过一半的server的票数时，它就成功当选了leader，并开始向每个server发送心跳信息。仅仅这么做其实是存在问题的，如果有多个candidate同时参与竞选，很可能出现选票分散的情况，最终无法选出有效的leader。因而除此之外，Raft还要求如果candidate收到term比自己大的投票请求时将自己的状态修改成follower，这么一来就成了谁的term增加得快的问题，因为timeout是随机的，总会出现更快的server，因此算法最终是收敛的<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225133221.png" alt=""><br>那么当选举成功后，整个集群进入log传输的状态。client会给leader发送需要传输的log，leader收到后在log上附加log的位置索引值和当前term值。这么一来每个log的索引与term值都是独一无二的。leader中会记录所有待传输给server的log索引值，针对于某个server，如果leader现存的索引数目大于待传输值，leader就会向该server传输新的logs。server收到logs后验证第一个log的term是否与自己同索引log的term一致，如果不一致告知leader匹配失败，leader会将传输的索引值减一，再重新传送。如果server验证后发现一致，则删除冲突索引后的所有log，并将新收到的log续借在该索引后面。</p></div><div class="note primary flat"><p><strong>Paxos和Raft的对比</strong>:<br>Paxos算法和Raft算法有显而易见的相同点和不同点。二者的共同点在于，它们本质上都是单主的一致性算法，且都以不存在拜占庭将军问题作为前提条件。二者的不同点在于，Paxos算法相对于Raft，更加理论化，原理上理解比较抽象，仅仅提供了一套理论原型，这导致很多人在工业上实现Paxos时，不得已需要做很多针对性的优化和改进，但是改进完却发现算法整体和Paxos相去甚远，无法从原理上保证新算法的正确性，这一点是Paxos难以工程化的一个很大原因。相比之下Raft描述清晰，作者将算法原型的实现步骤完整地列在论文里，极大地方便了业界的工程师实现该算法，因而能够受到更广泛的应用。同时Paxos日志的传输过程中允许有空洞，而Raft传输的日志却一定是需要有连续性的，这个区别致使它们确认日志传输的过程产生差异。</p></div><ol start="5"><li>一些大公司的分布式同步服务系统案列<br>谷歌的Chubby系统以paxos协议为基础<br>谷歌的zookeeper系统以ZAB协议为基础<br>百度的inexus系统以raft协议为基础</li></ol><h2 id="第五-八章-中间件">第五-八章 - 中间件</h2><ol><li>socket分类</li></ol><div class="note info flat"><p>什么是socket?<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225134429.png" alt=""><br>如图,可简单理解为进程之间负责通信(发送、接收数据)的一个类.</p></div><p>分为:<br>使用<strong>UDP</strong>传输的<strong>数据包socket</strong>(无连接)<br>使用<strong>TCP</strong>传输的<strong>流式socket</strong>(面向连接)</p><ol start="2"><li>socket提供了两种通信方式<br><strong>无连接</strong>和<strong>面向连接</strong></li></ol><div class="note info flat"><p><font color=red>怎么理解面向连接和无连接?</font><br>面向连接(TCP)要先建立起连接通道,然后通过通道传输数据.<br>无连接(UDP)只管往网络上传数据,不管对方是否收得到,大不了多发几次.<br>想象我和你两个客户端(比如QQ),我给你发了一段话<code>苟利国家生死以,岂因祸福避趋之.</code>,但这段话信息量有点大,必须逐个字地发,所以会出现下面两种情况:<br><strong>面向连接</strong>:<br>我: 我要给你发段话<br>你: 发吧<br>我: ‘苟,这是第一个字’<br>你: 收到,发下一个<br>我: ‘利,这是第二个字’<br>你: Copy,next<br>我: ‘国,这是第三个字’<br>我: ‘国,这是第三个字’<br>我: ‘国’???<br>你: 洗澡去了,收到,下一个字<br>我: ‘家’<br>…<br>我: 完毕<br>你: 收到,完毕<br><strong>无连接</strong>:<br>我: ‘苟利国家生死以,岂因祸福避趋之.’ – 这段话发给枪毙名单上的人<br>你: 收…(ping999)…到,‘国’,‘苟’,‘之’,‘因’,‘岂’.<br>你: 我收到了啥玩意?</p></div><ol start="3"><li><p>软件开发通常采用三层结构<br>数据层、业务层、应用层</p></li><li><p>RPC和RMI<br>RPC（Remote Procedure Call Protocol）远程过程调用协议，通过网络从远程计算机上请求调用某种服务。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225143150.png" alt=""><br>RMI:远程方法调用(Remote Method Invocation)。能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端java 虚拟机中的对象上的方法。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225143212.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225143239.png" alt=""></p><ul><li><em>ps: RPC: 发送请求,远程服务期执行后返回结果.</em></li><li><em>ps: RMI: 远程方法在本地虚拟机内有映射(虚拟方法)</em><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225143256.png" alt=""></li></ul></li><li><p>面向连接通信和无连接通信的比较<br>无连接方式将以任意顺序到达，而有连接方式则以发送顺序按序到达</p><ul><li><em>ps: 见2</em></li></ul></li><li><p>比较本地过程调用和远程过程调用<br>本地过程调用，主要是指本地进程间通信，是运行在同一块内存区域之内的进程间的互相通信，通常由系统IPC接口（如消息队列，信号量，共享存储等）来实现，也可以通过本地套接字方式实现。而远程过程调用，则是在本地过程调用的基础上实现远程进程之间的通信，一般由网络套接字来编程实现，远程过程调用会被物理网络的通信状况有所限制，也增加了安全问题，但是不再受本地内存空间以及系统资源的限制。</p></li><li><p>常用的数据库访问中间件两种形式<br>客户端程序库和数据库代理服务器</p></li><li><p>有名的数据库访问中间件<br>MYSQL代理、Cobar、TDDL、MyCAT</p></li><li><p>服务调用中间件<br>阿里的Dubbo、谷歌的gRPC、facebook的Thrift、新浪的Motan、百度的sofa-pbrpc、Navi-pbrpc</p></li><li><p>消息服务中间件<br>领英的kafka、阿里的RocketMQ、雅虎的Pulsar</p></li><li><p>跟踪服务中间件<br>谷歌的Dapper、阿里的EagleEye、twitter公司Zipkin、Naver公司的Pinpoint</p></li><li><p>客户-服务器通信代码<br>无连接:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225144109.png" alt="无连接"><br>面向连接:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225144123.png" alt=""></p></li></ol><h2 id="第九章-分布式文件系统">第九章 - 分布式文件系统</h2><ol><li><p><strong>大型</strong>分布式文件系统都是以<strong>GFS</strong>(Google文件系统, Google File System)为基础<br><a href="http://chen0495.xyz/onemanager/Document/gfs-sosp2003.pdf">gfs-sosp2003.pdf</a></p></li><li><p>分布式文件系统概念<br>分布式文件系统（Distributed File System，DFS）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点（可简单的理解为一台计算机）相连；或是若干不同的逻辑磁盘分区或卷标组合在一起而形成的完整的有层次的文件系统。DFS为分布在网络上任意位置的资源提供一个逻辑上的树形文件系统结构，从而使用户访问分布在网络上的共享文件更加简便。单独的 DFS共享文件夹的作用是相对于通过网络上的其他共享文件夹的访问点。</p><ul><li><em>ps:就是文件分割保存在不同服务器,怎么字多怎么来</em></li></ul></li><li><p>GFS是怎样保证数据一致性的<br>加粗是简记.</p><ul><li><strong>文件加锁</strong>: 对于文件(或目录)命名空间的修改(比如创建新文件), GFS 通过加锁保证其原子性.</li><li><strong>文件增量相同</strong>: 每次写操作后, 文件(或目录)最后一个字节的偏移值在各个副本都是一样的.</li><li><strong>文件位置相同</strong>: 每次写操作修改的文件(或目录)位置(即偏移量)都是一样的.</li><li><strong>单块原子性</strong>: 单数据块的写操作保证其原子性,而且结果是确定的</li><li><strong>一致性、唯一性和不定性</strong>: <strong>一致性</strong>是指多个副本上都保存有<em><strong>相同</strong></em>的数据, <strong>确定性</strong>是指无论几个多数据块写操作同时执行, 其结果是唯一(但不确定)的.</li><li><strong>追加原子性</strong>: 追加操作保证其原子性(不能同时追加?),而且结果是确定的.</li></ul></li><li><p>HDFS体系结构存在什么问题, 怎么解决?<br><font color=green>单点故障问题</font></p></li></ol><div class="note success flat"><p><font color=green size=4>解决方案</font><br>HDFS 2.x 中增加了一个高可用性功能. 具体做法是:<br>- 在Hadoop 2.x 中有两个名称节点(NameNode), 其中一个是活动的, 另一个则待机<br>- 活动名称节点处理所有客户的请求<br>- 和Hadoop 1.x 一样, 待机名称节点管理元数据(元数据: 文件本身的相关信息,如文件大小)<br>- 当活动名称节点出现故障, 待机名称节点处理所有的客户请求<br>- 活动名称节点与待机名称节点的管理和切换通过 Zookeeper 实现<br>相当于美国总统和副总统的关系, 总统干活, 副总统干点小活, 总统挂了副的顶上, 总统和副总统的任命通过米国人民选举产生.</p></div><ol start="5"><li>TFS (Taobao File System,淘宝分布式文件系统,主要针对海量小文件开发)的主要特点:<ul><li>TFS 将多个小图像文件存放在大的磁盘文件里(64MB),极大地减小了文件系统的元数据(以前记每个小文件的信息,现在只记这个大磁盘文件), 缩小了存储空间消耗. 每个块存储多份, 类似GFS/HDFS.</li><li>TFS 集群由两个名称服务器(Name Server,一主一备),和多个数据服务器(Data Server)组成. 两个名称服务器的主备管理通过Linux的心跳机制实现.</li><li>名称服务器处理客户端请求, 管理元数据(如文件与块的对应关系)和数据服务器的加入、退出、心跳等.</li><li>数据服务器管理数据块.</li></ul></li></ol><h2 id="第十一-十三章-NoSQL数据库">第十一-十三章 - NoSQL数据库</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201230155952.png" alt=""></p><ol><li>NoSQL 数据库的共性<ul><li>无模式: 与关系型数据库不同,NoSQL没有固定的模式(schema),这就为开发工作提供了很强的灵活性.(关系性数据库存储时必须事先定义’模式’,即要有哪些表格，表中有哪些列，每一列都存放何种类型的数据)</li><li>非关系型.</li><li>不支持SQL语言, 尤其不支持连接(join)操作.(都非关系了,怎么连接…)</li><li>分布式存储.(数据量大,一般采用分布式)</li><li>采用普通商用硬件,成本较低.</li><li>Linux操作系统(成本考虑,原生linux不要钱,啊这…)</li></ul></li><li>NoSql数据库的类型(根据数据模型划分)及其代表:<ul><li>基于键值对的 - (例如谷歌的levelDB,其存储结构分为<strong>内存</strong>部分和<strong>磁盘</strong>部分)</li><li>基于列存储的 - (谷歌的Bigtable)</li><li>基于文档的 - (10gen的mongoDB)</li><li>基于图的 - (neo科技公司的neo4j)</li><li>基于时间序列的 - (InfluxDB)</li></ul></li><li>与关系型数据库相比,谷歌的Bigtable有哪些优点?<ul><li>属于同一张Bigtable表的内容可以分布在不同节点上.<strong>表分布式</strong></li><li>属于同一个列族的列的数据类型是一样的<strong>列族下数据类型相同</strong></li><li>保证单行数据修改原子性,多行不保证.因此没有了支持连接(join)操作的负担,其拓展性更强.<strong>单行原子性</strong></li><li>Bigtable本质是一个<strong>分布式的、稀疏的、巨型的</strong>哈希表, 其键是一个三元组(行、列、时间),其值是内容.</li></ul></li></ol><h2 id="第十四章-NewSQL数据库">第十四章 - NewSQL数据库</h2><div class="note info flat"><p><a href="https://zhuanlan.zhihu.com/p/95650799">🔗SQL、NoSQL，NewSQL对比🔗</a></p></div><ol><li><p>ACID属性<br>ACID（Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久性）</p></li><li><p>NewSQL系统具有以下特点</p><ul><li>SQL作为和应用程序交互的主要方式</li><li>支持事务的 ACID 属性</li><li>使用非阻塞的并发锁(多为MVCC的变种), 这样读者不会与写着竞争</li><li>与传统的 RDBMS 相比,单节点的硬件配置要高很多(大内存,SSD硬盘)</li><li>水平扩展,无共享架构</li></ul></li><li><p>NewSQL怎么做到同时满足一致性和可用性?<br><em>资料: 在没有网络分区的情况下可以同时支持一致性和可用性</em><br>当网络分区发生时, 选择禁止或允许一些可能导致产生一致性问题的操作, 但是在分区结束后提供冲突解决手段(例如对刚刚恢复的节点进行同步,或者一开始就禁止操作)</p></li></ol><h2 id="第十五章-云化">第十五章 - 云化</h2><ol><li><p>云化的技术基础<br>云化的基础是<font color=red size=5>资源虚拟化</font>,如主机、网络、存储.<br>其中主机的虚拟化技术有两种: <u>虚拟机</u>技术,<u>容器</u>技术.</p></li><li><p>什么是云计算<br>通过连接运营商提供的云服务器等虚拟资源,在虚拟资源上完成计算得到结果.</p></li><li><p>云服务的服务类型<br>基础设施即服务(Iaas , Infrastructure as a Service)<br>平台即服务(Paas , Platform as a Service)<br>软件即服务(Saas , Software as a Service)<br>十多年前的玩意换个皮高大上而已…<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201225164359.png" alt=""></p></li><li><p>Google云计算关键技术<br>三大核心: <strong>GFS</strong>, <strong>MapReduce</strong>, <strong>BigTable</strong></p></li></ol><div class="note info flat"><p>GFS: 分布式文件系统<br>MapReduce: 并行计算的核心技术框架<br>BigTable: 分布式的、稀疏的、多维的、易扩展的、适用于海量数据的数据库</p></div><h2 id="第十六章-分布式系统的构建思想">第十六章 - 分布式系统的构建思想</h2><ol><li>避免单点故障的具体做法</li></ol><ul><li>文件系统故障<ul><li>采用有多副本支持的分布式文件系统, 如HDFS</li></ul></li><li>数据库故障<ul><li>利用数据库本身的复制机制, 实现主从复制</li><li>利用数据库中间件, 在中间层实现主从切换</li></ul></li><li>后台服务故障<ul><li>在多个节点部署相同服务,通过 Zookeeper 等实现服务节点切换</li><li>使用分布式服务调用框架</li></ul></li></ul><h2 id="参考资料-3">参考资料</h2><p>[^1]: <a href="https://www.w3schools.com/tags/ref_httpmethods.asp#:~:text=The%20difference%20between%20POST%20and,the%20same%20resource%20multiple%20times.">🔗HTTP Request Methods🔗</a><br>[^2]: <a href="https://zhuanlan.zhihu.com/p/130974371">🔗分布式一致性协议概述🔗</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行家算法 - 操作系统</title>
      <link href="/posts/59e4ca55/"/>
      <url>/posts/59e4ca55/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍-1">介绍[^1]</h2><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。<br>它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p><h2 id="背景-1">背景[^1]</h2><p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。<br>银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p><h2 id="算法">算法</h2><p>对于如图的资源分配表:<br>Allocation(已经分配出去的资源), MAX(最多需要多少资源), Available(空闲资源)<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213170622.png" alt="图"></p><p>首先计算出Need (Need = MAX - Allocation), 即<strong>还需要多少资源</strong>:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213171601.png" alt="Need"></p><p>然后加一个全为False的字段(FINISH, 表示当前进程是否满足, <strong>也可以不加,记着就行</strong>):<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213171815.png" alt="False"></p><p>接下来找到 Need 比 Available 小的(即空闲资源可以满足当前进程所需):<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213172528.png" alt="Find"></p><p>P2进程的需求能够得到满足, 所以现在满足它, P2已经完成了, 然后就要回收他的资源:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213172556.png" alt="Recycle"><br><font color=green><strong>注意加的是Allocation的值,即回收的是已经分配给该进程的那部分资源, 而不是进程所需要的(Need)</strong></font></p><p>P2回收完成, 标记Finish:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213172612.png" alt="Finish"></p><p>以此类推直到Finish全为True即为安全状态(进程完成的顺序即为<strong>安全序列</strong>):<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213172622.png" alt="True"></p><h2 id="参考资料-5">参考资料</h2><p>[^1]: <a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">WiKi: 银行家算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统期末复习习题</title>
      <link href="/posts/747adedd/"/>
      <url>/posts/747adedd/</url>
      
        <content type="html"><![CDATA[<h1>习题</h1><p>老师给的题库，ps是私货, 可看可不看…</p><h2 id="第一章-引论">第一章 - 引论</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213160322.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213160340.png" alt=""></p><h3 id="名词解释">名词解释</h3><ol><li><font color=green>操作系统</font>: 操作系统是管理和控制计算机系统内各种硬件和软件资源,有效地组织多道程序运行的系统软件（或程序集合）,是用户与计算机之间的接口。<br><font color=blue>管控软硬件,组织多道运行,人机接口</font></li><li><font color=green>管态</font>: <strong>执行操作系统程序时</strong>,处理机所处的状态.</li><li><font color=green>目态</font>: <strong>执行普通用户程序时</strong>,处理机所处的状态.</li><li><font color=green>多道程序设计</font>: 在该设计技术下, <strong>内存</strong>中能够<strong>同时存放多道程序</strong>, 在管理程序的控制下<strong>交替执行</strong>. 这些作业共享CPU和系统其他资源.<br><font color=blue>多道、交替、共享</font></li><li><font color=green>并发</font>: 是指两个或多个活动在<strong>同一给定的时间间隔</strong>中进行。它是宏观上的概念。<ul><li><em>ps: 非同时刻运行.</em></li></ul></li><li><font color=green>并行</font>: 是指两个或多个活动在<strong>同一时刻同时执行</strong>的情况。</li><li><font color=green>吞吐量</font>: 在一段给定的时间内，计算机所能完成的总工作量。</li><li><font color=green>分时</font>: 就是对时间的共享。在分时系统中，分时主要是指若干并发程序对CPU时间的共享。</li><li><font color=green>实时</font>: 表示“及时”或“既时”。<ul><li><em>ps: 不重要…</em></li></ul></li><li><font color=green>系统调用</font>: 是用户在程序中能以<strong>函数调用</strong>形式调用的、由操作系统提供的子功能的集合。每一个子功能称作一条系统调用命令。它是操作系统对外的接口，是用户级程序取得操作系统服务的唯一途径。<ul><li><em>ps: 系统提供功能让你间接控制计算机,而不是不通过调用直接控制,因为你可能搞崩系统.</em></li></ul></li><li><font color=green>特权指令</font>: 指令系统中的一些指令，如启动设备指令、设置时钟指令、中断屏蔽指令和清内存指令，这些指令<strong>只能由操作系统使用</strong>。<ul><li><em>ps: 只能由操作系统使用的指令叫特权指令, 这是操作系统的特权</em></li></ul></li><li><font color=green>命令解释程序</font>: 其主要功能是<strong>接收用户输入的命令</strong>，然后<strong>予以解释</strong>并且执行。<br><font color=blue>接收输入，解释执行</font></li><li><font color=green>脱机I/O</font>: 是指输入/输出工作不受主机直接控制，而由卫星机专门负责完成I/O，主机专门完成快速计算任务，从而二者可以并行操作。<br><img src='https://img.chen0495.top/Chen0495/newpicgo/img/20201210105314.jpg' style="width:200p;transform:rotate(270deg)"/></li><li><font color=green>联机I/O</font>: 是指作业的输入、调入内存及结果输出都在<strong>cpu直接控制</strong>下进行。</li><li><font color=green>资源共享</font>: 是指计算机系统中的<strong>资源被多个进程所占用</strong>。例如，多个进程同时占用内存，从而对内存共享；它们并发执行时对cpu进行共享；各个进程在执行过程中提出对文件的读写请求，从而对磁盘进行共享等等。</li></ol><h3 id="简答题">简答题</h3><ol><li><p><font color=green>Q: 什么是操作系统？它的主要功能是什么？</font><br><font color=red>A: 操作系统是控制和管理计算机系统内各种硬件和软件资源，有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。<br>操作系统的主要功能有5个方面，即<u>存储管理、处理机管理、设备管理、文件管理和用户接口。</u> </font><br><font color=blue>管控软硬件，组织多道，人机接口，四管理一接口</font></p></li><li><p><font color=green>Q: 推动操作系统形成和发展的主要动力是什么？</font><br><font color=red>A: 推动操作系统发展的因素很多，主要可归结为两大方面：硬件技术更新和应用需求扩大伴随计算机器件的更新换代和计算机体系结构的发展，<br>促使操作系统的性能和结构有了显著发展。 应用需求促进了计算机技术的发展，也促进了操作系统的不断更新升级。 </font><br><font color=blue>硬件发展+用户需求</font></p></li><li><p><font color=green>Q: 操作系统的基本特征是什么？</font><br><font color=red>A: 操作系统的基本特征是<strong>并发、共享和不确定</strong>。并发性是指两个或多个活动在同一给定的时间间隔中进行；共享是指计算机系统中的资源被多个进程所共用；不确定性是指系统中各种事件发生顺序的不可预测性。 </font></p></li><li><p><font color=green>Q: 多道程序和多重处理有何区别？</font><br><font color=red>A: 多道程序是作业之间自动调度执行、共享系统资源，并不是真正的同时执行多个作业；而多重处理系统配置多个cpu，能真正同时执行多道程序。<br>要有效使用多重处理，必须采用多道程序设计技术，而多道程序设计原则上不一定要求多重处理系统的支持。 </font></p><ul><li><em>ps:有没有多个cpu的区别,决定了能不能真正同时执行程序</em></li></ul></li><li><p><font color=green>Q: 试说明多道程序设计和多任务系统之间的关系</font><br><font color=red>A: 多道程序设计是利用外设与cpu能够并行处理的特性，在主存同时存放多个程序，使之在系统中交叉地使用cpu，从而提高系统资源的利用率。<br>而多任务系统主要指多进程交叉使用cpu。多道程序隐含了多任务处理，但多任务系统中不一定有多道程序。因为一个程序也可以采用多任务处理机制。 </font></p><ul><li><em>ps: 不如说多任务处理包含多道程序设计, 多道程序设计限制更多(主存存放,交叉使用), 而多任务则只着重强调计算机同时运行多个程序的能力. 可将多道看成一类特殊的多任务.</em></li></ul></li><li><p><font color=green>Q: 不同类型的操作系统提供不同的功能。假定有如下的应用环境，请你为它们选择适合的操作系统。<br>（1）飞机的导航，（2）办公自动化系统，（3）航空订票系统，（4）复杂的科学计算，（5）图书检索系统  </font><br><font color=red>（1）飞机的导航系统，应采用硬实时操作系统<br>（2）办公自动化系统，应采用分时操作系统<br>（3）航空订票系统，应采用软实时操作系统<br>（4）复杂的科学计算，应采用批处理系统<br>（5）图书检索系统，应采用软实时操作系统<br></font></p></li><li><p><font color=green>Q: 什么是分时系统，它有什么特征？</font><br><font color=red>A: 分时系统：把处理机的运行时间分成很短的时间片，按时间片轮转的方式，把处理机分配给各进程使用。其主要特征是：<u>交互性、多用户同时性、独立性。</u> </font><br><font color=blue>交互性，多用户同时性，独立性</font></p></li><li><p><font color=green>Q: 什么是实时系统？它有什么特征？</font><br><font color=red>A: 实时系统：在被控对象允许<strong>时间范围内</strong>做出响应 。其主要特征是：<u>对实时信息分析处理速度要比进入系统快、要求安全可靠、资源利用率低。</u> </font><br><font color=blue>速度快，资源少，安全可靠</font></p></li><li><p><font color=green>Q: 什么是批处理系统，它有什么特征？</font><br><font color=red>A: 批处理系统：操作员把用户提交的作业分类，把一批作业编成一个作业执行序列，由专门编制的监督程序自动依次处理。其主要特征是：<u>用户脱机使用计算机、成批处理、多道程序运行。</u></font><br><font color=blue>脱机，批处理，多道运行</font></p></li><li><p><font color=green>Q: 什么是处理机的核心态和用户态？为什么要设置这两种不同的状态？</font><br><font color=red>A: 当执行操作系统程序时，处理机处于核心态。它有较高的特权，可以执行所有的指令，包括一般用户程序中不能使用的特权指令，从而能对所有寄存器和内存进行访问，启动i/o操作等。<br>用户程序是在用户态下执行，它的权限较低，只能执行指令集中非特权指令。（2分）<br>设置这两种不同状态的目的是为了保护操作系统程序（特别是其内核部分），防止受到用户程序的损害。<br></font></p></li><li><p><font color=green>Q: 系统调用与过程调用在功能及实现上有什么相同点和不同点？</font><br><font color=red>A: 相同点：两者都由程序代码构成，可直接用高级程序设计语言（如C,C++和Perl语言）来编制；使用方式相同——以函数调用的形式出现，调用时传送参数。 </font><br><font color=red>不同点：①代码层次不同，过程调用不属于操作系统的一部分，而系统调用是操作系统的一部分。②运行状态不同。过程调用只能在用户态下运行，不能进入核心态，而系统调用是在核心态下运行的。③进入方式不同。过程调用在用户程序中调用，并直接在用户空间内执行；而系统调用可以在用户程序中调用，但是在用户程序中执行到系统调用时，会产生异常事件。实现处理机状态从用户态到核心态的转变，从而进入操作系统核心空间去执行系统调用的代码。 </font></p></li><li><p><font color=green>Q: 试说明特权指令和系统调用之间的区别与联系。</font><br><font color=red>A: 特权指令是一类只能在核心态下执行的机器指令。而系统调用不是机器指令，它往往以函数调用的形式出现，实现操作系统提供的子功能，它是操作系统与用户的编程接口 。在用户程序中可以使用系统调用来获得操作系统服务，在系统调用代码中可以使用特权指令</font></p></li></ol><h2 id="第二章-进程和线程">第二章 - 进程和线程</h2><h3 id="名词解释-2">名词解释</h3><ol><li><font color=green>顺序性</font> :是指顺序程序所规定的每个动作都在上个动作结束后才开始的特性。</li></ol><ul><li><em>ps: 即一个动作完成后下个动作才能开始</em></li></ul><ol start="2"><li><font color=green>封闭性</font> :是指只有程序本身的动作才能改变程序的运行环境.</li><li><font color=green>可再现性</font> :是指程序的执行结果与程序运行的速度无关。</li></ol><ul><li><em>ps: 程序在下次运行时一般不会改变结果</em></li></ul><ol start="4"><li><p><font color=green>进程</font> :程序在并发环境中的执行过程。</p></li><li><p><font color=green>互斥</font> :在逻辑上本来<strong>完全独立</strong>的进程，由于<strong>竞争</strong>同一个资源而产生的相互制约的关系。</p></li><li><p><font color=green>同步</font> :是指进程间共同完成一项任务时直接发生相互作用的关系。也就是说，这些具有伙伴关系的进程在执行次序上必须遵循确定的规律。</p><p>​- <em>ps: 多个可能不同的进程完成同一个任务, 这些进程相互制约, 如要进行B需要先完成A</em></p></li><li><p><font color=green>临界资源</font> :<strong>一次仅允许一个进程使用</strong>的资源。</p></li><li><p><font color=green>临界区</font> :<strong>在每个进程中访问临界资源的那段程序。</strong></p></li><li><p><font color=green>线程</font> :<strong>线程是进程中实施调度和分派的基本单位。</strong></p></li><li><p><font color=green>管程</font> :管程是一种<u>高级同步机制</u>，一个管程定义一个数据结构和能为并发进程在其上执行的一组操作，这组操作能使进程同步和改变管程中的数据。</p></li></ol><ul><li><em>ps: 可视为管理<u>进程同步</u>具体执行步骤的程序</em></li></ul><ol start="11"><li><font color=green>进程控制块</font> :进程控制块是进程存在的唯一标识，它保存了系统管理和控制进程所必须的信息，是进程动态特性的集中表现。</li></ol><ul><li><em>ps: 每个进程需要有个控制块来标记其地址、状态等信息</em></li></ul><ol start="12"><li><font color=green>原语</font> :指操作系统中实现一些具有特定功能的程序段，这些程序段的执行过程是<strong>不可分割</strong>的，即其执行过程<strong>不可中断</strong>。</li></ol><ul><li><em>ps: 某些语句被系统所定义, 相当于关键词/短语, 执行过程不可打断</em></li></ul><ol start="13"><li><font color=green>就绪态</font> :<strong>进程已经获得了除cpu之外的全部资源</strong>，等待系统分配cpu，一旦获得cpu，进程就可以变为运行态。</li></ol><ul><li><em>ps: 就差CPU啦!!!</em></li></ul><ol start="14"><li><p><font color=green>运行态</font> :**正在cpu上执行的进程所处的状态。**在单cpu系统中，任何时候最多只能有一个进程处于运行状态。</p></li><li><p><font color=green>阻塞态</font> :又称<u>等待态</u>，指<u>正在运行的进程因等待某个条件发生而不能运行时所处的状态。</u>处于阻塞态的进程在逻辑上是不能运行的，即使cpu空闲，它也不能占用cpu。</p><ul><li><em>ps: 某进程A正在运行, 但现在A需要B的结果来继续运行, 而B一时半会还轮不到运行, 为了效率, 此时应该中断A的运行, 直到B运行之后才继续A.</em></li></ul></li><li><p><font color=green>进程通信</font> :是指<strong>进程间的信息交换</strong>。</p></li><li><p><font color=green>同步机制</font> :同步机构是<u>负责处理进程之间制约关系</u>的机制，即操作系统中负责解决进程之间协调工作的同步关系（<strong>直接制约关系</strong>），以及共享临界资源的互斥关系（<strong>间接制约关系</strong>）的执行机构。</p><ul><li><em>ps: 不仅管理同步, 还管理互斥, 管程是一种同步机制的实现</em></li></ul></li></ol><h3 id="简答题-2">简答题</h3><ol><li><p><font color=red>Q: 在操作系统中为什么要引入进程概念？</font></p><p><font color=green>A: 由于多道程序并发执行时共享系统资源，共同决定这些资源的状态，因此系统中各程序在执行过程中就出现了相互制约的新关系，程序的执行出现“走走停停”的新状态。用程序这个静态的概念已不能如实反映程序并发执行过程中的这些特征。为此，人们引入了“进程（Process）”这一概念来描述程序动态执行过程的性质。 </font></p><p><font color=green>进程和程序是两个完全不同的概念。然而，进程与程序之间存在密切关系，进程的功能是通过程序的运行得以实现的，进程活动的主体是程序。进程不能脱离开具体程序而独立存在。 </font></p></li><li><p><font color=red>Q: 有人说，一个进程是由伪处理机执行的一个程序，这话对吗？为什么？</font></p><p><font color=green>A: 对。 </font></p><p><font color=green>因为伪处理机的概念只有在执行时才存在，它表示多个进程在单处理机上并发执行的一个调度单位。因此，尽管进程是动态概念，是程序的执行过程，但是，在多个进程并行执行时，仍然只有一个进程占据处理机执行，而其他并发进程则处于就绪或等待状态。这些并发进程就相当于由伪处理机执行的程序。</font></p></li><li><p><font color=red>Q: 试比较进程和程序的区别</font></p><p><font color=green>A: 1. 进程是一个动态的概念，而程序是一个静态的概念，程序是指令的有序集合，无执行含义，进程则强调执行的过程。 </font></p><p><font color=green>2. 进程具有并行特征（独立性、异步性），程序则没有。 </font></p><p><font color=green>3. 不同的进程可以包含同一个程序，同一程序在执行中也可以产生多个进程</font></p></li><li><p><font color=red>Q: 进程的基本状态有哪些？试描绘进程状态转换图</font></p><p><font color=green>A: 进程至少有三种基本状态：运行状态、就绪状态和阻塞状态（或等待状态） 。进程状态转换如下图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201231164747.jpg" alt=""></p></li><li><p><font color=red>Q: 并发进程间的制约有哪两种？引起制约的原因是什么？</font></p><p><font color=green>A: 并发进程所受的制约有两种：直接制约和间接制约。 </font></p><p><font color=green>直接制约是由并发进程相互共享对方的私有资源所引起的；间接制约是由竞争共有资源而引起的。</font></p></li><li><p><font color=red>Q: 什么是进程间的互斥？什么是进程间同步？</font></p><p><font color=green>A: 进程间的互斥是指：一组并发进程中的一个或多个程序段，因共享某一共有资源而导致它们必须以一个不许交叉执行的单位执行，即不允许两个以上的共享该资源的并发进程同时进入临界区。 </font></p><p><font color=green>进程间的同步是指：异步环境下的一组并发进程因直接制约相互发送消息而进行相互合作、相互等待，是各进程按一定的速度执行的过程。</font></p></li><li><p><font color=red>Q: 什么是临界区和临界资源？进程进入临界区的调度原则是什么？</font></p><p><font color=green>A: 临界资源——一次仅允许一个进程使用的资源</font></p><p><font color=green>临界区——在每个进程中访问临界资源的那段程序</font></p><p><font color=green>一个进程进入临界区的调度原则是：</font></p><p><font color=green>① 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入</font></p><p><font color=green>② 任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其他所有试图进入临界区的进程必须等待</font></p><p><font color=green>③ 进入临界区的进程要在有限的时间内退出，以便让其他进程能及时进入自己的临界区</font></p><p><font color=green>④ 如果进程不能进入自己的临界区，则应让出cpu，避免进程出现“忙等”现象.</font></p></li><li><p><font color=red>Q: 简述信号量的定义和作用。P，V操作原语是如何定义的？</font></p><p><font color=green>A: 信号量一般是由两个成员组成的数据结构，其中一个成员是整型变量，表示该信号量的值，它与相应资源的使用情况有关；另一个是指向PCB的指针。当多个进程都等待同一信号量时，它们就排成一个队列，由信号量的指针项指出该队列的队首。（2分）</font></p><p><font color=green>信号量通常可以简单反映出相应资源的使用情况，它与P、V操作原语一起使用可实现进程的同步和互斥。（1分）</font></p><p>P,V操作原语有如下定义:</p><p>P(S)顺序执行下述两个动作（1分）：</p><p>⑴信号量的值减1，即S=S-1;</p><p>⑵如果S&gt;=0,则该进程继续执行。</p><p>如果S&lt;0,则把该进程的状态置为阻塞态，把相应的PCB连入该信号量队列的末尾，并放弃处理机，进行等待（直到其他进程在S上执行V操作，把它释放出来为止）。</p><p>V(S)顺序执行下述两个动作（1分）：</p><p>⑴S值加1，即S=S+1;</p><p>⑵如果S&gt;0,则该进程继续运行；</p><p>如果S&lt;=0,则释放信号量队列上的第一个PCB所对应的进程（把阻塞态改为就绪态）,执行V操作的进程继续运行。</p></li><li><p><font color=red>Q: 什么是线程？它与进程有什么关系？</font></p><p><font color=green>A: 线程是进程中实施调度和分派的基本单位。 </font></p><p><font color=green>线程和进程之间有如下关系： </font></p><p><font color=green>① 一个进程至少有一个线程；而一个线程只能在一个进程的地址空间内活动。</font></p><p><font color=green>② 资源分配给进程，同一进程的所有线程共享该进程的所有资源。</font></p><p><font color=green>③ 处理机分给线程，即真正在处理机上运行的是线程。</font></p><p><font color=green>④ 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</font></p></li><li><p><font color=red>Q: 什么是管程？它由哪几部分组成？有什么基本特性?</font></p><p><font color=green>A: 一个管程定义了一个数据结构和能为并发进程在其上执行的一组操作，这组操作能同步进程和改变管程中的数据。 </font></p><p><font color=green>一个管程由四个部分组成，它们是管程名称、局部与管程的共享数据的说明、对数据进行操作的一组过程和对该共享数据赋初值的语句。 </font></p><p><font color=green>管程具有以下特性： </font></p><p><font color=green>① 管程内部的局部数据变量只能被管程内定义的过程所访问，不能被管程外面声明的过程直接访问</font></p><p><font color=green>② 进程要想进入管程，必须调用管程内的某个过程</font></p><p><font color=green>③ 一次只能有一个进程在管程内执行，而其余调用该管程的进程都被挂起，等待该管程成为可用的。就是说，管程自身能有效地实现互斥。</font></p></li></ol><h3 id="综合题">综合题</h3><p><font color="purple" size="6">伪代码缩进不好控制, 就这样吧…</font></p><ol><li><p><font color=red>Q: 如下图所示的工作模型中，有三个进程p0,p1,p2和三个缓冲区B0,B1,B2. 进程之间借助于相邻缓冲区进行消息传递：每个进程每次从缓冲区中取一条消息，经加工处理后送入另一个缓冲区中，三个缓冲区分别可存放3,2,2个消息。初始时，仅缓冲区0有一个消息。试用P、V操作写出三个进程之间的同步及互斥流程</font><br><font color=green>A: 这是一个生产者/消费者问题，而且每个进程既是生产者，也是消费者。(2’) 为此，应设置6个信号量：B0S1,B0S2,B1S1,B1S2,B2S1,B2S2,分别代表B0,B1,B2中是否有空缓冲和有数据。</font><br><font color=green>B0S1,B0S2,B1S1,B1S2,B2S2:semaphore;</font><br><font color=green>B0S1=2;B0S2=1;B1S1=2;B1S2=0;B2S1=2;B2S2=0;  (2’)</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Cobegin  (`6’=2’*3)  </span><br><span class="line">P0P1P2  </span><br><span class="line">beginbeginbegin  </span><br><span class="line">P(B0S2)P(B1S2)P(B2S2)  </span><br><span class="line">从B0取一个数据从B1取一个数据从B2取一个数据  </span><br><span class="line">V(B0S2)V(B1S1)V(B2S1)   </span><br><span class="line">加工   加工 加工  </span><br><span class="line">P(B1S1)P(B2S1)P(B0S1)  </span><br><span class="line">将加工结果送B1将加工结果送B2将加工结果送B0  </span><br><span class="line">V(B1S2)V(B2S2)V(B0S2)  </span><br><span class="line">endendend  </span><br><span class="line">coend  </span><br></pre></td></tr></table></figure><ul><li><em>ps: 缓存区依次为 3,2,2 且第一个(B0)已经有一个消息, 故缓冲区标记依次为 2,2,2 ;而对于数据标记, 只有B0有一个数据, 故为 1,0,0</em></li><li><em>ps: B_i为第i个缓冲区, S_1为缓冲区大小, S_2为数据个数</em></li></ul></li><li><p><font color=red>Q: 设用三个队列管理缓冲区池的使用情况，分别为空白缓冲队列em，输入缓冲队列in，以及输出缓冲队列out。过程add_buf(type,numb)和take_buf(type,numb)分别用来把缓冲区numb插入type队列和从type队列中取出缓冲区numb。试描述进程从任一缓冲队列中得到一个缓冲区的过程get_buf(type,numb)和释放一个缓冲区numb进入缓冲队列的过程put_buf(type,numb)。</font><br><font color=green>A: 假定用信号量s代表任一队列的可用缓冲区个数。假定三个队列的初值分别为n1,n2,n3。对任一队列的操作必须互斥。因此再引入一个互斥使用任一队列的信号量mutex，其初值为1。这里type代表队列的类型，它的取值为输入、输出和空白。</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  get_buf(type,numb)   (`3’)  </span><br><span class="line">begin  </span><br><span class="line">p(s)  </span><br><span class="line">p(mutex)  </span><br><span class="line">numb=take_buf(type,numb)  </span><br><span class="line">v(mutex)  </span><br><span class="line">end  </span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  put_buf(type,numb)   (`3’)  </span><br><span class="line">begin  </span><br><span class="line">p(mutex)  </span><br><span class="line">add_buf(type,numb)  </span><br><span class="line">v(mutex)  </span><br><span class="line">v(s)  </span><br><span class="line">  end</span><br></pre></td></tr></table></figure></li><li><p><font color=red>Q: 设有一个售票厅，可容纳100人购票。如果厅内不足100人则允许进入，进入后购票，购票后退出。如果厅内已有100人，则在厅外等候。试问：购票者之间是同步还是互斥？用P、V操作表达购票者的工作过程。</font><br><font color=green>A: 购票者之间是互斥关系。(2’). 一个售票厅可容纳100人购票，说明最多允许100个购票者共享售票厅；可引入一个信号量empty，其初值为100。由于购票者必须互斥地进行购票，故应再设一个mutex，其初值为1。(4’)</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> empty,mutex:semaphore;  </span><br><span class="line"> empty:=100; mutex:=1;  </span><br><span class="line"> begin  </span><br><span class="line">p(empty)  </span><br><span class="line">p(mutex)  </span><br><span class="line">进入厅内购票,购票后退出  </span><br><span class="line">v(empty)  </span><br><span class="line">v(mutex)  </span><br><span class="line"> end  </span><br></pre></td></tr></table></figure></li><li><p><font color=red>Q: 某招待所有100个床位，住宿者入住要先登记（在登记表上填写姓名和床位号）．离去时要注销登记（在登记表上删去姓名和床位号）．请给出住宿登记及注销过程的算法描述．</font><br><font color=green>A: 某招待所有100个床位，为了正确管理，引入一个信号量empty代表空床位数，初值为100；住宿者入住要先登记（在登记表上填写姓名和床位号），显然，登记表是一个临界资源，必须互斥访问，引入一个mutex，其初值为1。(4’)<br>住宿登记及注销过程的算法描述如下：(`3’)</font></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   //住宿登记：(`3’)  </span><br><span class="line">begin  </span><br><span class="line">p(empty)  //检查有无床位  </span><br><span class="line">p(mutex)  //申请登记   </span><br><span class="line">找出一个空床位将名字登入表中  </span><br><span class="line">v(mutex)  </span><br><span class="line">end  </span><br><span class="line">//注销过程：(`3’)  </span><br><span class="line">begin  </span><br><span class="line">p(mutex)   //申请退房  </span><br><span class="line">找出自己的登记项，并删除该项的登记   </span><br><span class="line">v(mutex)  </span><br><span class="line">v(empty)  </span><br><span class="line">  end.   </span><br></pre></td></tr></table></figure></li><li><p><font color=red>Q: 有一个阅览室，共有100个座位。为了很好地利用它，读者进入时必须先在登记表上进行登记。该表表目设有座位号和读者姓名；离开时再将其登记项擦除。<br>试问：为描述读者的动作，应编写几个程序，应设几个进程、它们之间的关系怎样？并请用P、V操作描述进程之间的同步算法。</font><br><font color=green>A: 为了描述阅览室，用一个登记表来记录其使用情况。表中共有100项。每当有读者进入阅览室时，为了正确地登记，各读者应互斥使用(1’)。为此设两个信号量：mutex为互斥信号量，用来制约各读者互斥地进行登记，其初值为1；empty为同步信号量，用来制约各读者能同时进入阅览室的数量，其初值为100  (2’)。<br>下面用两个过程描述对表格应执行的动作：</font></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   登记过程：(`2’)擦除过程：(`2’)  </span><br><span class="line">beginbegin  </span><br><span class="line">P(empty)    P(mutex)  </span><br><span class="line">P(mutex)找到自己的登记项擦除   </span><br><span class="line">找到一个登记项登记  V(mutex)  </span><br><span class="line">V(mutex)V(empty)  </span><br><span class="line">endend   </span><br></pre></td></tr></table></figure><p><font color=green>为了正确地描述读者的动作，可以将读者看成进程。若干读者希望进入阅览室时，调用登记过程，退出阅览室时，调用擦除过程(1’)。可见，一个程序可对应多个读者。可设的进程数由读者数决定，其动作如下：(`2’)</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> begin  </span><br><span class="line">调用登记过程  </span><br><span class="line">进入阅览室阅读  </span><br><span class="line">准备退出  </span><br><span class="line">调用擦除过程  </span><br><span class="line"> end  </span><br></pre></td></tr></table></figure></li><li><p><font color=red>Q: 一条河上架设了由若干个桥墩组成的一座桥。若一个桥墩只能站一个人，过河的人只能沿着桥向前走而不能向后退。过河时，只要对岸无人过，就可以过；但不允许河对岸的两个人同时过，以防止出现死锁。请给出两个方向的人顺利过河的同步算法。</font><br><font color=green>A: 假设一座桥由N个桥墩，也即最多允许有N个人同向过河，用一个计数器R记录同时过河的人数(2’)。用S1信号量保护计数器，其初值为1，R的初值为0；互斥使用桥的信号量用S表示，其初值为1。(2’)<br>同步算法描述如下：</font></p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   procedure goriver()  </span><br><span class="line">begin   </span><br><span class="line">       L:P(S1);//为同时过河,申请对计数器计数  </span><br><span class="line">          If R&gt;N begin V(S1); goto L; end  //同方向过河的人站满桥墩时,重新申请计数  </span><br><span class="line">          R=R+1;  </span><br><span class="line">          If R==1: P(S);//申请过河  </span><br><span class="line">       V(S1);  //释放计数器的使用权           (3’)  </span><br><span class="line">       占有一个桥墩,并顺序过河到对岸;  </span><br><span class="line">       P(S1);  </span><br><span class="line">          R=R-1;  </span><br><span class="line">          If R==0: V(S);//如果已经无同向的人过河,释放占用权  </span><br><span class="line">       V(S1);                                                       (3’)  </span><br><span class="line">  end   </span><br></pre></td></tr></table></figure></li><li><p><font color=red>Q: 在一个飞机订票系统中，多个用户共享一个数据库。各用户可以同时查询信息，若有一个用户要订票，须更新数据库时，其余所有用户都不可以访问数据库。请用P,V操作设计一个同步算法，实现用户查询与订票功能。要求：当一个用户订票而需要更新数据库时，不能因不断有查询者到来而使其长时间等待。利用信号量机制保证其正常执行。</font><br><font color=green>A: 这是典型的读者——写者问题，查询信息的用户是读者，订票用户是写者，并且要求写者优先。(2’)</font></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量说明：(`2’)</span><br><span class="line"> 计数变量</span><br><span class="line"> rc——正在运行的查询者进程数目，初值为0.</span><br><span class="line"> 信号量</span><br><span class="line"> Sw——控制订票者进程的活动，初值为1.</span><br><span class="line"> Src——互斥使用rc变量，初值为1.</span><br><span class="line"> S——当订票者到达时封锁后续的读进程，初值为1.</span><br><span class="line"> 读者进程 </span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/william_munch/article/details/84256690">🔗读写者问题🔗</a></p></li><li><p><font color=red>Q: </font><br><font color=green>A: </font></p></li><li><p><font color=red>Q: </font><br><font color=green>A: </font></p></li><li><p><font color=red>Q: </font><br><font color=green>A: </font></p></li><li><p><font color=red>Q: </font><br><font color=green>A: </font></p></li><li><p><font color=red>Q: </font><br><font color=green>A: </font></p></li><li><p><font color=red>Q: </font><br><font color=green>A: </font></p></li></ol><h2 id="第三章-死锁">第三章 - 死锁</h2><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213160202.png" alt=""></p><h3 id="名词解释-3">名词解释</h3><ol><li><p><font color=green>死锁: </font>是指在一个进程集合中的每个进程都在等待仅由该集合中的另一个进程才能引发的事件而无限期地僵持下去的局面。</p></li><li><p><font color=green>饥饿: </font>在系统中，每个资源占有者都在有限时间内释放它所占有的资源，但资源中存在某些申请者由于某种原因却永远得不到资源的一种错误现象。</p></li><li><p><font color=green>死锁防止: </font>要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。</p></li><li><p><font color=green>死锁避免: </font>对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性.</p><ul><li><em>ps: 死锁避免和死锁预防(防止)的区别在于,死锁预防是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁.死锁避免是在系统运行过程中注意避免死锁的最终发生.</em></li></ul></li><li><p><font color=green>安全序列: </font>针对当前分配状态来说，系统至少能够按照某种次序为每个进程分配资源（直至最大需求），并且使他们依次成功地运行完毕，这种进程序列{p1,p2,…,pn}就是安全序列。</p></li></ol><h3 id="简答题-3">简答题</h3><ol><li><font color=red>Q: 计算机系统中产生死锁的根本原因是什么?死锁发生的四个基本条件是什么？</font><br><font color=green>A: <strong>根本原因</strong>: <u>资源有限且操作不当.</u> <strong>死锁发生的四个基本条件</strong>: <u>互斥条件、请求保持条件（占有且等待条件）、非剥夺条件（不可抢占条件）和环路条件（循环等待条件）</u></font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213160637.png" alt=""></li><li><font color=red>Q: 简述发生死锁的四个必要条件?</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213161629.png" alt=""></li><li><font color=red>Q: 什么是死锁？解决死锁的方法一般有那几种?</font><br><font color=green>A: 死锁是指在一个进程集合中的每个进程都在等待仅由该集合中的另一个进程才能引发的事件而无限期地僵持下去的局面。</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213161940.png" alt=""></li><li><font color=red>Q: 死锁预防和死锁避免的基本思想是什么?</font><br><font color=green>A: <strong>死锁预防</strong>: 要求进程遵循某种协定, 从而打破死锁的四个必要条件中的一个或多个</font><br><font color=green>A: <strong>死锁避免</strong>: 对进程发出的每个资源申请加以动态的检查, 并根据检查结果决定是否分配</font></li><li>Q: 什么是死锁的安全序列?何谓系统是安全的？<br>A: 进程的安全序列{P1,P2,…,PN}是这样组成的：若对于每个进程Pi（1&lt;=I&lt;=n），它需要的附加资源可以被系统中当前可用资源加上所有进程Pj（j&lt;i）当前占有资源之和所满足，则{ P1,P2,…,PN }为一个安全序列。<br>“系统是安全的”是指系统中的所有进程能够按照某种次序分配资源，并且依次运行完毕。即系统中的进程处于安全序列中。</li></ol><ul><li><em>ps: 不重要,感觉不会考这么麻烦的题</em></li></ul><ol><li>Q: 资源按序分配法为什么能够预防死锁？<br>A: 证明：采用反证法来证明。<br>若存在循环等待，设在环路上的一组进程为{P0,P1,P2,…,Pn}，这里Pi等待进程Pi+1占有资源Ri（下角标取模运算，从而，Pn等待p0占有的资源）。由于Pi+1占有资源Ri,又申请资源Ri+1,从而一定存在F(i)&lt;F(i+1), 该式对所有的i都成立。于是就有：<br>F(R0)&lt;F(R1)&lt;…&lt;F(Rn)&lt;F(R0)<br>由传递性得到：<br>F(R0)&lt;F(R0)<br>显然，这是不可能的，因而，上述假设不成立，表明不会出现循环等待条件</li></ol><ul><li><em>ps: 不重要,感觉不会考这么麻烦的题,考了也能现编</em></li></ul><ol><li><font color=red>Q: 死锁和“饥饿”之间的主要差别是什么?</font><br><font color=green>A: <strong>死锁</strong>: 多个并发进程相互等待对方占用的资源而产生的错误现象。</font><br><font color=green><strong>饿死</strong>：在系统中，由于系统采用的资源分配算法不当，虽然每个资源占有者都在有限时间内释放它所占的资源，但仍然使一些进程永远得不到资源的一种错误现象。 </font><ul><li><em>ps: 死锁涉及的进程往往会相互有影响, 比如某个进程A需要等待进程B完成; 而饥饿涉及的进程则不一定, 其往往是优先级高的进程抢占了资源, 导致优先级低的进程无法获得资源</em></li></ul></li></ol><h3 id="综合题-2">综合题</h3><div class="note success flat"><p><a href="https://chen0495.top/posts/59e4ca55/">🔗银行家算法🔗</a></p></div>  <ol><li><p><font color=red>Q: 设系统中有三种类型的资源（A,B,C）和五个进程（P1,P2,P3,P4,P5）,A资源的数量为17，B资源的数量为5，C资源的数量为20。在T0时刻系统状态如表3-9所试。系统采用银行家算法来避免死锁。</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201213165422.png" alt=""><br><font color=red><br>①.T0时刻是否为安全状态？若试，请给出安全序列。<br>②.在T0时刻，若进程P2请求资源（0，3，4），能否实现资源分配？为什么？<br>③.在②的基础上，若进程P4请求资源（2，0，1），能否实现资源分配？为什么?<br>④.在③的基础上，若进程P1请求资源（0，2，0），能否实现资源分配？为什么?<br></font><br><font color=green>A:<br>①T0时刻是安全状态，因为存在一个安全序列{P4,P5,P1,P2,P3}  (2’)<br>②不能实现资源分配，因为所剩余的资源数量不够。  (2’)<br>③可以分配。当分配完成后，系统剩余的资源向量为（0，3，2），这时，仍可找到一个安全序列{P4,P5,P1,P2,P3}  (3’)<br>④不能分配。如果分配的话，则系统剩余的资源向量为（0，1，2），这时无法找到一个安全序列。(3’)<br></font></p></li><li><p><font color=red>Q: 在银行家算法中，系统有5个进程和3个资源。若出现以下资源分配情况</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214161645.png" alt=""></p><ol><li><font color=red>该状态是否安全(给出详细的检查过程)?</font></li><li><font color=red>如果进程依次有如下资源请求</font><br><font color=red>p1:资源请求Request(1,0,2)?<br>p4:资源请求Request(3,3,0)?<br>p0:资源请求Request(0,1,0)?<br>则系统如何进行资源分配，才能避免死锁？</font></li></ol><p><font color=green>A:  </font></p><ol><li><font color=green>该系统状态是否安全,主要看能否找到一个进程完成序列.若能找到,系统只要按照这个序列为进程分配资源,所有进程就都可顺利完成;若找不到,系统状态就是不安全的.为此,可先求出进程的剩余请求矩阵.  </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214162214.png" alt=""></li><li><font color=green>p1:资源请求Request(1,0,2)时，由1）可知，可以立即满足它，使得A=(2,2,0),P1的分配向量为(3,1,2)，其剩余向量变为(0,1,0).  (2’)  </font><br><font color=green>p4:资源请求Request(3,3,0)时，由于系统剩余资源向量A=(2,2,0)，显然不能满足它的请求，因为系统剩余资源向量A小于P4的请求  (2’)  </font><br><font color=green>p0:资源请求Request(0,1,0)时，由于系统剩余资源向量A=(2,2,0)，若满足它的请求，使得系统剩余资源向量A=(2,1,0)。之后，系统仍可以找到一个进程完成序列P1,P4,P0,P4,P2。故可以满足它的请求。  (2’)</font></li></ol></li><li><p><font color=red>Q: 送分题, 简单加减法, 不如不做</font><br><font color=green>A: …</font></p></li><li><p><font color=red>Q: 又是加减法</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214164740.png" alt=""><br><font color=green>A: 贴个答案</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214164808.png" alt=""></p></li><li><p><font color=red>Q: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214170356.png" alt=""><br><font color=green>A: 说到底银行家算法就不难</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214170623.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201214170640.png" alt=""></p></li></ol><h2 id="第四章-调度">第四章 - 调度</h2><h3 id="名词解释-4">名词解释</h3><ol><li><p><font color=green>作业</font>: 用户在一次上机过程中要求计算机系统所做工作的集合。</p></li><li><p><font color=green>周转时间</font>: 是指从作业<strong>进入</strong>系统开始，到作业<strong>退出</strong>系统所经历的时间。</p></li><li><p><font color=green>响应时间</font>: 是分时系统的一个技术指标，指从用户输入命令到系统对命令开始执行和显示所需要的时间。</p><ul><li><em>ps: 点执行按钮到真正执行有延迟, 该延迟即响应时间</em></li></ul></li><li><p><font color=green>作业调度</font>: 也称<font color=red>高级调度</font>, 作业调度的主要任务是完成作业从后备状态到执行状态和从执行状态到完成状态的转换。</p><ul><li><em>ps: 简单理解为作业运行状态的转变</em></li><li><strong>ps: 它决定把后备作业调入内存运行(或者调出).</strong></li></ul></li><li><p><font color=green>进程调度</font>: 也称<font color=red>低级调度</font>程序，它完成进程从<strong>就绪状态到运行状态</strong>的转化。实际上，进程调度完成一台物理的cpu转变成多台虚拟（或逻辑）的cpu的工作。</p><ul><li><em>ps: 相较于作业调度,它实现更加具体的任务</em></li><li><strong>ps: 它决定让就绪队列的某进程获得CPU.</strong></li><li><strong>ps: 只负责进程获得CPU, 不负责剥夺进程的资源(中级调度)</strong></li></ul></li><li><p><font color=green>交换调度</font>: 负责将主存中处于等待状态或就绪状态的某个或某些进程交换到外存交换区中，以便将外存交换区上具备运行条件的进程换入主存，准备执行。</p><ul><li><em>ps: 顾名思义, 负责进程在主存和辅存上的交换</em></li></ul></li><li><p><font color=green>剥夺式调度</font>: 当一个进程正在执行时，系统基于某种策略强行将处理机从占有者进程剥夺而分配给另一个进程的调度。这种调度方式系统开销大，但系统能及时响应请求。</p><ul><li><em>ps: 顾名思义, 将一个进程的资源强行剥夺给另一个进程</em></li></ul></li><li><p><font color=green>非剥夺式调度</font>: 系统一旦把处理机分配给某个进程之后，该进程一直运行下去，直到该进程完成或因等待某个事件发生时，才将处理机分配给其他进程。这种调度方式实现简单，系统开销小，但系统性能不够好。</p><ul><li><em>ps: 与剥夺式相反, 它会等待进程完成, 在这期间, 进程可以一直占用资源</em></li><li><em>ps: 这很不合理, 毕竟会造成严重的饥饿现象, 但确实是一种调度方式</em></li></ul></li></ol><h3 id="简答题-4">简答题</h3><ol><li><p><font color=red>Q: 作业由哪几部分组成？各有什么功能？</font><br><font color=green>A: <strong>程序、数据和作业说明书</strong>, 程序和数据完成用户所要求的业务处理工作，作业说明书则体现用户的控制意图。 </font></p></li><li><p><font color=red>Q: 试比较作业和进程的区别</font><br><font color=green>A: 一个进程是<u>一个程序对某个数据集的执行过程，是分配资源的单位</u>。作业是<u>用户需要计算机完成某项任务，而要求计算机所做工作的集合</u>。</font><br><font color=green>主要区别:</font></p><ol><li><font color=green>作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业之后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在内存中。</font></li><li><font color=green>一个作业可由多个进程组成。且必须至少由一个进城组成，但反过来不成立。</font></li><li><font color=green>作业的概念主要用在批处理系统中。像UNIX这样的分时系统中，则没有作业概念。则进程的概念则用在几乎所有的多道程序系统中。</font></li></ol></li><li><p><font color=red>Q: 高级调度与低级调度的主要功能是什么？为什么要引入中级调度？</font><br><font color=green>A: 高级调度的主要功能是根据一定的算法,从输入的一批作业中选出若干作业,分配必要的资源,如内存、外设等，为它建立相应的用户作业进程和为其服务的系统进程（如输入/输出进程），最后把它们的程序和数据调入内存，等待进程调度程序对其执行调度，并在作业完成后做善后处理工作。 低级调度的主要功能是根据一定的算法将cpu分派给就绪队列中的一个进程。</font><br><font color=green>为了使内存中同时存放的进程数目不至于太多，有时需要把某些进程从内存移到外存上，以减少多道程序的数目，为此设立了中级调度.</font></p></li><li><p><font color=red>Q: 处理机调度一般分为哪三级？其中哪一级调度必不可少？为什么？</font><br><font color=green>A: 处理机调度一般可分为高级调度（作业调度）、中级调度和低级调度（进程调度） 。其中进程调度必不可少 。</font><br><font color=green>进程只有在得到CPU之后才能真正活动起来，所有就绪进程经由进程调度才能获得CPU的控制权。实际上，进程调度完成一台物理的CPU转变成多台虚拟机（或逻辑）的CPU的工作，进程调度的实现策略往往决定了操作系统的类型，其算法优劣直接影响整个系统的性能。 </font></p><ul><li><em>ps: 类比一下, 高级语言(python)和低级语言(C/C++)哪个重要? 没了C/C++操作系统都不能跑, 没了python照样运行, 而在操作系统底层C/C++的执行效果更好</em></li></ul></li><li><p><font color=red>Q: 作业调度与进程调度之间有什么差别？二者间如何协调工作？</font><br><font color=green>A: 作业调度与进程调度之间的差别主要是：作业调度是宏观调度，它所选择的作业只是具有获得处理机的资格，但尚未占有处理机，不能立即在其上实际运行；而进程调度是微观调度，动态地把处理机实际地分配给所选择的进程，使之真正活动起来。另外，进程调度相当频繁，而作业调度执行的次数一般很少。<br>作业调度从外存的后背队列中选择一批作业调入内存，为它们创建进程，这些进程被送入就绪队列。进程调度从就绪队列中选出一个进程来，并把它的状态改为运行态，把cpu分配给它。当运行进程要等待某一事件时，就让出cpu，进入相应的阻塞队列，并进行进程调度。运行进程完成后，由作业调度进行善后处理工作。<br>个</font></p><ul><li><em>ps: 标准答案, 只要理解了两者各自的工作和联系, 怎么答都行, 毕竟主观题.</em></li></ul></li></ol><h3 id="综合题-3">综合题</h3><ol><li><p><font color=red>Q: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226162742.png" alt=""><br><font color=green>A: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226162814.png" alt=""></p></li><li><p><font color=red>Q: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226164739.png" alt=""><br><font color=green>A: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226164759.png" alt=""></p></li><li><p><font color=red>Q: 简单,略</font><br><font color=green>A: 略</font></p></li><li><p><font color=red>Q: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226165637.png" alt=""><br><font color=green>A: 见图</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226165652.png" alt=""></p></li></ol><h2 id="第五章-存储管理">第五章 - 存储管理</h2><p><font color="red" size="5">真长啊…</font></p><ol><li><p><font color="green">物理地址</font>: 内存中各存储单元的地址由<strong>统一的基地址</strong>顺序编址，这种地址称为物理地址。</p></li><li><p><font color="green">逻辑地址</font>: 用户程序经编译之后的每个目标模块都以<strong>0为基地址</strong>顺序编址，这种地址称为逻辑地址。</p><ul><li><em>ps: 类似各个编程语言, 真实地址和数组下标的关系</em></li></ul></li><li><p><font color="green">逻辑地址空间</font>: 由程序中逻辑地址组成的<strong>地址范围</strong>叫做逻辑地址空间。</p></li><li><p><font color="green">物理地址空间</font>: 由内存中的一系列存储单元所限定的<strong>地址范围</strong>称作内存空间。</p></li><li><p><font color="green">重定位</font>: 把<u>逻辑地址转变为内存物理地址的过程</u>叫做重定位。</p><ul><li><em>ps: 那把物理地址转变为逻辑地址叫什么?</em></li><li><strong>ps: 按照重定位的时机划分, 分为动态重定位和静态重定位</strong></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201216140619.png" alt=""></li></ul></li><li><p><font color="green">静态重定位</font>: 在目标程序装入内存时所进行的重定位。</p></li><li><p><font color="green">动态重定位</font>: 在程序执行期间，每次访问内存之前进行的重定位。</p></li><li><p><font color="green">可重定位地址</font>当含有它的程序被重定位时，将随之被调整的一种地址。</p><ul><li><em>ps: 重定位中需要改变的那部分地址</em></li></ul></li><li><p><font color="green">碎片</font>在<strong>分区法</strong>中，内存出现许多容量太小、无法被利用的小分区称作“碎片”。</p><ol><li><em>ps: 分区法将内存分为几个部分, 类似硬盘分区, 不过在内存中分的更细,分区更多.</em></li><li>机械硬盘中的碎片(红色):<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201216141750.png" alt="磁盘碎片"></li><li>在<strong>内存</strong>中, 这些碎片更小, 进入的程序往往会要求连续空间, 而碎片的大小不足以满足程序的空间大小, 故往往得不到利用.</li></ol></li><li><p><font color="green">内部碎片</font>: 在一个分区内部出现的碎片（即被浪费的空间）称作内部碎片。如固定分区法会产生内部碎片。</p></li><li><p><font color="green">外部碎片</font>: 在所有分区之外新产生的碎片称作外部碎片，如在动态分区法实施过程中出现的越来越多的小空闲块，由于它们太小，无法装入一个小进程，因而被浪费掉。</p></li><li><p><font color="green">紧缩</font>: 移动某些已分区的内容，使所有作业的分区紧挨在一起，而把空闲区留在另一端，这种技术称为紧缩。</p><ul><li><em>ps: 优化手段</em></li></ul></li><li><p><font color="green">固定分区法</font>: 内存中分区的个数固定不变，各个分区的大小也固定不变，但不同分区的大小可以不同，每个分区只可装入一道作业</p><ul><li><em>ps: 想象一张扇形图</em></li></ul></li><li><p><font color="green">动态分区法</font>各个分区是在相应作业要求进入内存时才建立的，使其大小恰好适应作业的大小。</p><ul><li><em>ps: 还是扇形图,但会随时间不断变化</em></li></ul></li><li><p><font color="green">可再入代码</font>也称纯代码，是指那些在其执行过程本身不做任何修改的代码，通常由指令和常数组成。</p><ul><li><em>ps: 没搞懂…</em></li></ul></li><li><p><font color="green">虚拟存储器</font>: 虚拟存储器是用户能作为可编程内存对待的虚拟存储空间，在这种计算机系统中实现了用户逻辑存储器与物理存储器的分离，它是操作系统给用户提供的一个比真实内存空间大得多的地址空间。</p><ul><li><em>ps: 就是Windows电脑常见的虚拟内存, 物理内存不够时, 在硬盘(辅存)开辟一块空间当内存用, 用来存放暂时用不到的内存资源</em></li></ul></li><li><p><font color="green">抖动</font>: 页面抖动是系统中频繁进行页面置换的现象。即如果一个进程没有一定数量的内存块，它很快就发生缺页。此时，它必须淘汰某页。由于所有这些页面都正在使用，所以刚被淘汰出去的页很快又被访问，因而要把它重新调入。可是调入不久又再被淘汰出去，这样再访问，再调入，如此反复，使得整个系统的页面替换非常频繁，以致大部分机器时间都用在来回进行的页面调度上，只有一小部分时间用于进程的实际运算方面。</p></li><li><p><font color="green">工作集</font>: 工作集是一个<strong>进程</strong>在某一小段时间内<strong>访问页面</strong>的集合。利用工作集模型可防止抖动，也可以进行页面置换。</p></li><li><p><font color="green">程序局部性原理</font>: 在相对短的一段时间内，进程集中在一组子程序或循环中之行，<u>导致所有的存储器访问局限于进程地址空间的一个固定子集</u>。这种现象就叫做程序局部性原理。</p></li><li><p><font color="green">快表</font>: 提高变换速度→用高速缓冲存储器存放常用的页表项.</p><ul><li><em>ps: 一般页表放在内存当中(慢表), 所以要取数据需要先在页表中找到数据地址, 再根据地址找到数据, 这样就访问了两次内存; 所以将一部分常用的页表放到高速缓存(Cache)当中, 以此加快访问速度.</em></li></ul></li><li><p><font color="green">交换</font>: 交换系统指系统根据需要把主存中暂时不运行的某个（或某些）作业部分或全部移到外存。而把外存中的某个（或某些）作业移到相应的主存区，并使其投入运行。</p></li><li><p><font color="green">换页</font>: 指系统根据某种策略选择某页出主存，将某页调入主存的过程。</p><ul><li><em>ps:分页大小固定, 分段由系统动态分配大小</em></li></ul></li><li><p><font color="green">实存</font>实存是指计算机配置的物理存储器，它直接向cpu提供程序和数据。</p><ul><li><em>ps: 物理内存</em></li></ul></li><li><p><font color="green">虚存</font>虚存是指系统向用户程序提供的编程空间，其大小由cpu的地址长度决定。</p><ul><li><em>ps: 虚拟内存</em></li></ul></li></ol><h3 id="简答题-5">简答题</h3><ol><li><p><font color=red>Q: 解释固定分区法和动态分区法的基本原理。</font><br><font color=green>A: 固定分区法——内存中分区的个数固定不变，各个分区的大小也固定不变，但不同分区的大小可以不同。每个分区只可装入一道作业。<br>动态分区法——各个分区是在相应作业要进入内存时才建立的，使其大小恰好适应作业的大小。<br></font></p></li><li><p><font color=red>Q: 说明内部碎片和外部碎片的不同之处</font><br><font color=green>A: 内存中出现的其容量太小、无法被利用的小分区称作碎片 。内部碎片和外部碎片出现的位置不同 。内部碎片出现在一个分区的内部（即被浪费的空间），如固定分区法会产生内部碎片 。外部碎片出现在所有分区之外，是新增的小分区，如在动态分区法实施过程中会出现外部碎片 。</font></p></li><li><p><font color=red>Q: 动态重定位分区管理方式中如何实现虚-实地址映射？</font><br><font color=green>A: 作业装入内存时，是将该用户的程序和数据原封不动地装入到内存中 。当调度该进程在cpu上执行时，操作系统就自动将该进程在内存的起始地址装入基址寄存器，将进程的大小装入限长寄存器 。当执行指令时，如果地址合法，则将相对地址与基址寄存器中的地址相加，所得结果就是真正要访问的内存地址；如果地址越界，则发出相应中断，进行处理 </font></p></li><li><p><font color=red>Q: 什么是虚拟存储器？它有哪些基本特征？</font><br><font color=green>A: 虚拟存储器是用户能作为可编址内存对待的虚拟存储空间,在这种计算机系统中实现了用户逻辑存储器与物理存储器的分离,它是操作系统给用户提供的一个比真实内存空间大得多的地址空间。 </font><br><font color=green>虚拟存储器的基本特征是:</font><br><font color=green>虚拟扩充——不是物理上,而是逻辑上扩充了内存容量;</font><br><font color=green>部分装入——每个作业不是全部一次性地装入内存,而是只装入一部分;</font><br><font color=green>离散分配——不必占用连续的内存空间,而是”见缝插针”;</font><br><font color=green>多次对换——所需的全部程序和数据要分成多次调入内存。</font></p><ul><li><em>ps: 就是虚拟内存</em></li></ul></li><li><p><font color=red>Q: 引入虚拟存储器后，除了获得主存“扩充”的好处，还有什么好处？</font><br><font color=green>A: 引入虚存后，程序的地址空间都是虚地址的集合，只有在程序运行中通过硬件地址转换机构和操作系统的相应软件，才能将虚地址变换成主存的实地址，这将为主存的分配带来更大的灵活性。另外，虚、实地址分开，用户程序不能干扰实地址的生成，从而实现了存储器的保护 。</font></p><ul><li><em>ps: 总结: 灵活、安全</em></li></ul></li><li><p><font color=red>Q: 什么是分页？什么是分段？二者有何主要区别？</font><br><font color=green>A: 分页是由系统将一个进程的逻辑地址空间划分成若干大小相等的部分，每一部分称做一个页面。 分段是用户根据作业的逻辑关系进行自然划分，每个分段是作业中相对独立的一部分。 </font></p><ul><li><em>ps: 分页大小固定, 分段则按照装入进程的大小动态分配空间</em></li><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201216154717.png" alt=""></li></ul></li><li><p><font color=red>Q: 在分页系统中页面大小由谁决定？页表的作用是什么？如何将逻辑地址转换成物理地址？</font><br><font color=green>A: 在分页系统中页面大小<u>由硬件决定</u>。 页表的作用是:<u>实现从页号到物理块号的地址映射</u>。 </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201221142919.png" alt=""></p></li><li><p><font color=red>Q: 什么是belady现象？</font><br><font color=green>A: belady现象是指在使用FIFO算法进行内存页面置换时 ，在未给进程或作业分配足它所要求的全部页面的情况下，有时出现的分配的页面数增多，缺页次数发而增加的奇怪现象。</font></p><ul><li><em>ps: 重点</em></li></ul></li><li><p><font color=red>Q: 请求分页技术的基本思想是什么？它与简单分页技术之间有何根本区别？</font><br><font color=green>A: 请求分页技术的基本思想是：当一个进程的部分页面在内存时就可调度它运行；在运行过程中若用到的页面尚未在内存，则把它们动态换入内存。这样，就减少了对换时间和所需内存数量，允许增加程序的道数。<br>请求分页技术是在简单分页技术基础上发展起来的，两者根本区别是：请求分页提供虚拟存储器，而简单分页系统并未提供虚拟存储器。<br></font></p><ul><li><em>ps: 某个进程只要有部分在内存中即可运行, 当要运行的部分不在内存中时, 临时将其置换入内存</em></li><li><strong>需要虚拟内存的支持</strong></li></ul></li><li><p><font color=red>Q: 为什么分段技术比分页技术更容易实现程序或数据的共享和保护？</font><br><font color=green>A: 每一段在逻辑上是相对完整的一组信息，分段技术中的共享是在段一级出现的。这样，任何共享的信息就可以单独成为一段。同样，段中所有内容可以用相同的方式进行使用，从而规定相同的保护权限。 然而，页是信息的物理单位，在一页中可能存在逻辑上互相独立的两组或多组信息，各有不同的使用方式和存取权限，因而，对分页难以进行共享和保护。 </font></p><ul><li><em>ps: 总的来说就是分段中某段属于同一个作业/进程, 只要整段保护/共享就行, 而分页式同一页可能有毫不相关的两个进程</em></li></ul></li><li><p><font color=red>Q: 何谓工作集？它有什么作用？</font><br><font color=green>A: 工作集是一个进程在某一小段时间内访问页面的集合。<br>利用工作集模型可防止抖动，也可以进行页面置换</font></p><ul><li><em>ps: 就是保存进程最近访问的页面在内存, 这样循环之类的一直调用同一资源的操作<u>不用一直把页面调进调出内存</u></em></li></ul></li><li><p><font color=red>Q: 什么是页面抖动？系统怎样检测是否出现抖动？一旦检测到抖动？系统如何消除它？</font><br><font color=green>A: 页面抖动是系统频繁进行页面置换的现象。整个系统的页面替换非常频繁，以致大部分机器时间都用在来回进行的页面调度上，只有一小部分时间用于进程的实际运算方面。<br>操作系统监督每个进程的工作集，并给它分配工作集所需的内存块。若有足够多的额外块，就可以装入并启动另外的进程。如果工作集增大了，超出可用块的总数，即系统中全部进程对内存块的总请求量大于可用内存块的总量，将出现抖动，因为某些进程得不到足够的内存块。<br>一旦检测到抖动，操作系统要选择一个进程让它挂起，把它的页面写出去，把它占用的内存块分给别的进程。被挂起的进程将在以后适当时机重新开始执行。<br></font></p></li></ol><h3 id="综合题-4">综合题</h3><div class="note info flat"><p>有效访问时间计算:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227170556.jpg" alt=""></p></div><ol><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226190624.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226190551.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226194005.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226194020.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226194227.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226194238.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226195457.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201226195512.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227132457.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227132514.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227132823.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227132834.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227155028.png" alt=""><br><font color=green>A: 分页需要访问2次，第一次访问页表，第二次执行访内操作(2’)；分段需要访问2次，第一次访问段表，第二次执行访内操作；段页式需要访问3次，第一次访问段表，第二次访问页表，第三次执行访内操作(2’)。</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227170549.jpg" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227160252.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227160313.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227160846.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227160910.png" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227171814.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227171740.jpg" alt=""></p></li><li><p><font color=red>Q: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227171840.png" alt=""><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201227172145.png" alt=""></p></li></ol><h2 id="第六章-文件系统">第六章 - 文件系统</h2><h3 id="名词解释-5">名词解释</h3><ol><li><p><font color="green">逻辑记录</font>: 用户构造文件时使用的一个信息单位。通常以逻辑记录为单位存取文件。</p></li><li><p><font color="green">物理记录</font>: 文件存储器上组织信息的一个单位。它是文件存储器识别信息的单位。</p></li><li><p><font color="green">文件</font>: 是命名的相关信息的集合体，它通常存放在外存（如磁盘、磁带）上，可以作为一个独立单位存放并实施相应的操作（如打开、关闭、读、写等）。</p></li><li><p><font color="green">文件系统</font>: 操作系统中负责<u>操纵和管理文件</u>的一整套设施，它实现文件的<u>共享和保护</u>，方便用户“按名存取”。</p></li><li><p><font color="green">目录项</font>: 为了加快对文件的检索，把<strong>文件控制块集中在一起进行管理</strong>。这种文件控制块的有序集合称为文件目录。当然，文件控制块也是其中的目录项。</p></li><li><p><font color="green">目录文件</font>: <u>全由目录项构成的文件</u>称为目录文件</p></li><li><p><font color="green">路径</font>: 在树形目录结构中，从根目录出发经由所需子目录到达指定文件的通路。</p></li><li><p><font color="green">当前目录</font>: 为节省文件检索的时间，每个用户可以指定一个目录作为当前工作目录，以后访问文件时，就从这个目录开始向下顺序检索。这个目录就称作当前目录。</p></li><li><p><font color="green">文件的逻辑组织</font>: 用户对文件的观察和使用是从自身处理文件数据时所采用的组织方式来看待文件组织形式。这种从用户观点出发所见到的文件组织形式称为文件的逻辑组织。</p></li><li><p><font color="green">文件的物理组织</font>: 文件在存储设备上的存储组织形式称为文件的物理组织</p><ul><li><em>ps: 分别从用户和实际角度看待文件的组织来区分</em></li></ul></li><li><p><font color="green">文件控制块</font>: 用于<strong>描述和控制文件</strong>的数据结构，其中包括<u>文件名、文件类型、位置、大小</u>等信息。文件控制块与文件一一对应，即在文件系统内部，给每个文件唯一地设置一个文件控制块，核心利用这种结构对文件实施各种管理。</p></li><li><p><font color="green">存取权限</font>: 用户或系统为文件规定的谁能访问，以及如何访问的方式</p></li></ol><h3 id="简答题-6">简答题</h3><ol><li><p><font color=red>Q: 什么是文件、文件系统？文件系统有哪些功能？</font><br><font color=green>A: 在计算机系统中，文件被解释为<u>一组赋名的相关字符流的集合</u>，或者是<strong>相关记录的集合</strong>。<br>文件系统是<u>操作系统中与管理文件有关的软件和数据</u>。<br>文件系统的功能是为用户<u>建立文件，撤销、读写修改和复制文件</u>，以及完成对文件的<u>按名存取和进行存取控制</u>。<br></font></p></li><li><p><font color=red>Q: 文件系统一般按什么分类？可以分为那几类</font><br><font color=green>A: <strong>性质，用途，组织形式，文件中的信息流向或文件的保护级别.</strong><br>按文件的性质与用途可以分为系统文件，库文件和用户文件。按文件的组织形式可以分为普通文件，目录文件和特殊文件。按文件中的信息流向可以分为输入文件，输出文件和输入/输出文件。按文件的保护级别可以分为只读文件，读写文件，可执行文件和不保护文件。<br></font></p></li><li><p><font color=red>Q: 什么是文件的逻辑结构，什么是记录？</font><br><font color=green>A: <strong>逻辑结构就是用户可见的结构</strong>, 可分为字符流式的无结构文件和记录式的有结构文件两大类.<br><strong>记录是一个具有特定意义的信息单位</strong>, 由该记录在文件中的逻辑地址（相对位置）与记录名所对应的一组关键字，属性及其属性值所组成.<br></font></p></li><li><p><font color=red>Q: 什么是文件目录？文件目录中包含那些信息？</font><br><font color=green>A: 文件目录是<u>一个文件的文件名</u>和<u>对该文件实施控制管理的说明信息</u>.<br>其包含: <u>文件名、文件名相对应的文件内部标识以及文件信息在文件存储设备上第一个物理块的地址等信息。另外还可能包含关于文件逻辑结构、物理结构、存取控制和管理等信息。</u><br></font></p></li><li><p><font color=red>Q: 文件系统中目录结构主要有哪几种？分别说明各自的实现思想？</font><br><font color=green>A: 文件系统中的目录结构主要有：<strong>单级</strong>目录结构，<strong>二级</strong>目录结构，<strong>树形</strong>目录结构和<strong>非循环图</strong>目录结构。 </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201228142003.png" alt=""></p></li><li><p><font color=red>Q: 什么是文件控制块?它与文件有何关系？</font><br><font color=green>A: 一种用于<strong>描述和控制文件的数据结构</strong>，其中包括<u>文件名、文件类型、位置、大小等信息</u>。<br>文件控制块与文件一一对应，即在文件系统内部，给每个文件唯一地设置一个文件控制块，核心利用这种结构对文件实施各种管理。<br></font></p></li><li><p><font color=red>Q: 文件系统中的目录结构有哪几种基本形式？各有何优缺点？</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201228143611.png" alt=""></p></li><li><p><font color=red>Q: 常用的磁盘空闲区管理技术有哪几种？试简要说明各自的实现思想。</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201228144636.png" alt=""></p></li><li><p><font color=red>Q: 什么是文件共享？文件链接如何实现文件共享？</font><br><font color=green>A: 文件链接是给文件起别名，即将该文件的目录项登记在链接目录中。这样，访问该文件的路径就不只一条。不同的用户（进程）就可以利用各自的路径来共享同一文件。</font></p></li><li><p><font color=red>Q: 什么是文件后备？数据转储方法有哪两种？按时间划分，后备分哪几种？</font><br><font color=green>A: 文件的后备就是把硬盘上的文件转储到其他外部介质上。<br>将磁盘上的数据转储到磁带上有两种方式：物理转储和逻辑转储。物理转储是从磁盘上第0块开始，把所有的盘块按照顺序写到磁带上，当复制完最后一块时，转储结束。逻辑转储方式是从一个或多个指定的目录开始，递归地转储自某个日期以来被修改过的所有文件和目录。<br>通常有以下三种备份策略：<strong>完全备份</strong>、<strong>增量备份</strong>和<strong>更新备份</strong>。<br>完全备份也称简单备份，即每隔一定时间就对系统作一次全面的备份；增量备份使每隔一段较短的时间进行一次备份，但仅仅备份在这段时间间隔内修改过的数据；更新备份是备份从上次进行完全备份后至今更改的全部数据文件。<br></font></p></li><li><p><font color=red>Q: 文件系统的一般格式是怎样的？其中引导块和超级块的作用各是什么？</font><br><font color=green>A: 文件系统的一般由<u>引导块、超级块、空闲空间管理、I节点、根目录、文件数据区</u>组成.<br>引导块的作用是引导操作系统。它包括一个小程序，用于读入该分区上相应操作系统的引导部分，从而把该分区中的操作系统装入内存。<br>超级块的作用是对整个文件系统进行控制和管理。它包含有关文件系统的全部关键参数。当计算机加电进行引导或第一次遇到该文件系统时，就把超级块中的信息读入内存。超级块中包含标识文件系统类型的幻数、文件系统中的盘块数量、修改标记及其他关键管理方面的信息。<br></font></p></li></ol><h2 id="第七章-设备管理">第七章 - 设备管理</h2><h3 id="名词解释-6">名词解释</h3><ol><li><p><font color="green">输入井</font>: 是指为使设备与cpu速度相匹配，系统在磁盘上设置的多个缓冲区，以实现设备与cpu之间的数据交换。输入井主要用来存放由输入设备输入的信息。</p></li><li><p><font color="green">缓冲池</font>: 又叫公共缓冲区，也是系统在磁盘上设置的多个缓冲区。它既可以用于输入，也可以用于输出，较好地克服了专用缓冲区的缺点。一方面提高了缓冲区的利用率，另一方面也提高了设备与cpu的并行操作程度。</p></li><li><p><font color="green">虚拟设备</font>: 它是利用共享设备上的一部分空间来模拟独占设备的一种I/O技术。</p></li><li><p><font color="green">存储设备</font>: 它们是指计算机用来存储信息的设备，如此盘（硬盘和软盘）、磁带等。</p></li><li><p><font color="green">输入输出设备</font>: 是计算机用来接收来自外部世界信息的设备，或者将计算机加工处理好的信息送向外部世界的设备。例如键盘、打印机、卡片输入机。</p></li><li><p><font color="green">设备的无关性</font>: 也称设备独立性，就是说，用户程序应与实际使用的物理设备无关，由操作系统来考虑因实际设备不同而需要使用不同的设备驱动程序等问题。</p></li><li><p><font color="green">通道</font>: 为使CPU摆脱繁忙的I/O事务，现代大、中型计算机都设置了<strong>专门处理I/O操作</strong>的机构，这就是通道。</p></li><li><p><font color="green">RAID</font>: 称作廉价磁盘冗余阵列，即利用一台磁盘阵列控制器来统一管理和控制一组磁盘驱动器（几台到几十台），组成一个高可靠性、快速大容量的磁盘系统。采用该技术可以获取更高的可靠性和更快的数据传输速率，而不是价格上更便宜。</p></li></ol><h3 id="简答题-7">简答题</h3><ol><li><p><font color=red>Q: 为什么要引入缓冲技术？设置缓冲区的原则是什么？</font><br><font color=green>A:</font></p><ol><li><font color=green>缓和CPU与I/O设备间速度不匹配的矛盾。</font></li><li><font color=green>提高它们之间的并行性。</font></li><li><font color=green>减少对CPU的中断次数，放宽CPU对中断响应时间的要求。</font></li></ol></li><li><p><font color=red>Q: 操作系统中设备管理的功能是什么？</font><br><font color=green>A:  </font></p><ol><li><font color=green>监视设备状态 </font></li><li><font color=green>进行设备分配 </font></li><li><font color=green>完成I/O操作 </font></li><li><font color=green>缓冲管理与地址转换 </font></li></ol></li><li><p><font color=red>Q: 什么是缓冲？为什么要引入缓冲？</font><br><font color=green>A: <strong>特指内存中的缓冲</strong>缓冲即是使用专用硬件缓冲器或在内存中划出一个区域用来暂时存放输入输出数据的器件。<br>引入缓冲是为了匹配外设和cpu之间的处理速度，减少中断次数和cpu的中断处理时间，同时解决dma或通道方式时的数据传输瓶颈问题。<br></font></p></li><li><p><font color=red>Q: I/O设备通常可分为哪两大类？各自传输的信息单位有什么特点？</font><br><font color=green>A:<br><strong>字符设备</strong>和<strong>块设备</strong><br>字符设备通常以<strong>独占方式</strong>分配，信息的<u>传输单位是字符或字节</u>。块设备通常采用<strong>共享方式</strong>分配，信息的<u>传输是以块为单位</u>进行传输的。<br></font></p></li><li><p><font color=red>Q: 什么是I/O控制？,I/O操作的四种控制方式是什么？</font><br><font color=green>A: I/O 控制是指☞从用户进程的 输入/输出 请求开始, 给用户进程分配设备和启动有关设备进行 I/O 操作, 并在 I/O 操作完成后响应中端, 直到善后处理为止的整个系统控制进程.</font><br><font color=green>四种控制方式:</font><br><font color=blue><strong>其区别主要在于CPU对I/O控制的干预程度</strong></font></p><ul><li><font color=green><strong>程序直接控制</strong>, CPU必须周期地检查设备直到 I/O 完毕.</font></li><li><font color=green><strong>中断 I/O 控制</strong>, 当设备准备好时, 向CPU发出中断信号.(数据需要经过CPU寄存器)</font></li><li><font color=green><strong>DMA 控制</strong>, 将读写操作时, CPU把任务委托给DMA部件, 由DMA完成I/O.(直接由DMA写入/读取内存, 不经过CPU寄存器)</font></li><li><font color=green><strong>I/O 通道控制</strong>, 通道与CPU共享内存, CPU将任务派给通道, 由通道在内存中完成I/O</font></li></ul></li><li><p><font color=red>Q: I/O控制可用那几种方式实现，各有什么优缺点？</font><br><font color=green>A: I/O控制过程可用三种方式实现：作为请求I/O操作的进程实现；作为当前进程的一部分实现；由专门的系统进程——I/O进程完成。<br>第一种方式请求对应I/O操作的进程能很快占据处理机，但要求系统和I/O操作的进程具有良好的实时性。第二种方式不要求系统具有高的实时性，但I/O控制过程要由当前进程负责。第三种方式增加了一个额外的进程开销，但用户不用关心I/O控制过程<br></font></p></li><li><p><font color=red>Q: 设备分配技术主要有哪些？常用的设备分配算法是什么？</font><br><font color=green>A: 设备分配技术主要有：<strong>独占分配</strong>、<strong>共享分配</strong>和<strong>虚拟分配</strong>。<br>常用的设备分配算法是：<strong>先来先服务</strong>算法和优先级高的<strong>优先服务</strong>算法<br></font></p></li><li><p><font color=red>Q: 实现SPOOLing系统的硬件前提是什么？SPOOLing系统的主要功能是什么？</font><br><font color=green>A: 要提供大容量的磁盘，要有中断和通道装置<br>其主要功能即是：提高I/O速度, 将独占设备改造为共享设备, 实现虚拟设备 。<br></font></p></li><li><p><font color=red>Q: 简述处理I/O请求的主要步骤。</font><br><font color=green>A: (主要是中断I/O)<br>①用户进程发出I/O请求.<br>②系统接受请求, 转去执行其他核心程序.<br>③设备驱动程序具体实现I/O操作.<br>④I/O完成后, 发出中断信号, 系统进行中断处理, I/O完成.<br></font></p></li><li><p><font color=red>Q: 设备驱动程序主要执行什么功能？</font><br><font color=green>A: 设备驱动进程严格执行设备驱动程序中规定的各种功能 ，即接受用户的I/O请求 ；取出请求队列中队首的请求，将相应的设备分配给它 ；启动该设备工作，完成指定的I/O操作 ；处理来自设备的中断 </font></p></li><li><p><font color=red>Q: I/O软件的设计目标？它是如何划分层次的？各层的功能是什么？</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201228200900.png" alt=""></p></li><li><p><font color=red>Q: 什么叫寻道？访问磁盘时间由哪几部分组成?其中哪一个是磁盘调度的主要目标？为什么？</font><br><font color=green>A: <strong>把磁头从当前位置移到相应的磁道上或柱面上</strong>，这个操作过程叫做寻道。<br>访问磁盘时间: <strong>寻道时间、旋转延迟时间和传输时间</strong><br>寻道时间是磁盘调度的主要目标。<br>传输时间是硬件设计时就固定的，寻道时间和旋转延迟时间与信息在磁盘上的位置有关。因为磁头臂是机械移动，所以对大多数磁盘来说，寻道时间远大于旋转延迟时间与传输时间之和，它是影响磁盘调度的主要因素。<br></font></p></li><li><p><font color=red>Q: 什么是RAID？采用RAID技术的优点是什么？</font><br><font color=green>A: RAID称作廉价磁盘冗余阵列，即利用一台磁盘阵列控制起来统一管理和控制一组磁盘驱动器（几台到几十台），组成一个高可靠性、快速大容量的磁盘系统。 采用RAID技术可以获取更高的可靠性和更快的数据传输速率，而不是价格上更便宜</font></p></li></ol><h3 id="综合题-5">综合题</h3><div class="note info flat"><p><font color=blue size=4>磁盘调度算法<font><br>磁盘: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229135452.png" alt=""><br>一个磁盘访问队列:<code>98,183,37,122,14,124,65,67</code>.</p><ol><li>FIFO/FCFS(先来先服务,First In First OUT/First Come First Served): 根据进程请求的时间顺序依次调度.<u>假设当前磁道在某一位置，依次处理服务队列里的每一个磁道</u>，这样做的优点是处理起来比较简单，但缺点是磁头移动的距离和平均移动距离会很大。<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229141037.png" alt=""></li></ul></li><li>SSTF(最短寻道时间,Shortest Seek Time First): 利用贪心算法,假设当前磁道在某一位置，接下来<u>处理的是距离当前磁道最近的磁道号，处理完成之后再处理离这个磁道号最近的磁道号</u>，直到所有的磁道号都服务完了程序结束。这样做的优点是性能会优于FIFO算法，但是会产生距离当前磁道较远的磁道号长期得不到服务，也就是“饥饿”现象，因为要求访问的服务的序列号是动态产生的，即各个应用程序可能不断地提出访问不同的磁道号的请求(插队)。<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229141450.png" alt=""></li></ul></li><li>SCAN(扫描scan,也叫电梯调度算法): 对于扫描算法，磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时，处理请求。当到达磁盘的另一端时，磁头移动方向反转，并继续处理。磁头连续来回扫描磁盘。SCAN 算法有时称为电梯算法，因为磁头的行为就像大楼里面的电梯，先处理所有向上的请求，然后再处理相反方向的请求。<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229141513.png" alt=""></li></ul></li><li>C-SCAN(循环扫描算法,Circular SCAN): 我们观察电梯算法,假设请求柱面的分布是均匀的，考虑当磁头移到磁盘一端并且反转方向时的请求密度。这时，紧靠磁头前方的请求相对较少，因为最近处理过这些柱面。磁盘另一端的请求密度却是最多。这些请求的等待时间也最长，那么为什么不先去那里？<br>像 SCAN 一样，C-SCAN 移动磁头从磁盘一端到磁盘另一端，并且处理行程上的请求。然而，当磁头到达另一端时，它立即返回到磁盘的开头，而并不处理任何回程上的请求.<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229141521.png" alt=""></li></ul></li><li><em>FS-CAN(分布电梯调度): 在SCAN算法的基础上, 算法思想是，<u>在扫描的过程中所有新产生的序列放在另外的一个队列中，当访问完当前队列之后，再访问新产生的一个队列</u>。这种算法可以有效防止磁壁粘着现象。</em></li><li>Look调度: 正如以上所述，SCAN 和 C-SCAN 在磁盘的整个宽度内移动磁臂。实际上，这两种算法通常都不是按这种方式实施的。更常见的是，磁臂只需移到一个方向的最远请求为止。<br>遵循这种模式的 SCAN 算法和 C-SCAN 算法分别称为 LOOK 和 C-LOOK 调度，因为它们在向特定方向移动时查看是否会有请求.<ul><li><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229141529.png" alt=""></li></ul></li></ol></div><ol><li><p><font color=red>Q: 假定一个硬盘有100个柱面，每个柱面有10个磁道，每个磁道有15个扇区。当进程要访问磁盘的12345扇区时，计算磁盘的三维物理扇区号</font><br><font color=green>A: 每个柱面的扇区数为：10*15=150  (3’)<br>12345/150=82余45,故12345扇区所在的柱面为82  (3’)<br>再将45/15，其商为3，余数为0，(3’)<br>故求得12345扇区所在的磁盘地址为：82柱面，3磁道，0扇区。(1’)<br></font></p></li><li><p><font color=red>Q: 假设移动头磁盘有200个磁道（0-199号）。目前正在处理143号磁道上的请求，而刚刚处理结束的请求是125号，如果下面给出的顺序是按FIFO排成的等待服务队列顺序：86，147，91，177，94，150，102，75，130   那么，下列各种磁盘调度算法来满足这些请求所需的总磁头移动量是多少？<br>1）FCFS,   2)SSTF</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229160655.png" alt=""></p></li><li><p><font color=red>Q: 假设移动头磁盘有200个磁道（0-199号）。目前正在处理143号磁道上的请求，而刚刚处理结束的请求是125号，如果下面给出的顺序是按FIFO排成的等待服务队列顺序：86，147，91，177，94，150，102，75，130   那么，下列各种磁盘调度算法来满足这些请求所需的总磁头移动量是多少？<br>1)SCAN,   2)C-LOOK</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229160745.png" alt=""></p></li><li><p><font color=red>Q: 假设一个磁盘由200个磁道，编号从0~199。当前磁头正在143道上服务，并且刚刚完成了125道的请求。如果寻道请求队列的顺序是：86，147，91，177，94，150，102，175，130 问：为完成上述请求，下列算法各自磁头移动的总量是多少？<br>①FCFS       ②SSTF    </font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229160851.png" alt=""></p></li><li><p><font color=red>Q: 假设一个磁盘由200个磁道，编号从0~199。当前磁头正在143道上服务，并且刚刚完成了125道的请求。如果寻道请求队列的顺序是：86，147，91，177，94，150，102，175，130 问：为完成上述请求，下列算法各自磁头移动的总量是多少？<br>① SCAN       ② C-SCAN</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229160905.png" alt=""></p></li><li><p><font color=red>Q: 磁盘请求以10，22，20，2，40，6，38柱面的次序到达磁盘驱动器。寻道时每个柱面移动需要6ms，计算以下寻道次序和寻道时间：<br>①先到先服务        ②电梯调度算法（起始移动向上）<br>所有情况下磁臂的起始位置都是柱面20。</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229161124.png" alt=""></p></li><li><p><font color=red>Q: 某系统文件存储空间共有80个柱面，20磁道/柱面，6块/磁道，每块有1K字节。用位示图表示。每张位示图为64个字，其中有4个包含的是控制信息。位示图中的位若为1，表示占用；为0表示空闲。试给出分配和回收一个盘块的计算公式。</font><br><font color=green>A: </font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20201229161152.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析(PCA)详解</title>
      <link href="/posts/3ecfb80c/"/>
      <url>/posts/3ecfb80c/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-5">前言</h2><p>学习深度学习,教材是人民邮电出版的《DEEP LEARNING 深度学习》,讲的太细节了,数学符号完全不知道什么意思,非数学系的我看着头痛,只好翻翻博客,最后选择这篇进行学习: <a href="https://blog.csdn.net/zhongkelee/article/details/44064401">主成分分析（PCA）原理详解</a><br>记录下学习过程…</p><h2 id="PCA简介">PCA简介</h2><h3 id="介绍">介绍</h3><p>深度学习的数据往往是多维度的,但不是每个维度都能对最后结果产生影响,试想有下面一组数据:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916185518.jpg" alt="图"><br>若假设各个科目成绩不会相互影响,我们很容易看出语文列的数据相同,也就是说即使我们去掉该列也不会影响最后的结果.那么数学、物理、化学这三门课的成绩构成了这组数据的主成分.<br>再看一组数据:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916185951.jpg" alt="图"><br>显然不容易找出其主成分.数据太多了，以至于看起来有些凌乱！也就是说，无法直接看出这组数据的主成分，因为在坐标系下这组数据分布的很散乱。究其原因，是因为无法拨开遮住肉眼的迷雾~如果把这些数据在相应的空间中表示出来，也许你就能换一个观察角度找出主成分。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916190158.jpg" alt="图"><br>而对于更高维度人脑无法想象的数据应该如何分析?</p><h3 id="数据降维">数据降维</h3><p>假设我们有一个三维的数据,但其数据点均分布在三维立体空间的一个二维平面上,那么这组数据是否能够仅使用二维坐标表示?<br>答案是肯定的,而这个过程的本质是: 这个三维数据的秩是2,即最大有两个线性无关变量.<br>如果这个二维平面不过原点呢?那就把它平移到过原点,然后记录下该改变方便还原.</p><p><strong>PCA的思想是将n维特征映射到k维上（k&lt;n），这k维是全新的正交特征。这k维特征称为主成分，是重新构造出来的k维特征，而不是简单地从n维特征中去除其余n-k维特征。</strong></p><h2 id="PCA实例">PCA实例</h2><p>假设一组数据:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916192820.jpg" alt="图"><br>行代表样例,列代表特征,每个样例两个特征分别是x、y;</p><ol><li><p>分别求x和y的平均值,然后对于所有的样例,都减去对应的均值.这里x的均值是1.81,y的均值是1.91,那么第1个样例减去均值后即为（0.69,0.49）,得到:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916193311.jpg" alt="图"></p></li><li><p>求特征协方差矩阵,如果数据是3维,那么协方差矩阵是:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916194324.jpg" alt="图"><br>这里只有x&amp;y,求解得:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916195159.jpg" alt="图"><br>对角线上分别是x和y的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。协方差是没有单位的量，因此，如果同样的两个变量所采用的量纲发生变化，它们的协方差也会产生树枝上的变化。</p><ul><li>协方差矩阵的计算及概念如下:<a href="%5B%E5%A6%82%E4%BD%95%E7%9B%B4%E8%A7%82%E5%9C%B0%E7%90%86%E8%A7%A3%E3%80%8C%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E3%80%8D%EF%BC%9F%5D(https://zhuanlan.zhihu.com/p/37609917)">^1</a><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916194845.png" alt="图1"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916194852.png" alt="图2"><br>关于求方差除以n-1而不是n的解释:<br>如果除以n,那么样本方差总比总体方差的值偏小,所以除n-1.<a href="%5B%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%A0%B7%E6%9C%AC%E6%96%B9%E5%B7%AE%E4%B8%BA%E4%BD%95%E9%99%A4%E4%BB%A5n-1%5D(https://blog.csdn.net/Hearthougan/article/details/77859173)">^2</a></li></ul></li><li><p>求协方差的特征值和特征向量:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916200721.jpg" alt="图"><br>上面是两个特征值，下面是对应的特征向量，特征值0.0490833989对应特征向量为，这里的特征向量都归一化为单位向量。</p></li><li><p>将特征值按照从大到小的顺序排序,选择其中最大的k个,然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵.<br>这里特征值只有两个，我们选择其中最大的那个，这里是1.28402771，对应的特征向量是(-0.677873399, -0.735178656)T。</p></li><li><p>把样本点投影到选定的特征向量上.假设样例数为m，特征数为n，减去均值后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为:<br>FinalData(10*1) = DataAdjust(10*2矩阵) x 特征向量(-0.677873399, -0.735178656)T<br>其结果是:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916201919.jpg" alt="图"><br>这样,n维数据就变成了k维,这k维就是原始特征在k维上的投影<br>上面的数据可以认为是x&amp;y融合成一个新的特征,其基本上代表了两个特征.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200916202124.png" alt="图"><br>正号表示预处理后的样本点，斜着的两条线就分别是正交的特征向量（由于协方差矩阵是对称的，因此其特征向量正交），最后一步的矩阵乘法就是将原始样本点分别往特征向量对应的轴上做投影。</p></li></ol><h2 id="Python代码实现PCA">Python代码实现PCA</h2><p><font color=green size=4>待补</font></p><h2 id="参考资料-2">参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> PCA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> PCA </tag>
            
            <tag> 主成分分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Python]对于yield关键字的理解</title>
      <link href="/posts/1129d15c/"/>
      <url>/posts/1129d15c/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-4">前言</h2><p>一直对python中的yield关建字的作用一知半解,很多博客根本是照着官网翻译的… 知道看到这篇文章 <a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">🔗python中yield的用法详解🔗</a> 才理解了其涵义,特此记录.</p><h2 id="正文-4">正文</h2><h3 id="yield与return及生成器">yield与return及生成器</h3><p>首先, yield是一个 “return”, 其次带有yield的函数是一个迭代器;<br>如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo() <span class="comment">#因为yield存在,函数并未真正执行,即未输出任何字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">starting...</span><br><span class="line">4</span><br><span class="line">********************</span><br><span class="line">res: None</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><font color=green size=3>解释</font>:</p><blockquote><p>程序开始执行后,因为函数中存在yield关键字所以并不会真正执行,而是得到一个生成器g.</p><p>调用next方法,foo函数开始执行.</p><blockquote><p>执行时遇到yield关建字,将其看成’return 4’,return后程序停止, <font color=red size=3>res并没有被赋值</font>,next(g)执行完成,结果即前两句.</p></blockquote><p>程序执行print(“*”*20)，输出20个*</p><p>再次调用next方法,<font color=red size=3>程序从上次执行的中断处继续执行</font></p><blockquote><p>从上次中断处执行(即res的赋值操作),<font color=puple size=3>时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数）</font> ,所以这个时候res赋值是None,所以接着下面的输出就是res:None.</p></blockquote><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p></blockquote><h3 id="生成器中的send-函数">生成器中的send()函数</h3><p>通过send方法来将一个值”发送“给生成器。other = yield foo 这样的语句的意思是，&quot;返回foo的值，这个值返回给调用者的同时，将other的值也设置为那个值.</p><p>再看代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(g.send(<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">starting...</span><br><span class="line">4</span><br><span class="line">********************</span><br><span class="line">res: 7</span><br><span class="line">4</span><br></pre></td></tr></table></figure><ol><li><p>同上…</p></li><li><p>程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量</p></li><li><p>由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环</p></li><li><p>程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。</p></li></ol><h2 id="参考资料">参考资料</h2><p><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">🔗python中yield的用法详解——最简单，最清晰的解释🔗</a><br><a href="https://www.cnblogs.com/nymrli/p/9416949.html">🔗Python生成器及send用法讲解🔗</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[树+dfs]Add and Search Word - Data structure design</title>
      <link href="/posts/f4634336/"/>
      <url>/posts/f4634336/</url>
      
        <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>Design a data structure that supports the following two operations:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(word)</span>  </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(word)</span>  </span></span><br></pre></td></tr></table></figure><p>search(word) can search a literal word or a regular expression string containing only letters <strong>a-z</strong> or <strong>.</strong>. A <strong>.</strong> means it can represent any one letter.</p><p><strong>Example</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addWord</span>(<span class="string">&quot;bad&quot;</span>)</span><br><span class="line"><span class="built_in">addWord</span>(<span class="string">&quot;dad&quot;</span>)</span><br><span class="line"><span class="built_in">addWord</span>(<span class="string">&quot;mad&quot;</span>)</span><br><span class="line"><span class="built_in">search</span>(<span class="string">&quot;pad&quot;</span>) -&gt; <span class="function"><span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">&quot;bad&quot;</span>)</span> -&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">&quot;.ad&quot;</span>)</span> -&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">&quot;b..&quot;</span>)</span> -&gt; <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p><strong>Note</strong>:<br>You may assume that all words are consist of lowercase letters <strong>a-z</strong>.</p><p><strong>Python3</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds a word into the data structure.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordDictionary()</span></span><br><span class="line"><span class="comment"># obj.addWord(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>题意:<br>完成<strong>WordDictionary</strong>类,<strong>addWord</strong>方法向词库中添加词,<strong>search</strong>方法用来搜索词,其中 ‘.’ 表示该位置可匹配任意字符. 所有单词只包含小写字母.</p><p>思路:<br>创建一颗树,在单词结尾节点进行标记以判断是否单词,遇到 ‘.’ 则对当前节点的所有子节点进行匹配.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200812165345.png" alt=""></p><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections <span class="keyword">as</span> cl</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.Children=cl.defaultdict(Node)</span><br><span class="line">        self.isWord=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root=Node()</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addWord</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            node =node.Children[i]</span><br><span class="line">        node.isWord=<span class="literal">True</span> <span class="comment">#对单词结尾标记</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Adds a word into the data structure.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        node = self.root</span><br><span class="line">        self.res=<span class="literal">False</span></span><br><span class="line">        self.dfs(node,word)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self,node,word</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">if</span> node.isWord:</span><br><span class="line">                self.res = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> word[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> node.Children.values():</span><br><span class="line">                self.dfs(j,word[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            node = node.Children.get(word[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.dfs(node,word[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordDictionary()</span></span><br><span class="line"><span class="comment"># obj.addWord(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> dfs </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转载]collections.defaultdict()的使用</title>
      <link href="/posts/a1580455/"/>
      <url>/posts/a1580455/</url>
      
        <content type="html"><![CDATA[<h2 id="正文-3">正文</h2><p><a href="https://blog.csdn.net/yangsong95/article/details/82319675">🔗原文链接:@yangsong95🔗</a></p><p>Python中通过Key访问字典，当Key不存在时，会引发‘KeyError’异常。为了避免这种情况的发生，可以使用collections类中的defaultdict()方法来为字典提供默认值。</p><p>语法格式：<br>collections.defaultdict([default_factory[, …]])</p><p>该函数返回一个类似字典的对象。defaultdict是Python内建字典类（dict）的一个子类，它重写了方法_missing_(key)，增加了一个可写的实例变量default_factory,实例变量default_factory被missing()方法使用，如果该变量存在，则用以初始化构造器，如果没有，则为None。其它的功能和dict一样。</p><p>第一个参数为default_factory属性提供初始值，默认为None；其余参数包括关键字参数（keyword arguments）的用法，和dict构造器用法一样。</p><p>1、使用list作第一个参数，可以很容易将键-值对序列转换为列表字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s=[(<span class="string">&#x27;yellow&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">d=defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].append(v)</span><br><span class="line">a=<span class="built_in">sorted</span>(d.items())</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200812173832.png" alt="图源水印"></p><p>当字典中没有的键第一次出现时，default_factory自动为其返回一个空列表，list.append()会将值添加进新列表；再次遇到相同的键时，list.append()将其它值再添加进该列表。</p><p>这种方法比使用dict.setdefault()更为便捷，dict.setdefault()也可以实现相同的功能。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [(<span class="string">&#x27;yellow&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">d=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d.setdefault(k,[]).append(v)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,d)</span><br><span class="line">a=<span class="built_in">sorted</span>(d.items())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,a)</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200812173828.png" alt="图"></p><p>2、defaultdict还可以被用来计数，将default_factory设为int即可。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s = <span class="string">&#x27;mississippi&#x27;</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line">    d[k] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,d)</span><br><span class="line">a=<span class="built_in">sorted</span>(d.items())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,a)</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200812173829.png" alt="图"></p><p>字符串中的字母第一次出现时，字典中没有该字母，default_factory函数调用int()为其提供一个默认值0,加法操作将计算出每个字母出现的次数。</p><p>函数int()是常值函数的一种特例，总是返回0。使用匿名函数（lambda function）可以更快、更灵活的创建常值函数，返回包括0在内的任意常数值。<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constant_factory</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: value</span><br><span class="line">d = defaultdict(constant_factory(<span class="string">&#x27;&lt;missing&gt;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,d)</span><br><span class="line">d.update(name=<span class="string">&#x27;John&#x27;</span>, action=<span class="string">&#x27;ran&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;%(name)s %(action)s to %(object)s&#x27;</span> % d)</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200812173831.png" alt=""></p><p>3、default_factory设为set时，可以用defaultdict建立集合字典（a dictionary of sets）。<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">s = [(<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">4</span>)]</span><br><span class="line">d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].add(v)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,d)</span><br><span class="line">a=<span class="built_in">sorted</span>(d.items())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>,a)</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200812173830.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSU19-ACM搜索专题题解</title>
      <link href="/posts/a1e49d79/"/>
      <url>/posts/a1e49d79/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-3">前言</h2><p><a href="https://vjudge.net/contest/387326">🔗Vjudge题集链接(组员可进)🔗</a><br>很多讲的不是很清楚或者没理解的建议拿着纸笔🖊照着代码演算一遍,这样对代码思想和算法原理的理解有很大帮助,然后一些<br>常用的模板(bfs,素数表)是要背下来的(理解了更好).<br>另,C++比C方便很多,而且C有的C++也有,C没有的C++也有,建议使用C++作为算法学习主要语言…</p><h2 id="知识预备">知识预备</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2#cite_note-ItoA-1">🔗【中文wiki】深度优先搜索(需要特殊上网手段)🔗</a><br><a href="https://blog.csdn.net/raphealguo/article/details/7560918">🔗【算法入门】深度优先搜索(DFS)🔗</a><br><a href="https://www.cnblogs.com/lshedward/p/10480342.html">🔗算法图解之广度优先算法BFS🔗</a><br><a href="https://blog.csdn.net/raphealguo/article/details/7523411">🔗【算法入门】广度/宽度优先搜索(BFS)🔗</a><br><a href="http://a.newday.me/"><s>🔗谷歌访问助手,远离百度,从我做起🔗</s></a></p><h2 id="正文-2">正文</h2><h3 id="A：Dungeon-Master-poj-2251">A：Dungeon Master (poj-2251)</h3><p>题意:<br>三维迷宫,给定出口和入口,要求输出最短路径长度.</p><p>思路:<br>bfs求解,只需要在二维的基础上加一维(上下两个方向)即可.</p><p>知识点:<br><a href="https://blog.csdn.net/g11d111/article/details/76169861">🔗 bfs 🔗</a><br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> m[<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">31</span>][<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="type">int</span> L,R,C;</span><br><span class="line"><span class="type">int</span> start_x=<span class="number">0</span>,start_y=<span class="number">0</span>,start_z=<span class="number">0</span>,end_x=<span class="number">0</span>,end_y=<span class="number">0</span>,end_z=<span class="number">0</span>;<span class="comment">//起终点坐标</span></span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]= &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//上下东南西北</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;<span class="comment">//坐标</span></span><br><span class="line">    <span class="type">int</span> step;<span class="comment">//步数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node&gt; S;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> st;</span><br><span class="line">    st.step=<span class="number">0</span>;</span><br><span class="line">    st.x=start_x;</span><br><span class="line">    st.y=start_y;</span><br><span class="line">    st.z=start_z;</span><br><span class="line">    S.<span class="built_in">push</span>(st);</span><br><span class="line">    v[st.x][st.y][st.z]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">node</span> tmp=S.<span class="built_in">front</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tmp.x==end_x&amp;&amp;tmp.y==end_y&amp;&amp;tmp.z==end_z)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Escaped in &quot;</span>&lt;&lt;tmp.step&lt;&lt;<span class="string">&quot; minute(s).&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">node</span> tmp2;</span><br><span class="line">        <span class="built_in">up</span>(<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp2.x=tmp.x+dir[i][<span class="number">0</span>];</span><br><span class="line">            tmp2.y=tmp.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            tmp2.z=tmp.z+dir[i][<span class="number">2</span>];</span><br><span class="line">            tmp2.step=tmp.step+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp2.x&lt;<span class="number">0</span>||tmp2.x&gt;=L||tmp2.y&lt;<span class="number">0</span>||tmp2.y&gt;=R||tmp2.z&lt;<span class="number">0</span>||tmp2.z&gt;=C)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m[tmp2.x][tmp2.y][tmp2.z]==<span class="string">&#x27;#&#x27;</span>||v[tmp2.x][tmp2.y][tmp2.z])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v[tmp2.x][tmp2.y][tmp2.z]=<span class="literal">true</span>;</span><br><span class="line">                S.<span class="built_in">push</span>(tmp2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Trapped!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(NULL);</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;L&gt;&gt;R&gt;&gt;C)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(L||R||C))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="literal">false</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="built_in">up</span>(L)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;R; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;C; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;m[i][j][k];</span><br><span class="line">                <span class="keyword">if</span>(m[i][j][k]==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                    start_x=i,start_y=j,start_z=k;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(m[i][j][k]==<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                    end_x=i,end_y=j,end_z=k;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="B：Catch-That-Cow-poj-3278">B：Catch That Cow (poj-3278)</h3><p>题意:<br>给定牛🐂和人在直线上的坐标,人可以沿着直线左右移动一个单位,或者传送到2*X的位置(设X是人的坐标),耗费时间都是1mins.求人抓到牛🐂的时间.</p><p>思路:<br>看到题的瞬间就想到了动态规划,然而这是搜索专题,就都讲下吧.</p><p>动态规划: <img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200806101538.png" alt="我是图"><br>动态规划思想见知识点链接,这里直接上思路.给出一个数组dp,dp[i]表示从起点到i的时间(或者直接说步数),给0到牛坐标初始化一个数值为i到起点坐标的绝对值(即起点到i的最长步数).<br>考虑直线上任意一点p:</p><ul><li>p点本身</li><li>p+1点的最优+1</li><li>p-1点的最优+1</li><li>p/2点的最优+1(p为偶数)</li></ul><p>对于奇数,考虑前3个.p+1的最优只能是dp[i+1]，<em>此时还没有发生变化</em>,和dp[(i+1)/2]+1,简单理解就是偶数数尽量使用传送,我自己推导的时候遇到了数学难题,能力不够无法证明,所以这里就当贪心算法了,我记得我学长给我讲的时候就说的是贪心.<br>又由于dp[i+1]=dp[i]+1，所以不再考虑dp[i+1]。同时，也不考虑dp[p/2]+1.<br>对于偶数多考虑一个dp[p/2]+1.</p><p><font color=green size=4>BFS</font>:<br>套模板:</p><ol><li>初始化,标记初始点已访问并将初始点入队列</li><li>循环<ol><li>标记此处,已经遍历过</li><li>判断是否退出,是则return</li><li>操作当前数</li><li>判断越界和是否已经遍历过</li><li>push</li></ol></li><li>return</li></ol><p>知识点:<a href="https://blog.csdn.net/ailaojie/article/details/83014821">🔗动态规划🔗</a><br>贪心: 我觉得、我认为,找规律就vans了.</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">100007</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(NULL);</span></span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">up</span>(k+<span class="number">1</span>)&#123; <span class="comment">//初始化</span></span><br><span class="line">        dp[i]=<span class="built_in">abs</span>(n-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],dp[(i+<span class="number">1</span>)/<span class="number">2</span>]+<span class="number">2</span>);</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],dp[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],dp[i/<span class="number">2</span>]+<span class="number">1</span>);</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],dp[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[(i+<span class="number">1</span>)/<span class="number">2</span>]+<span class="number">2</span>,dp[i]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=k;i++)cout&lt;&lt;dp[i]&lt;&lt;endl;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;dp[k]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上扒的bfs:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span>  pos;</span><br><span class="line">    <span class="type">int</span>  ct;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> p,<span class="type">int</span> ctt):<span class="built_in">pos</span>(p),<span class="built_in">ct</span>(ctt)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> view[<span class="number">100000</span>+<span class="number">5</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    queue &lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">node</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> p=u.pos;</span><br><span class="line">        view[p]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;<span class="number">100000</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==k)&#123;</span><br><span class="line">            <span class="keyword">return</span> u.ct;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;<span class="number">100001</span>&amp;&amp;!view[p+<span class="number">1</span>])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">node</span>(p+<span class="number">1</span>,u.ct+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;<span class="number">0</span>&amp;&amp;!view[p<span class="number">-1</span>])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">node</span>(p<span class="number">-1</span>,u.ct+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;<span class="number">50001</span>&amp;&amp;!view[p*<span class="number">2</span>])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">2</span>*p,u.ct+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;N,&amp;K);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">bfs</span>(N,K));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C：Find-The-Multiple-poj-1426">C：Find The Multiple (poj-1426)</h3><p>题意:<br>给个数n,找到一个只由0|1组成的并且可以被n整除的数</p><p>思路:<br><a href="https://www.cnblogs.com/WGD943/p/12229633.html">🔗广搜bfs🔗</a><br><a href="https://www.pianshen.com/article/9499313762/">🔗深搜dfs🔗</a></p><p>代码:<br>见思路链接</p><h3 id="D：Prime-Path-poj-3126">D：Prime Path (poj-3126)</h3><p>题意:<br>给出n和m两个4位的素数,现在变换n的任何一位数字,但变换后依旧要是素数,要求从n变到m的最少步数</p><p>思路:<br>如果是最大步数直接打素数表遍历就好,但既然是最少…<br>打出素数表后,通过改变操作数的每一位进行bfs;</p><ol><li>打素数表(套模板)</li><li>初始化</li><li>标记初始点并入队列</li><li>循环<ol><li>判断是否到达终点,是则return</li><li>切割各个位</li><li>对各个位分别改变并判断是否满足条件(素数),满足入队列push</li></ol></li><li>return</li></ol><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10007</span>;</span><br><span class="line"><span class="type">int</span> pri[maxn],a[maxn],vis[maxn];</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getp</span><span class="params">()</span><span class="comment">//素数表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[tot++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i; j&lt;=maxn; j+=i)</span><br><span class="line">                vis[j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;tot; i++) <span class="comment">//取出4位数的素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">1000</span>&amp;&amp;a[i]&lt;<span class="number">10000</span>)</span><br><span class="line">            pri[p++]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dif</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//判断数是否差一位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp1=l%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> tmp2=r%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp1!=tmp2)</span><br><span class="line">            sum++;</span><br><span class="line">        l/=<span class="number">10</span>;</span><br><span class="line">        r/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span><span class="comment">//模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node&gt; Q;</span><br><span class="line">    <span class="comment">//Q.push(&#123;n,0&#125;);</span></span><br><span class="line">    <span class="comment">//VJ的编译器不允许这样写...</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> t;</span><br><span class="line">    t.step=<span class="number">0</span>;</span><br><span class="line">    t.val=n;</span><br><span class="line">    Q.<span class="built_in">push</span>(t);</span><br><span class="line"></span><br><span class="line">    vis[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">node</span> tmp=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tmp.val==m)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;tmp.step&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">up</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[pri[i]]&amp;&amp;<span class="built_in">dif</span>(pri[i],tmp.val))</span><br><span class="line">            &#123;</span><br><span class="line">                vis[pri[i]]=<span class="number">1</span>;</span><br><span class="line">               <span class="comment">// Q.push(&#123;pri[i],tmp.step+1&#125;);</span></span><br><span class="line">               t.val=pri[i];</span><br><span class="line">               t.step=tmp.step+<span class="number">1</span>;</span><br><span class="line">               Q.<span class="built_in">push</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">getp</span>();</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));<span class="comment">//vis曾用于标记素数表,故需要初始化</span></span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="E：迷宫问题-poj-3984">E：迷宫问题 (poj-3984)</h3><p>题意:<br>二维迷宫找最短路径(输出路线)</p><p>思路:<br>在迷宫问题最短路径的基础上记录下路径即可:<a href="https://blog.csdn.net/huanghanqian/article/details/51506732">🔗外部链接🔗</a><br>代码: 见思路<a href="https://blog.csdn.net/huanghanqian/article/details/51506732">🔗外部链接🔗</a></p><h3 id="F：Oil-Deposits-poj-1241">F：Oil Deposits (poj-1241)</h3><p>题意:<br>二维字符数组’@‘表示有油,’*'无油,相邻(包括对角线)则属于同一油田,问有多少个油田</p><p>思路:<br>水题,深搜,19级上套题就有</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"><span class="type">char</span> mp[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">bool</span> v[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]= &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> m=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[sx][sy]||mp[sx][sy]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    v[sx][sy]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;sx&lt;&lt;&quot;-&quot;&lt;&lt;sy&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">up</span>(<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp_x=sx+dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> tmp_y=sy+dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(tmp_x&lt;<span class="number">0</span>||tmp_x&gt;=m||tmp_y&lt;<span class="number">0</span>||tmp_y&gt;=n||v[tmp_x][tmp_y]||mp[tmp_x][tmp_y]==<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">dfs</span>(tmp_x,tmp_y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(NULL);</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(m|n))<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="literal">false</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                cin&gt;&gt;mp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// cout&lt;&lt;dfs(i,j)&lt;&lt;endl;</span></span><br><span class="line">                sum+=<span class="built_in">dfs</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G：非常可乐-hdu-1495">G：非常可乐 (hdu-1495)</h3><p>题意:</p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200806140304.png" alt="我是图"></p><p>思路:<br>注意装可乐的瓶子也是可以用的,6个选择:</p><ul><li>S &lt;-&gt; N</li><li>S &lt;-&gt; M</li><li>N &lt;-&gt; M</li></ul><p>用bfs解决;<br>也有数学方法解决(数论): <a href="https://blog.csdn.net/weixin_43627118/article/details/105678059">🔗外部链接🔗</a></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200806142127" alt="我是图"></p><p>直接扒代码<a href="https://blog.csdn.net/weixin_43627118/article/details/105678059">🔗外部连接🔗</a>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100+5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,s,t;</span><br><span class="line">&#125;cole[N],st;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a,b,s;</span><br><span class="line"><span class="type">int</span> vis[N][N];  <span class="comment">//记录状态（二维就可以记录三维的状态）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    st.a=<span class="number">0</span>; st.b=<span class="number">0</span>; st.s=s; st.t=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line">    vis[a][b]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node u=q.<span class="built_in">front</span>(),v;</span><br><span class="line">        <span class="comment">//能平分的条件是可乐瓶和容量大（a）的杯子都装着最开始一半的可乐。</span></span><br><span class="line">        <span class="keyword">if</span>(u.a==s/<span class="number">2</span> &amp;&amp; u.s==s/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> u.t;</span><br><span class="line">        <span class="keyword">if</span>(u.s &amp;&amp; u.a!=a)   <span class="comment">//s-&gt;a</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=a-u.a;</span><br><span class="line">            <span class="keyword">if</span>(u.s&gt;=c) v.a=a,v.s=u.s-c;</span><br><span class="line">            <span class="keyword">else</span> v.a=u.a+u.s,v.s=<span class="number">0</span>;</span><br><span class="line">            v.b=u.b; v.t=u.t+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v.a][v.b])  <span class="comment">//只从之前没有出现的状态往下推，下同。</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vis[v.a][v.b]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.s &amp;&amp; u.b!=b)   <span class="comment">//s-&gt;b</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=b-u.b;</span><br><span class="line">            <span class="keyword">if</span>(u.s&gt;=c) v.b=b,v.s=u.s-c;</span><br><span class="line">            <span class="keyword">else</span> v.b=u.b+u.s,v.s=<span class="number">0</span>;</span><br><span class="line">            v.a=u.a; v.t=u.t+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v.a][v.b])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vis[v.a][v.b]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.a &amp;&amp; u.s!=s)   <span class="comment">//a-&gt;s</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=s-u.s;</span><br><span class="line">            <span class="keyword">if</span>(u.a&gt;=c) v.s=s,v.a=u.a-c;</span><br><span class="line">            <span class="keyword">else</span> v.s=u.s+u.a,v.a=<span class="number">0</span>;</span><br><span class="line">            v.b=u.b; v.t=u.t+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v.a][v.b])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vis[v.a][v.b]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.a &amp;&amp; u.b!=b)   <span class="comment">//a-&gt;b</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=b-u.b;</span><br><span class="line">            <span class="keyword">if</span>(u.a&gt;=c) v.b=b,v.a=u.a-c;</span><br><span class="line">            <span class="keyword">else</span> v.b=u.b+u.a,v.a=<span class="number">0</span>;</span><br><span class="line">            v.s=u.s; v.t=u.t+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v.a][v.b])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vis[v.a][v.b]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.b &amp;&amp; u.a!=a)   <span class="comment">//b-&gt;s</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=a-u.a;</span><br><span class="line">            <span class="keyword">if</span>(u.b&gt;=c) v.a=a,v.b=u.b-c;</span><br><span class="line">            <span class="keyword">else</span> v.a=u.a+u.b,v.b=<span class="number">0</span>;</span><br><span class="line">            v.s=u.s; v.t=u.t+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v.a][v.b])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vis[v.a][v.b]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u.b &amp;&amp; u.s!=s)   <span class="comment">//b-&gt;a</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=s-u.s;</span><br><span class="line">            <span class="keyword">if</span>(u.b&gt;=c) v.s=s,v.b=u.b-c;</span><br><span class="line">            <span class="keyword">else</span> v.s=u.s+u.b,v.b=<span class="number">0</span>;</span><br><span class="line">            v.a=u.a; v.t=u.t+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v.a][v.b])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                vis[v.a][v.b]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//所有扩展的状态都不能使之平分。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;a,&amp;b),s||a||b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s%<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); <span class="comment">//这里使a作大号杯，方便bfs条件的判定。</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H：Find-a-way-hdu-2612">H：Find a way (hdu-2612)</h3><p>题意:<br>Y和M两人到达同一个肯德基’@'的最短路径.</p><p>思路:<br>对Y和M分别进行2次bfs,因为最短路径需要合计,所以分别进行bfs时不设置终止条件(即找到每个kfc的路径).<br>对Y进行bfs得到Y到每个kfc的最短距离并保存,然后对M进行bfs得到M到每个kfc的最短距离加上前面Y的距离即可.</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ma[MAXN][MAXN];<span class="comment">//存图</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//图的大小</span></span><br><span class="line"><span class="type">int</span> v[MAXN][MAXN];<span class="comment">//标记数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;<span class="comment">//x坐标,y坐标，及到达此点的步数</span></span><br><span class="line">&#125;t, p, q, que[<span class="number">121212</span>];</span><br><span class="line"><span class="type">int</span> ans[MAXN][MAXN];<span class="comment">//记录到达@点的步数</span></span><br><span class="line"><span class="type">int</span> vectors[][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">//上下左右四个方向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v[x][y] = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    p.x = x;</span><br><span class="line">    p.y = y;</span><br><span class="line">    p.step = <span class="number">0</span>;</span><br><span class="line">    que[rear++] = p;<span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        q = que[front++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//四个方向遍历</span></span><br><span class="line">         &#123;</span><br><span class="line">            p.x = q.x + vectors[i][<span class="number">0</span>];</span><br><span class="line">            p.y = q.y + vectors[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(p.x&lt;<span class="number">0</span>||p.x&gt;=n||p.y&lt;<span class="number">0</span>||p.y&gt;=m||v[p.x][p.y]||ma[p.x][p.y]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                 <span class="keyword">continue</span>;<span class="comment">//不符条件</span></span><br><span class="line">            <span class="keyword">if</span>(ma[p.x][p.y]==<span class="string">&#x27;@&#x27;</span>)<span class="comment">//如果是终点</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans[p.x][p.y] += q.step + <span class="number">1</span>;<span class="comment">//记录步数</span></span><br><span class="line">            &#125;</span><br><span class="line">            v[p.x][p.y] = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">            p.step = q.step+<span class="number">1</span>;<span class="comment">//更新步数</span></span><br><span class="line">            que[rear++] = p;<span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));<span class="comment">//清零</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ma[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ma[i][j]==<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.x = i;<span class="comment">//记录横坐标</span></span><br><span class="line">                t.y = j;<span class="comment">//记录竖坐标</span></span><br><span class="line">                t.step = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">bfs</span>(t.x, t.y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ma[i][j]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.x = i;</span><br><span class="line">                t.y = j;</span><br><span class="line">                t.step = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));<span class="comment">//记得清零</span></span><br><span class="line">    <span class="built_in">bfs</span>(t.x, t.y);</span><br><span class="line">    <span class="type">int</span> min = <span class="number">989898</span>;<span class="comment">//定义一个大一点的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span>(ans[i][j]&lt;min&amp;&amp;ans[i][j])</span><br><span class="line">                    min = ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min*<span class="number">11</span>);<span class="comment">//别忘了*11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="I：胜利大逃亡-hdu-1253">I：胜利大逃亡 (hdu-1253)</h3><p>题意:<br>不会吧? 不会吧? 不会真有人看不懂中文吧?</p><p>思路:<br>3维bfs,直接抄我以前写的代码了,毕竟刚学的时候写的,某些代码习惯不要学.</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,y,z,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">52</span>][<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;Node&gt; Q;</span><br><span class="line">    <span class="type">int</span> xi=<span class="number">0</span>,yi=<span class="number">0</span>,zi=<span class="number">0</span>,step=<span class="number">0</span>;</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(&#123;xi,yi,zi,step&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node tmp=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        xi=tmp.x;</span><br><span class="line">        yi=tmp.y;</span><br><span class="line">        zi=tmp.z;</span><br><span class="line">        step=tmp.step;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;%d: (%d, %d, %d)\n&quot;,step,xi,zi,zi);</span></span><br><span class="line">        <span class="keyword">if</span>(xi==x<span class="number">-1</span>&amp;&amp;yi==y<span class="number">-1</span>&amp;&amp;zi==z<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step&lt;=t)cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">             <span class="type">int</span> xj=xi+dir[i][<span class="number">0</span>];</span><br><span class="line">             <span class="type">int</span> yj=yi+dir[i][<span class="number">1</span>];</span><br><span class="line">             <span class="type">int</span> zj=zi+dir[i][<span class="number">2</span>];</span><br><span class="line">             <span class="type">int</span> sj=step+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;%d: (%d, %d, %d)\n&quot;,step,xj,yj,zj);</span></span><br><span class="line">            <span class="keyword">if</span>(xj&lt;<span class="number">0</span>||xj&gt;=x||yj&lt;<span class="number">0</span>||yj&gt;=y||zj&lt;<span class="number">0</span>||zj&gt;=z)&#123;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;&quot;fail&quot;&lt;&lt;endl;</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;Q.size()&lt;&lt;&quot;:::&quot;&lt;&lt;a[xj][yj][zj]&lt;&lt;&quot; &quot;&lt;&lt;b[xi][yi][zi]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(a[xj][yj][zj]!=<span class="number">1</span>&amp;&amp;!b[xj][yj][zj])&#123;</span><br><span class="line">               <span class="comment">// cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;</span></span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;xj,yj,zj,sj&#125;);</span><br><span class="line">                b[xj][yj][zj]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;y; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>; l&lt;z; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i][j][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="J：胜利大逃亡-续-hdu-1429">J：胜利大逃亡(续) (hdu-1429)</h3><p>题意:<br>…</p><p>思路:<br>以前混过去的,果然该还的还是要还的…<br>状态压缩+bfs<br>每个点有一个钥匙🔑的状态由一个10位二进制数表示,第i位为1则表示第i把钥匙🔑已经到手,遇到门直接用位运算匹配钥匙🔑的值即可</p><p>知识点:<br><a href="https://zhuanlan.zhihu.com/p/131585177">🔗逼乎🔗</a><br><a href="https://blog.csdn.net/weixin_33966095/article/details/94504276">🔗CSDN🔗</a><br>位运算(百度)</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> up(x) for(int i=0;i&lt;x;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l,mid,rt&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;     <span class="comment">///1 061 109 567</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> negative_infinite = <span class="number">0xcfcfcfcf</span>;   <span class="comment">///-808 464 433</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]= &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> a[<span class="number">22</span>][<span class="number">22</span>];<span class="comment">//地图</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">22</span>][<span class="number">22</span>][<span class="number">2</span>&lt;&lt;<span class="number">10</span>];<span class="comment">//一个点可以多次经过,但他们所具有的钥匙状态不同,若钥匙状态相同说明重复了,不可继续访问该点.</span></span><br><span class="line"><span class="type">int</span> m,n,t,key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">int</span> key;<span class="comment">//钥匙状态,一个二进制数</span></span><br><span class="line">&#125;S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(&#123;S.x,S.y,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">v[S.x][S.y][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    Node now=Q.<span class="built_in">front</span>(),next;</span><br><span class="line">    Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        next=now;</span><br><span class="line">        next.x+=dir[i][<span class="number">0</span>];</span><br><span class="line">        next.y+=dir[i][<span class="number">1</span>];</span><br><span class="line">        next.step++;</span><br><span class="line">        <span class="keyword">if</span>(next.step&gt;=t||next.x&lt;<span class="number">0</span>||next.x&gt;=m||next.y&lt;<span class="number">0</span>||next.y&gt;=n||v[next.x][next.y][next.key])<span class="keyword">continue</span>;<span class="comment">//超时超界以及钥匙状态判断</span></span><br><span class="line">        <span class="keyword">if</span>(a[next.x][next.y]==<span class="string">&#x27;^&#x27;</span>)&#123; <span class="comment">//终点,结束.</span></span><br><span class="line">            cout&lt;&lt;next.step&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[next.x][next.y]==<span class="string">&#x27;*&#x27;</span>)<span class="keyword">continue</span>; <span class="comment">//墙</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[next.x][next.y]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;a[next.x][next.y]&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123; <span class="comment">//遇到门</span></span><br><span class="line">            <span class="keyword">if</span>(next.key&gt;&gt;(a[next.x][next.y]-<span class="string">&#x27;A&#x27;</span>) &amp;<span class="number">1</span>)&#123;</span><br><span class="line">                v[next.x][next.y][next.key]=<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(next);            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[next.x][next.y]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;a[next.x][next.y]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123; <span class="comment">//遇到钥匙</span></span><br><span class="line">            next.key|=(<span class="number">1</span>&lt;&lt;(a[next.x][next.y]-<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            v[next.x][next.y][next.key]=<span class="number">1</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//普通的路</span></span><br><span class="line">            v[next.x][next.y][next.key]=<span class="number">1</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl; <span class="comment">//bfs失败,无法逃脱</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n&gt;&gt;t)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                cin&gt;&gt;a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    S.x=i;</span><br><span class="line">                    S.y=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));<span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="K：诡异的楼梯-hdu-1180">K：诡异的楼梯 (hdu-1180)</h3><p>题意:<br>…</p><p>思路:<br>bfs,bfs,bfs,全是bfs…<br>注意楼梯是捷径,如果你走的方向恰好和楼梯一样,你就可以通过楼梯,人的方向由dir可以顺便得出<br><a href="https://blog.csdn.net/weixin_41707869/article/details/81265526">🔗详细一点的讲解🔗</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> sx,sy,m,n,ans;</span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>][<span class="number">20</span>],ch;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]= &#123;<span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">-1</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">//下右上左</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(node p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.x&gt;=<span class="number">0</span> &amp;&amp; p.x&lt;m &amp;&amp; p.y&gt;=<span class="number">0</span> &amp;&amp; p.y&lt;n &amp;&amp; !vis[p.x][p.y]) <span class="comment">//没有出界并且没有访问过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stair</span><span class="params">(node q,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a[q.x][q.y]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; i%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; (q.step<span class="number">-1</span>)%<span class="number">2</span>==<span class="number">0</span>) ||  <span class="comment">//楼梯开始时横着，人左右走，此时楼梯仍横着</span></span><br><span class="line">       (a[q.x][q.y]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; (q.step<span class="number">-1</span>)%<span class="number">2</span>==<span class="number">1</span>) ||  <span class="comment">//楼梯开始时横着，人上下走，此时楼梯旋转成竖着</span></span><br><span class="line">       (a[q.x][q.y]==<span class="string">&#x27;|&#x27;</span> &amp;&amp; i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; (q.step<span class="number">-1</span>)%<span class="number">2</span>==<span class="number">0</span>) ||  <span class="comment">//楼梯开始时竖着，人上下走，此时楼梯仍竖着</span></span><br><span class="line">       (a[q.x][q.y]==<span class="string">&#x27;|&#x27;</span> &amp;&amp; i%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; (q.step<span class="number">-1</span>)%<span class="number">2</span>==<span class="number">1</span>) )   <span class="comment">//楼梯开始时竖着，人左右走，此时楼梯旋转成横着</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue &lt;node&gt; Q;</span><br><span class="line">    node p,q;</span><br><span class="line">    p.x = sx;</span><br><span class="line">    p.y = sy;</span><br><span class="line">    p.step = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(p);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        p = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.x = p.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            q.y = p.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            q.step = p.step + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(q) &amp;&amp; a[q.x][q.y]!=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[q.x][q.y]==<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = q.step;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[q.x][q.y]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[q.x][q.y] = <span class="literal">true</span>;</span><br><span class="line">                    Q.<span class="built_in">push</span>(q);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[q.x][q.y]==<span class="string">&#x27;-&#x27;</span> || a[q.x][q.y]==<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">stair</span>(q,i))</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.x = q.x + dir[i][<span class="number">0</span>];</span><br><span class="line">                        q.y = q.y + dir[i][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">check</span>(q) &amp;&amp; a[q.x][q.y]!=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(a[q.x][q.y]==<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                ans = q.step;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            vis[q.x][q.y] = <span class="literal">true</span>;</span><br><span class="line">                            Q.<span class="built_in">push</span>(q);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        q = p;</span><br><span class="line">                        q.step++;</span><br><span class="line">                        Q.<span class="built_in">push</span>(q);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;ch;</span><br><span class="line">                a[i][j] = ch;</span><br><span class="line">                <span class="keyword">if</span>(ch == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="L：Eight-hdu-1043">L：Eight (hdu-1043)</h3><p>题意:<br>八数码问题也称为九宫问题。在3×3的棋盘上摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。给出一个初始状态和一个目标状态，求出从初始状态转变成目标状态的移动棋子步数的最少值。</p><p>思路&amp;代码:<br>八数码问题,不要求掌握但不妨碍你去掌握</p><p>直接看大佬的博客吧:<br><a href="https://blog.csdn.net/txl16211/article/details/51953951">🔗外部链接1🔗</a><br><a href="https://blog.csdn.net/xiaosshhaa/article/details/54315981">🔗外部链接2🔗</a></p><h3 id="M：连连看-hdu-1175">M：连连看 (hdu-1175)</h3><p>题意:<br>…</p><p>思路:<br>bfs,可改进的bfs<br>改进思路:</p><blockquote><p>一个一般的结论:</p><blockquote><p>如果某一点记录的转向次数大于当前路径在该点的转向次数，那么还能从该点再发出一条路径来查找。</p></blockquote></blockquote><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> map[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//方向数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> trun;</span><br><span class="line">&#125;start,endd;</span><br><span class="line"> queue&lt;node&gt; q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x0&lt;<span class="number">0</span>||x0&gt;=n||y0&lt;<span class="number">0</span>||y0&gt;=m)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(x0==x2<span class="number">-1</span>&amp;&amp;y0==y2<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(map[x0][y0]!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//队列清零</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">start.x=x0;</span><br><span class="line">start.y=y0;</span><br><span class="line">start.trun=<span class="number">-1</span>;</span><br><span class="line">v[x0][y0]=<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">q.<span class="built_in">push</span>(start);<span class="comment">//元素入列</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">start=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//元素出列</span></span><br><span class="line"><span class="keyword">if</span>(start.trun&gt;=<span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">endd.x=start.x+dir[i][<span class="number">0</span>];</span><br><span class="line">endd.y=start.y+dir[i][<span class="number">1</span>];</span><br><span class="line">endd.trun=start.trun+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">judge</span>(endd.x,endd.y))<span class="keyword">continue</span>;<span class="comment">//越界判断</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">judge</span>(endd.x,endd.y)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(endd.x==x2<span class="number">-1</span>&amp;&amp;endd.y==y2<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[endd.x][endd.y]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(endd);<span class="comment">//元素入列</span></span><br><span class="line">v[endd.x][endd.y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">endd.x+=dir[i][<span class="number">0</span>];</span><br><span class="line">endd.y+=dir[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;map[i][j]);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            <span class="keyword">if</span>(x1==x2&amp;&amp;y1==y2)<span class="comment">//起点终点相同，不行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map[x1<span class="number">-1</span>][y1<span class="number">-1</span>]!=map[x2<span class="number">-1</span>][y2<span class="number">-1</span>]||map[x1<span class="number">-1</span>][y1<span class="number">-1</span>]==<span class="number">0</span>||map[x2<span class="number">-1</span>][y2<span class="number">-1</span>]==<span class="number">0</span>)<span class="comment">//起点或者终点为0，起点终点不同，不行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line"><span class="built_in">bfs</span>(x1<span class="number">-1</span>,y1<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="N：Dating-with-girls-2-hdu-2579">N：Dating with girls(2) (hdu-2579)</h3><p>题意:<br>给你一个数T，表示有T组测试示例，接下来时r，c，k，表示迷宫的大小为r行c列，这个迷宫是非常奇怪的，<br>迷宫里有很多石头。这些石头会在t时刻消失，t的定义是k的倍数，在其他时候石头是依然存在的…是你<br>可以直接走的到地方，#表示石头，Y表示你的初始位子，G表示妹纸，保证只有一个Y和一个G，<br>每一秒你可以向左走，向右走，向上走，或者向下走。</p><p>思路:<br>J题的简单版?只需要在t倍数时刻判断一下是否可以走到石头点就行了.</p><p><a href="https://blog.csdn.net/lihuanz/article/details/81158120">代码</a>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,output;</span><br><span class="line">&#125;now,nex;</span><br><span class="line"><span class="type">int</span> fx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">105</span>][<span class="number">105</span>][<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    now.x=x;</span><br><span class="line">    now.y=y;</span><br><span class="line">    now.output=<span class="number">0</span>;</span><br><span class="line">    vis[x][y][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    queue&lt;node&gt;s;</span><br><span class="line">    s.<span class="built_in">push</span>(now);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        now=s.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(a[now.x][now.y]==<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,now.output);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nex.x=now.x+fx[i];</span><br><span class="line">            nex.y=now.y+fy[i];</span><br><span class="line">            nex.output=now.output+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nex.x&gt;=<span class="number">0</span>&amp;&amp;nex.x&lt;n&amp;&amp;nex.y&gt;=<span class="number">0</span>&amp;&amp;nex.y&lt;m&amp;&amp;vis[nex.x][nex.y][nex.output%k]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[nex.x][nex.y]==<span class="string">&#x27;.&#x27;</span>||a[nex.x][nex.y]==<span class="string">&#x27;G&#x27;</span>||a[nex.x][nex.y]==<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[nex.x][nex.y][nex.output%k]=<span class="number">1</span>;</span><br><span class="line">                    s.<span class="built_in">push</span>(nex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a[nex.x][nex.y]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;nex.output%k==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[nex.x][nex.y][nex.output%k]=<span class="number">1</span>;</span><br><span class="line">                    s.<span class="built_in">push</span>(nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please give me another chance!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sx,sy;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sx=i;</span><br><span class="line">                    sy=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(sx,sy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p><font color=blue size=5>下一节应该是二分查找&amp;贪心?做好预习吧…</font></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android系统https抓包问题分析</title>
      <link href="/posts/e83dc864/"/>
      <url>/posts/e83dc864/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>曾在Android系统抓包Bilibili客户端时遇到HTTPS验证问题，一直很不解，我不是安装了CA证书了吗？直到在52pojie看到<a href="https://www.52pojie.cn/home.php?mod=space&amp;uid=488347">@小木曾雪菜</a> 的文章 <a href="https://www.52pojie.cn/thread-1217467-1-1.html">[原创] 网络逆向（一） 油猴脚本与抓包初步 以显示b站楼层编号为例 </a><br>才恍然大悟,b站客户端通过SSL pinning进行安全通信,原理大概是: 中间人通过伪造假的服务端证书来欺骗客户端，那么客户端就预置一份服务端证书来验证证书的真假.<br>之后机缘巧合下刚好在论坛的精华贴看到<a href="https://www.52pojie.cn/home.php?mod=space&amp;uid=959833">@psych1</a> 的文章 <a href="https://www.52pojie.cn/thread-1213657-1-1.html">[Android 原创] android系统https抓包问题分析</a><br>很好的解释了我遇到的问题，特此记录，<font color=red size=4>侵删</font></p><span id="more"></span><h2 id="HTTPS">HTTPS</h2><p>http是超文本传输协议，其存在通信使用明文，内容极易被窃听；不验证通信方的身份，因此有可能遭遇伪装；无法证明报文的完整性，所以有可能遭到篡改的问题<br>于是HTTPS应运而生。https中的s是ssl或者tls，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP + 加密 + 认证 + 完整性保护 = HTTPS</span><br></pre></td></tr></table></figure><h3 id="HTTPS的单双向验证">HTTPS的单双向验证</h3><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200712195213.png"/>  <p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200712195313.png" alt=""></p><h3 id="SSL-pinning">SSL pinning</h3><p>SSL-pinning有两种方式：<br>证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。</p><blockquote><p>证书锁定</p><blockquote><p>需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在<br>证书续期后需要将证书重新内置到APP中。</p></blockquote><p>公钥锁定</p><blockquote><p>提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。</p></blockquote></blockquote><p>与双向验证不同，SSL pinning方案是服务端发送CA证书给客户端，客户端将本地预置的证书(存放在.\asset目录或\res\raw下)与其进行校验,而双向验证<br>则<strong>额外</strong>有个客户端向服务器发送CA证书，服务器对客户端证书进行校验的过程</p><h2 id="解决方案">解决方案</h2><p>不是研究方向，未实际做过，直接贴原文:<br><a href="https://www.52pojie.cn/thread-1213657-1-1.html">https://www.52pojie.cn/thread-1213657-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程笔记(弃坑)</title>
      <link href="/posts/f3ce9b23/"/>
      <url>/posts/f3ce9b23/</url>
      
        <content type="html"><![CDATA[<h2 id="词法分析">词法分析</h2><p><s>前面的课程没有笔记，在这里补一下哈，主要参考国防科技大学的编译原理MOOC</s><br>简单来说就是判断一个字符串是否是合法单词<br>正规式的等价性:<br>b(ab)*=(ba)*b<br>即：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430103730.jpg" alt="MOOC"></p><h3 id="确定的有限自动机-DFA">确定的有限自动机(DFA)</h3><p>M=(S,Σ,f,S?,F)</p><span id="more"></span><p>S：有穷状态集<br>Σ：输入字母表<br>f：状态转换函数，<strong>后继唯一</strong><br>S?：S? ∈ S，<strong>是唯一的一个初态</strong><br>F：F ∈ S，终态集(可以为空)</p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430105139.jpg" alt="MOOC"></p><p>tips:</p><ul><li>DFA每个顶点射出的弧上的标记符不同</li><li>DFA M所识别的字的全体为L(M)</li></ul><h3 id="非确定的有限自动机">非确定的有限自动机</h3><p>M=(S,Σ,f,S?,F)</p><p>S：有穷状态集<br>Σ：输入字母表<br>f：状态转换函数，<strong>可以是字符，字，正规式</strong><br>S?：S? ∈ S，<strong>非空初态集</strong><br>F：F ∈ S，终态集(可以为空)<br>NFA与DFA区别：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430111624.jpg" alt="MOOC"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430115640.jpg" alt="MOOC"></p><p>DFA与NFA识别能力相同：</p><ul><li>对于每一个NFA，有一个DFA与该NFA识别能力相同</li></ul><h3 id="NFA到DFA的转换-NFA的确定化">NFA到DFA的转换(NFA的确定化)</h3><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430115640.jpg" alt="MOOC"><br>如上图，NFA的确定化就是要消除这三个方面的差异</p><ol><li>消除初始状态的差异</li></ol><ul><li>引进新的初态结点X和终态结点Y，X经过ε到S?(初始状态集)中任意结点，Y经过ε到F(终态集)中的任意结点</li></ul><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430120536.jpg" alt="NFA by MOOC"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200430120541.jpg" alt="INSERT XY by MOOC"></p><ol start="2"><li>消除弧上标记差异和转换差异<br>子集法: 解决 ε 弧和转换关系</li></ol><ul><li>引入定义<strong>ε-闭包</strong>，即ε-closure(I)为:<ul><li>若S ∈ I，则S ∈ ε-closure(I)；</li><li>若S ∈ I，则从S出发经过任意条 ε 弧所能到达的任何状态 S′ 都属于ε-closure(I)。</li></ul></li></ul><p><font color=green size=5>偷下懒，直接放图</font><br>定义Ia如图：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200502144604.jpg" alt="MOOC"><br>即：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200502144718.jpg" alt="MOOC"><br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200502145258.jpg" alt="MOOC"><br>得到转换表:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200502145841.jpg" alt="MOOC"><br>注意即使Ia或者Ib是空集若满足条件也要放入I计算下去<br><u>话说计算 J 中间能经过 ε 吗？应该是不能的(若有错误请联系我订正)，而且只能经过一个a|b。</u></p><p>放个例子：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200502151035.jpg" alt="MOOC"><br>转换表编号后变成DFA：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200502151845.jpg" alt="MOOC"></p><p>DFA化简( <font color=green size=4>待补</font> )：<br>先划分为终态和非终态；<br>再对两个子集细分直到无法再分：<br>即子集中每个元素的move结果不同的要区分开来，具体见<a href="https://www.icourse163.org/learn/NUDT-1003101005?tid=1450256472#/learn/content?type=detail&amp;id=1214459156&amp;cid=1218189141">MOOC 6.1 第4个视频</a></p><hr><h2 id="语法分析">语法分析</h2><p>简单理解为判断一个输入串是否是一个<strong>句子</strong><br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508140318.jpg" alt="分析方法"></p><h3 id="回顾上下文无关文法">回顾上下文无关文法</h3><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508135238.jpg" alt="四元组"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508135424.jpg" alt="一些定义"></p><ul><li>开始符S能推导出的叫做<strong>句型</strong>，<strong>句型</strong>只有<strong>终结符组成</strong>叫<strong>句子</strong>, 文法的所有句子的集合叫<strong>语言</strong></li></ul><h3 id="自上而下分析">自上而下分析</h3><p>示例如图：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508141105.jpg" alt=""><br>从文法开始符号S开始推导,S只有一个右部，取 S -&gt; xAy 进入下一层，x匹配成功，A匹配失败且A有下一层，取右部(从左到右取),A下一层是两个※号,第一个 * 匹配成功，第二个 * 匹配失败，<strong>回溯</strong>,<br>取A -&gt; * ，匹配成功，y匹配成功，完成。<br>下面介绍下一些可能遇到的问题。</p><h4 id="回溯问题">回溯问题</h4><p>如上例，匹配成功可能是暂时的，出错时就得<strong>回溯</strong></p><h4 id="文法左递归问题">文法左递归问题</h4><p>即可能存在 P =+=&gt; Pα，即P推导出的句型中又有P开头<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508142439.jpg" alt="左递归"><br>构建语法树的过程中可能不断遇到使用左递归式的问题，这会导致语法树一直构建下去而未继续读入任何字符，陷入死循环</p><h4 id="消除文法左递归">消除文法左递归</h4><h5 id="消除直接左递归">消除直接左递归</h5><p>例如： P -&gt; Pα|β (β不以P开头)<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508143258.jpg" alt="简单直接左递归"><br>而右递归因为有字符会不断被读入并匹配，所以右递归不会产生死循环<br>下面是一个复杂点的 m个左递归<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508143648.jpg" alt="复杂直接左递归"></p><h5 id="消除间接左递归">消除间接左递归</h5><p>如：<br>S -&gt; Qc|c<br>Q -&gt; Rb|b<br>R -&gt; Sa|a<br>没有直接左递归，但其实S,Q,R都是左递归的，例如存在 S =&gt; Qc =&gt; Rbc =&gt; Sabc</p><p>现在来消除间接左递归<br>但是有前提条件</p><ul><li>不含以 ε 为右部的产生式</li><li>不含回路，即不能自己推自己(P =+=&gt; P)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508145132.jpg" alt=""><br>通过不断带入来打破循环<br>算法 ：<br>所有非终结符P = { P1…Pn }按顺序排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 把(Pi) -&gt; (Pj)α 改写为 (Pi) -&gt; (β1)α|(β2)α|(β3)α...|(βk)α</span></span><br><span class="line">        <span class="comment"># 示例见下图</span></span><br></pre></td></tr></table></figure><p>同一个文法<br>S -&gt; Qc|c<br>Q -&gt; Rb|b<br>R -&gt; Sa|a<br>排列：R,Q,S<br>首先R，R以S开头，但S顺序在R后面，故R不处理；然后Q，Q以R开头，R在Q前面，所以把R用R的右部代替即 Q -&gt; Sab|ab|b ,<br>R的右部现在没有<u>按照顺序在它前面的非终结符</u>开头的了，所以完成；开始S，Q在S之前，Q要替换成Q的右部即 S -&gt; Sabc|abc|bc|c<br><strong>注意了！！！</strong> ,S有有直接左递归，按照消除左递归的方法消除它：S -&gt; abcS’ | bcS’ | cS’ and S’ -&gt; abcS’ | ε<br><strong>然后！！！</strong> 可以看到从S出发到S’, S’ 又到 S’,Q和R无用，删掉</p><h4 id="消除回溯">消除回溯</h4><p>即保证在构建分析树的时候输入一个字符串，对于每一个非终结符，如果它有多个候选A -&gt; α|β|σ 选择必须是正确唯一的，这样就不需要回溯。</p><p>我们这样想，我们要扩展A就要选择A的右部中 <u>以当前匹配字符a开头的</u> 或者 <u>经过若干步推导以a开头的</u><br>但是A的右部有多个以当前匹配字符a开头的怎么办？依旧有回溯啊？<br>于是引入FIRST集，<font color=red size=5>这个FIRST集是针对所有非终结符(例如上面的A)的右部的每个式子而产生的</font><br>这样就能解决上面提出的问题<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508160102.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508160337.jpg" alt=""><br>示例：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508160902.jpg" alt=""><br>匹配 i+i ，<strong>在末尾加个结束符#</strong>，从开始符E开始，E只有一个右部，扩展；T只有一个右部，扩展；F要匹配i，(E) 的首符集是左括号，i的首符集是i，所以F选择推导到i而不是(E);<br>对于T’ 因为另一个首符集是星号，只能选择 ε。后面略。</p><p>但是我们同时也看到在第一个T’时，T’只能取 ε，且+号跟在 T’ 后面,…我也半知半解…<br>总之，引入FOLLOW集，即从开始符S能推出的所有句子中，A后面跟着的那个字符组成的集合就是A的FOLLOW集<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508174944.jpg" alt=""><br>例如上图，若A要匹配a但a不在A的FIRST集里，所以只能取ε，但取了后是否就能匹配呢，这要看FOLLOW集。</p><h5 id="FIRST集及其构造方法">FIRST集及其构造方法</h5><ul><li>为了消除公共左公因子产生的回溯问题<br>左公因子产生式举例：<br><strong>A -&gt; αβ1 | αβ2</strong><br>即某个非终结符的多个候选式具有相同前缀，上式αβ1和αβ2具有相同前缀α</li></ul><p>构造方法：<br>对于每一个X ∈ V_t ∪ V_n , 使用如下规则直到每个FIRST集不再增大：</p><ul><li>若X ∈ V_t，则FIRST(X)={X}<br>若X是终结符，则其FIRST集就是其本身</li><li>若X ∈ V_n，X是非终结符，那么有<ul><li>若X -&gt; a… ，则 a ∈ FIRST(X)，<strong>这里 a 可以是 ε</strong></li><li>若X -&gt; Y… ，则 FIRST(Y) - {ε} ∈ FIRST(X)</li><li>若X -&gt; Y?Y?Y?..Ym…Yn , Y(1-m) 即 前m个Y 都是非终结符.<ul><li>若FIRST(Yj) 1 &lt;= j &lt;= m 都含有ε，则把FIRST(Ym+1)中的非ε元素加入FIRST(X),直白点就是前面m个都<strong>可以</strong>为空，那就把他们取成空来算后面那个。</li><li>若FIRST(Yj) 1 &lt;= j &lt;= n 都含有ε，则把ε加入FIRST(X).</li></ul></li></ul></li></ul><p><font color=red size=4>若在构造过程中有FIRST(X)发生变化，从头开始</font><br>例：<br>G_S:<br>S -&gt; aA<br>S -&gt; d<br>A -&gt; bAS<br>A -&gt; ε<br>有FIRST集<br>FIRST(S) = {a,d}<br>FIRST(A) = {b,ε}<br>FIRST(aA) = {a}<br>FIRST(d) = {d}<br>FIRST(bAS) = {b}<br>FIRST(ε) = {ε}</p><h5 id="FOLLOW集及其构造">FOLLOW集及其构造</h5><p>对于A ∈ V_t，有 FOLLOW(A) = {a | S =*=&gt; …Aa… , a ∈ V_t }</p><p>若S =*=&gt; …A ,则规定 # ∈ FOLLOW(A)<br>这里用#作为输入串的结束符，也叫输入串符号</p><p>构造方法：<br>对于每个非终结符A，使用如下规则直到每个FOLLOW集不再增大：</p><ul><li>首先，若S为文法开始符号，{ # } ∈ FOLLOW(S)</li><li>若 B -&gt; αAβ 是一个产生式,则FIRST(β)-{ε} ∈ FOLLOW(A)</li><li>若 B -&gt; αA 或者 B -&gt; αAβ且β =*=&gt; ε，则FOLLOW(B) ∈ FOLLOW(A)<br>例：<br>A -&gt; BCc|gDB<br>B -&gt; bCDE|ε<br>C -&gt; DaB|ca<br>D -&gt; dD|ε<br>E -&gt; gAf|c<br>有</li></ul><table><thead><tr><th style="text-align:center">非终结符</th><th style="text-align:center">FIRST集</th><th style="text-align:center">FOLLOW集</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">{ a,b,c,d,g }</td><td style="text-align:center">{ f,# }</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">{ b,ε }</td><td style="text-align:center">{ a,c,d,g,f,# }</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">{ a,c,d }</td><td style="text-align:center">{ c,d,g }</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">{ d,ε }</td><td style="text-align:center">{ a,b,c,g,f,# }</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">{ c,g }</td><td style="text-align:center">{ a,c,d,g,f,# }</td></tr></tbody></table><h4 id="LL-1-文法">LL(1)文法</h4><p>L - 从左到右扫描字符串<br>L - 最左推导<br>1 - 每次分析根据当前单词向前看一个符号<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508175746.jpg" alt="图"><br>满足上面三条的是LL(1)文法</p><h4 id="LL-1-分析法">LL(1)分析法</h4><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527124558.jpg" alt="LL1分析法"></p><h4 id="预测分析表的构造">预测分析表的构造</h4><h5 id="SELECT集">SELECT集</h5><p>其实就是上面LL(1)分析法，用select作为中介方便写，不容易出错。<br>对于待输入字符a，我们现在匹配a，所以找到 a ∈ FIRST(A-&gt;α)</p><ul><li><strong>若 α 不能推导出 ε ，那么 SELECT(A-&gt;α) = FIRST(α)</strong></li><li><strong>若 α 能推导出 ε ，那么 SELECT(A-&gt;α) = (FIRST(α)-{ε}) ∪ FOLLOW(A)</strong>，其实就是 α 能推出 ε，所以还要考虑α = ε的情况啦，这时候(α = ε)匹配a的就应该是A后面跟的字符。</li></ul><h5 id="构造预测分析表">构造预测分析表</h5><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527130452.jpg" alt="百度文库-构造"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527130700.jpg" alt="百度文库-示例"></p><h3 id="自下而上分析">自下而上分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527131836.jpg" alt="语法分析的方法"></p><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527134330.jpg" alt="图"></p><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527134256.jpg" alt="图"></p><h4 id="短语和直接短语-算符优先分析">短语和直接短语(算符优先分析)</h4><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527135806.jpg" alt="图"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528104245.jpg" alt="图"></p><h4 id="算符优先分析法">算符优先分析法</h4><p>句子可能有几种不同的归约方法，导致结果不同。如果事先规定算符的优先次序，并按照优先级进行归约，则这个归约过程就会是唯一的。<br>如，对于文法G[E]: E -&gt; i | E+E | E-E | E*E | E/E | (E),  有句子i+i-i*(i+i)<br>其归约过程如下：<br>i+i-i*(i+i)    E -&gt; i<br>E+i-i*(i+i)    E -&gt; i<br>E+E-i*(i+i)    E -&gt; E+E<br>E-i*(i+i)    E -&gt; i<br>E-E*(i+i)    这一步涉及到算符优先级，需要先算乘法，而乘法算符后面是括号，括号优先级更高，应该先算括号表达式<br>E-E*(E+E)    E -&gt; i 两次<br>E-E*(E)    E -&gt; E+E<br>E-E*E    E -&gt; (E)<br>E-E   E -&gt; E*E<br>E   E -&gt; E-E<br>归约完成<br>但我们知道文法本身没有规定算符优先级，我们再看一个例子，同样对于上面的句子进行归约<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528110336.jpg" alt="图"><br>归约过程中你会发现并不需要考虑算符优先级，这个句子依旧被正确地归约。  实际上我们是可以看出该文法优先级关系的。</p><h5 id="算符优先关系">算符优先关系</h5><p><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528111248.jpg" alt="图"><br>注意此关系与数学上的 &lt; , = , &gt; 是不同的，它表示左边的算符a与右边的算符b之间的关系，有前后顺序。<br>如对于 + 算符，数学上当然是两个加号相等的，不会出现大于小于关系(不考虑大于等于，小于等于)，但在算符优先关系上是可以规定优先级的，即可以规定左部的加号优先级小于右边的加号。<br>且<img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528111908.jpg" alt="图"></p><h5 id="算符优先文法">算符优先文法</h5><p>我们规定算符文法：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528112258.jpg" alt="图"><br>上面的计算的两个文法都是算符文法<br>继续规定:<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528113051.jpg" alt="图"><br>怎么理解？<br>小写字母是终结符，大写字母是非终结符</p><ol><li>如对于E -&gt; (E) ，左( 和 右) 的优先级相等</li><li>对于E -&gt; E?+E? ，这里用下标区分位置，又有E? -&gt; E?*E?，所以 左+ 优先级小于 右*</li><li>对于E -&gt; E?*E?,这里用下标区分位置,又有E? -&gt; E?+E?，所以 左+ 优先级大于 右*</li></ol><p>我们看到2与3似乎是矛盾的，但我们已经在上面的计算中发现该文法具有二义性，不能唯一地归约一个句子，所以这个矛盾恰恰说明其不是算符优先文法<br>我们规定：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528114147.jpg" alt="图"></p><p>例子：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528115047.jpg" alt="图"><br>得到算符优先关系表：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528115210.jpg" alt="图"></p><h5 id="构造算符优先关系表">构造算符优先关系表</h5><ol><li><p>对于相等优先关系，我们只需要考虑产生式右部中各个候选式，连续出现的终结符的优先关系就行，不需要考虑非终结符的推导<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528115514.jpg" alt=""></p></li><li><p>大于小于优先关系则需要考虑非终结符的推导<img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602083003.png" alt=""><br>其简单理解就是P的<strong>所有</strong>推导式的最左的终结符和最右的终结符<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602083746.png" alt=""></p></li></ol><p>构造FIRSTVT§的算法：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602084441.png" alt=""></p><p>构造LASTVT§的算法：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602085314.png" alt=""></p><p>构造关系表<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602090754.png" alt=""></p><h4 id="句柄和规范归约-LR分析">句柄和规范归约(LR分析)</h4><p>L: 从左到右扫描输入串<br>R: 自下而上进行归约<br><strong>一个句型的最左直接短语叫句柄</strong><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602095041.png" alt=""></p><p>例：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602092834.png" alt="">  <img src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602092843.png" alt=""></p><h4 id="LR分析法">LR分析法</h4><p>LR分析表：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602100204.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602100952.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602101004.png" alt=""></p><p>空白表示报错</p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602101235.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602101502.png" alt=""><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602101625.png" alt=""></p><p>举例：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200602101717.png" alt=""><br>右边LR分析表的构造会在后面提到</p><h5 id="LR-0-项目集规范族、DFA和分析表的构建">LR(0)项目集规范族、DFA和分析表的构建</h5><p><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200712194809.png" alt="概念"></p><p>例子:<br>文法：<br>S --&gt; BB<br>B --&gt; aB<br>B --&gt; b</p><p>步骤:</p><ol><li><p>拓展文法<br>S’ --&gt; S<br>S --&gt; BB<br>B --&gt; aB<br>B --&gt; b</p></li><li><p>求出项目集规范族<br>Item0 = CLOSURE({S’ --&gt; .S}) = {S’ --&gt; .S，S --&gt; .BB，B --&gt; .aB，B --&gt; .b}<br>Item1 =GO(Item0,S) = CLOSURE({S’ --&gt; S.}) = {S’ --&gt; S.}<br>Item2 = GO(Item0,B) = CLOSURE({S --&gt; B.B}) = {S --&gt; B.B，B --&gt; .aB，B --&gt; .b}<br>Item3 = GO(Item0,a) = CLOSURE({B --&gt; a.B}) = {B --&gt; a.B，B --&gt; .aB，B --&gt; .b}<br>Item4 = GO(Item0,b) = CLOSURE({B --&gt; b.}) = {B --&gt; b.}<br>至此Item0已经遍历完，开始遍历下一个，由于Item1圆点已经到达末尾，所以跳过Item1。<br>Item5 = GO({Item2,B) = CLOSURE({S --&gt; BB.}) = {S --&gt; BB.}<br>由于 GO(Item2,a) 和 GO(Item2,b) 重复，所以去掉。<br>Item6 = GO(Item3,B) = CLOSURE({B --&gt; aB.}) = {B --&gt; aB.}<br>由于 GO(Item3,a) 和 GO(Item3,b) 重复，所以去掉。<br>至此，项目集闭包不再增加，所以项目集规范族构造完毕！</p></li><li><p>构造DFA<br>!<img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200712194908.jpg" alt=""></p></li><li><p>构造LR(0)分析表(根据DFA图将分析表填充)<br>输入：文法G的扩展文法G’<br>输出：G’的LR(0)分析表（即 Action表和Goto表）<br>步骤：<br>1、 本例中Item2  --B–&gt;  Item5，则在  状态号为2的行，列名为B的格中填入状态5<br>(转移条件为非终结符，填充Goto表，填入状态号， 转移条件为终结符，填充Action表,<br>填入Sn，Sn表示移进，移进符号并且移进状态号n)<br>Item2  --a–&gt;  Item3 ，则在状态号为2的行，列名为a的格填入S3。<br>2、 对于圆点在右部最右边：<br>if  A --&gt; α. ∈ Itemk (0&lt;k&lt;n)  &amp; A --&gt; α 为G的第 j 个产生式，<br>then for  任意 a ∈ T U { # }  do<br>Action[k,a]  =  Rj<br>（Rn表示归约，不移进符号，用第n个产生式的右部替换符号栈的X）<br>3、 if  S’ --&gt; S.  ∈ Itemk (0&lt;k&lt;n)    then Action[k,#] = acc.<br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200712194947.jpg" alt=""></p></li></ol><h5 id="SLR-1-分析">SLR(1)分析</h5><p><a href="https://blog.csdn.net/hjc256/article/details/90573145">见CSDN</a></p><h5 id="LALR-1-分析">LALR(1)分析</h5><p><a href="https://blog.csdn.net/weixin_44225182/article/details/105599118">见CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双线部署你的个人博客</title>
      <link href="/posts/87a809ba/"/>
      <url>/posts/87a809ba/</url>
      
        <content type="html"><![CDATA[<h1>基于GitHub+Coding双线部署的Hexo静态博客搭建教程</h1><hr><h2 id="前言-2">前言</h2><p>双线部署是为了实现国内访问走Coding，国外访问走GitHub以保证静态博客的访问速度，且Coding和GitHub服务器并不在国内大陆，避免了备案的麻烦。<br>感谢酷安<a href="royce2019.github.io">@晴初_back</a>大佬的搭建教程，本文旨在记录本人的博客搭建过程并指出原教程的一些错误以防止新手掉坑，原教程请参考: <a href="https://royce2019.github.io/posts/13128.html">外部链接</a></p><ul><li>2022-04-05更新<ul><li>修正Coding连接问题</li></ul></li></ul><span id="more"></span><hr><h2 id="准备：">准备：</h2><ol><li>GitHub账号</li><li>Git</li><li>Node.js</li><li>Coding账号</li><li>一个域名</li></ol><hr><h2 id="GitHub仓库创建">GitHub仓库创建:</h2><p>在<a href="https://github.com/">GitHub</a>创建仓库，<a href="http://xn--yourname-wg0mk3cs44awx4aoa8253n.github.io">仓库名应该为yourname.github.io</a>，<font color=red size=4><strong>文章中的yourname均表示你的GitHub账号名</strong></font></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143505.jpg" alt="GitHub"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143524.jpg" alt="GitHub"></p><p>记得勾选xxx with a README</p><hr><h2 id="安装相关软件并连接GitHub：">安装相关软件并连接GitHub：</h2><h3 id="安装Git">安装Git</h3><p><a href="https://git-scm.com">Git</a>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br><a href="https://git-scm.com/downloads">Git下载</a><br>安装可以一路继续。<br>安装完成后在命令行(cmd)输入<code>git</code>查看是否成功，若提示‘ ‘git’是内部或外部命令，不是可运行的程序或批量处理文件。 ’则安装失败，建议百度 Git系统环境变量 或者重装Git。</p><hr><h3 id="安装Node-js">安装Node.js</h3><p><a href="https://nodejs.org/zh-cn/">Node中文官网地址</a>，安装后cmd中输入:</p><pre><code>node -v npm -v</code></pre><p>可以看到版本号<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143531.jpg" alt="GitHub"></p><hr><h3 id="连接GitHub">连接GitHub</h3><p>桌面右击后在菜单栏点击<strong>Git Bash Here</strong>这一栏<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143537.jpg" alt="GitHub"></p><p>然后输入：</p><pre><code>git config --global user.name '接你的GitHub用户名'git config --global user.email '接你的GitHub注册邮箱'</code></pre><p>再输入：</p><pre><code>ssh-keygen -t rsa -C '接你的GitHub注册邮箱'</code></pre><p>之后3个回车不设置密码，之后再在<code>C:\Users\Usersname\.ssh</code>中找到id_rsa.pub密钥文件用记事本打开并全选复制<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143548.jpg" alt="GitHub"></p><p>GitHub添加密钥，如图<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143554.jpg" alt="GitHub"></p><p>将复制的内容填入key栏中，title栏随意填，然后点下面的绿色按钮 Add SSH Key<br>在<strong>Git Bash</strong>中输入下面的内容来验证Github连接成功</p><pre><code>ssh -T git@github.com</code></pre><p>出现<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414143601.jpg" alt="GitHub"></p><p>则成功。</p><hr><h2 id="安装Hexo">安装Hexo</h2><p>在本地电脑创建一个文件夹用作博客的根目录，所有文件夹的名字应该尽量避免中文出现，然后进入博客根目录中右键进入<strong>Git Bash</strong><br>输入：</p><pre><code>npm install -g hexo-cli</code></pre><p>安装Hexo，然后初始化：</p><pre><code>hexo init</code></pre><p>你会发现根目录下多了很多文件，这些就是你博客的本地文件了，你以后可以在博客根目录下把本地博客推送到网上。</p><hr><h2 id="本地预览">本地预览</h2><p>输入以下命令预览你博客的效果：</p><pre><code>hexo generatehexo server</code></pre><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144539.jpg" alt="GitHub"></p><p>浏览器进入如图提示你的地址 <a href="http://localhost:4000">http://localhost:4000</a> 浏览博客，按 Ctrl+C 停止运行</p><hr><h2 id="部署">部署</h2><p>将本地博客部署到GitHub，进入博客根目录，找到配置文件_config.yml记事本打开，到最后deploy项修改，我的用户名Chen0495改为你自己的GitHub用户名。<br>coding那一行是双线部署部分，现在不写，或者先在该行开头打个 # 号注释掉：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144547.jpg" alt="GitHub"></p><p><font color="red" size="5">Coding改版后其仓库地址已经发生变化,请注意:</font><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img/20200809220218.png" alt="GitHub"></p><p>然后在<strong>Git Bash</strong>中输入：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>再依次输入命令：</p><pre><code>hexo clean  #清理缓存hexo generate  #监视文件变动并生成静态文件hexo deploy  #部署文件</code></pre><p>完成后你的博客就搭建完成了，它还太简陋，你可以继续学习相关操作来完善你的博客，你的博客的地址是 <code>yourname.github.io</code>,yourname是你的GitHub用户名。<br>之后我们继续将博客部署到Coding上，但在此之前，我认为你应该学些基本知识。</p><hr><h2 id="修改博客">修改博客</h2><p>_config.yml文件：</p><pre><code>title: Chen0495  #网站标题subtitle: description:   #网站描述keywords:   #网站关键词author:   #网站作者language: zh-CN  #语言timezone:</code></pre><p>后面还有条 url，修改成你自己的博客地址<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144553.jpg" alt="GitHub"><br>你的博客默认地址一般在 <a href="http://yourname.github.io/year/mouth/day/title_name">yourname.github.io/year/mouth/day/title_name</a> ，可以修改permalink项，比如我的是posts/:abbrlink/而有些是yourname.github.io/year/title_name。<br>其他的相关参数可自行了解，一般知道英文都能猜出来干嘛的。之后的相关教程可参考 <a href="https://royce2019.github.io/posts/13128.html">外部链接</a> 或者 百度，这里不再赘述。</p><hr><h2 id="Markdown">Markdown</h2><p>你以后的文章都会用Markdown语法编写，所以有必要深入学习下: <a href="https://guides.github.com/features/mastering-markdown/">Markdown</a> or <a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a><br>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p><hr><h2 id="双线部署">双线部署</h2><p>接下来就是双线部署了，GitHub访问实在太慢，所以我们将国内访问部署到 <a href="https://coding.net/">Coding</a> 上而境外访问走GitHub。<br>为了你的博客地址方便好记，我建议购买一个域名，以阿里云为例，我买了<code>.top</code>后缀的域名，首年￥9，之后26￥/年，之后相关操作均以阿里云为例。</p><hr><h3 id="Coding部署">Coding部署</h3><p>注册账号，选团队账号 <a href="https://coding.net/">Coding官网</a><br>1个人的团队也是团队嘛，5人以下免费使用，不需要管那个试用期，试用期到了也能继续用。<br>创建项目：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144558.jpg" alt="Coding"></p><p>选择代码托管:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144610.jpg" alt="Coding"></p><p>填写项目信息:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144617.jpg" alt="Coding"></p><p>去右下角的项目设置把静态网页选项打开:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144629.jpg" alt="Coding"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144652.jpg" alt="Coding"></p><p>然后返回并创建静态网站(惯例，Chen0495为你自己用户名):<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144704.jpg" alt="Coding"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144712.jpg" alt="Coding"></p><p>之后会给你一个你的博客的访问地址:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144722.jpg" alt="Coding"></p><p>但这个地址太难记了，所以我们自己买个好记的域名然后将其解析到这个地址，这样我们就只要记那个好记的域名就行了，而且域名除了后缀还能自定义，不香吗？<br><s>再找到那个SSH公钥</s><strong>用Ed25519算法生成另一个不同名公钥</strong>:<code>ssh-keygen -m PEM -t ed25519 -C &quot;your.email@example.com&quot;</code>，具体参考<a href="https://chen0495.top/posts/29f2c3fc/">Git连接Coding坑点</a><br><img src="https://img.chen0495.top/Chen0495/newpicgo/img2022/20220405172903.png" alt=""></p><p>记事本打开全选复制，在Coding中打开个人设置：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144729.jpg" alt="Coding"></p><p>填入Key，<font color=red size=4><strong>记得勾选永久有效!!!</strong></font><br>完成后连接Coding，<strong>Git Bash</strong>中输入:</p><pre><code>ssh -T git@e.coding.net</code></pre><p>成功后提示: <code>你好,你已经通过 SSH 协议认证...</code><br>接下来原教程有点错误，应该先解析Coding再解析GitHub，否则会因为GitHub是走的国外线路而证书申请失败。<br>进入你买域名的平台(示例使用阿里云)，进入控制台:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144735.jpg" alt="Aliyun"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144744.jpg" alt="Aliyun"></p><p>解析你购买的域名，一般要实名认证，认证下就好了，几个小时就过了:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414151945.jpg" alt="Aliyun"></p><p>然后填写信息，我们先解析Coding，原因上面也说了，记录类型 CNAME，主机记录 www，线路默认或者随便选，总之不要选境外，记录值填<strong>Coding给你的那个地址</strong>，<br>TTL是你修改后的响应时间，这里选10分钟<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414153242.png" alt="Aliyun"></p><p>现在获取我们域名的IPv4地址，打开cmd:</p><pre><code>ping '接Coding给你的博客地址'</code></pre><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414154224.jpg" alt="Aliyun"></p><p>复制’[ ]'内的IPv4地址，再添加一条记录:<br>记录类型 A,主机记录 @，线路同上，记录值填<strong>你刚刚复制的IPv4地址</strong>，TTL 10分钟。<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414154706.jpg" alt="Aliyun"></p><p>添加两条记录后去Coding打开项目，进入静态网站的设置，拉到最底的自定义域名，选择绑定新域名并填写<strong>你买的那个域名</strong><br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414155534.jpg" alt="Aliyun"></p><p><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414155544.jpg" alt="Aliyun"></p><p>可以开启强制HTTPS访问，再绑定一个www.开头的域名如上图，绑定两个后绑定首选域名，就在绑定新域名的旁边，选择不带www.的为首选然后将www.设置<br>为跳转至首选<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414162804.jpg" alt="Aliyun"></p><p><strong>然后在操作里选择申请证书！！！两个都要，直到证书状态正常。</strong><br>接着修改博客根目录的配置文件_config.yml，惯例修改用户名，修改deploy为:<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414144547.jpg" alt="Aliyun"></p><hr><h3 id="GitHub部署">GitHub部署</h3><p>现在部署GitHub，进入阿里云控制台的域名解析页面，添加一条记录，解析线路选<strong>境外</strong>，记录值填你的GitHub的仓库名：<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414163509.jpg" alt="Aliyun"></p><p>然后我们添加另一条记录，记录值为你ping 上面的GitHub仓库名的IPv4地址，线路依旧境外<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414163515.jpg" alt="Aliyun"></p><p>之后去GitHub找到你博客的仓库进入setting<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414164538.jpg" alt="GitHub"></p><p>一直向下滑动到GitHub Page页，填你买的域名，Save，等一会然后刷新就可以点强制HTTPS了<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414164545.jpg" alt="GitHub"></p><hr><h3 id="本地推送">本地推送</h3><p>然后我们将本地的博客推送到网页上面<br>博客本地根目录下打开 <strong>Git Bash</strong> 输入，以后修改博客后更新网页也是这3个命令</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>成功后你可以在Coding中看到相关记录<br><img src="https://img.chen0495.top/Chen0495/newpicgo/old_pic/2020/20200414165235.jpg" alt="Coding"></p><h3 id="一些重要提醒">一些重要提醒</h3><ol><li>除非你选择搭建在自己买的高配置服务器上并配套购买了CDN加速之类的功能,否则请使用比较简单且长期维护的主题(如fluid,next等);并在文章中插入压缩过的图片(<a href="http://xn--tinypng-c19ni39t.com">推荐tinypng.com</a>).</li><li>图床可以使用PicGo+GitHub并结合jsdelivr提供的免费cdn加速,教程参考<a href="https://blog.csdn.net/qq_36759224/article/details/98058240">🔗外部连接🔗</a> ,注意评论区哦,另外picgo有时会因为网络问题上传失败请百度某些玄学方法解决;</li><li>或者干脆用<a href="https://imgchr.com">🔗路过图床🔗</a>及其他图床.</li><li>在本地博客目录下source(非theme)文件夹下创建文本文件并在内写上你在github绑定的域名然后改文件名为CNAME,这样每次推送不用重新绑定域名.</li><li>文章的内容若格式不对,会造成无法推送,请在某些特殊字前加转义符,请注意.</li><li>博客的主题一般在github上搜hexo-theme,找星数多的比较好,其内有详细安装教程(有些是纯英文,自行选择)</li><li>推送次数过多会导致.git分支文件过大,如果你不在乎以前的版本可以直接删了.deploy_git和.idea并备份好你的配置文件、文章和主题文件，然后进行本文‘本地预览’章节后的‘部署’章节步骤，将备份好的文件放好即可.或者你可以选择按照百度到的操作.</li><li>GitHub对单个文件上传大小有限制.</li><li>遇到问题请Google,无法Google再Baidu</li></ol><hr><h2 id="结束">结束</h2><p>你的博客已经搭建完了，你可以访问你购买的域名来访问你的博客网站，<s>你会发现有时候会提示你你的网站不安全，那是因为你没有SSL安全证书，</s>  去完善你的博客吧！！！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> Blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
