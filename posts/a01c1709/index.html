

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Chen0495">
  <meta name="keywords" content="Python,C/C++,计算机网络">
  
    <meta name="description" content="第一章 - 网络体系结构 计算机网络的概念    是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。 直观理解为“网”：点（终端、路由等）和线（物理线路、无线网络等） 计算机网络的3种不同定义 上图不需要记,只需要知道三者的侧重点即可 广义观点只侧重资源共享；资源共享观点则侧重独立、互联、共享；透明观点只侧重整体性&#x2F;透明性">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络考研复习">
<meta property="og:url" content="https://chen0495.github.io/posts/a01c1709/index.html">
<meta property="og:site_name" content="Chen0495的空间站">
<meta property="og:description" content="第一章 - 网络体系结构 计算机网络的概念    是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。 直观理解为“网”：点（终端、路由等）和线（物理线路、无线网络等） 计算机网络的3种不同定义 上图不需要记,只需要知道三者的侧重点即可 广义观点只侧重资源共享；资源共享观点则侧重独立、互联、共享；透明观点只侧重整体性&#x2F;透明性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210701210022.png">
<meta property="article:published_time" content="2021-07-01T13:00:49.000Z">
<meta property="article:modified_time" content="2021-12-18T12:44:19.094Z">
<meta property="article:author" content="Chen0495">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="计网">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210701210022.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>计算机网络考研复习 - Chen0495的空间站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"chen0495.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":false,"baidu":"4cfdf1bbbfc14c67b6054b14a9f17c34","google":null,"gtag":"G-RETB4NG5L9","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?4cfdf1bbbfc14c67b6054b14a9f17c34";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  
    <!-- Google gtag.js -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.googletagmanager.com/gtag/js?id=G-RETB4NG5L9', function() {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-RETB4NG5L9');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Chen0495</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210701210022.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络考研复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-07-01 21:00" pubdate>
          2021年7月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          193 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机网络考研复习</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2021年12月18日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章-网络体系结构"><a href="#第一章-网络体系结构" class="headerlink" title="第一章 - 网络体系结构"></a>第一章 - 网络体系结构</h1><ol>
<li><p>计算机网络的概念<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210701210733.png" srcset="/img/loading.gif" lazyload alt="计算机网络概念">  </p>
<ul>
<li>是一个将分散的、具有独立功能的计算机系统，通过<font color=red>通信设备与线路</font>连接起来，由功能完善的<strong>软件</strong>实现<font color=green>资源共享</font>和<font color=green>信息传递</font>的系统。</li>
<li><font color=blue>直观理解为“网”：点（终端、路由等）和线（物理线路、无线网络等）</font></li>
<li>计算机网络的3种不同定义<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109071950860.png" srcset="/img/loading.gif" lazyload><ul>
<li><font color=blue>上图不需要记,只需要知道三者的侧重点即可</font></li>
<li>广义观点只侧重<strong>资源共享</strong>；资源共享观点则侧重<strong>独立、互联、共享</strong>；透明观点只侧重<strong>整体性&#x2F;透明性</strong>，意指网络作为一个网状系统不被人感知。</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机网络的功能：数据通信（<strong>最基本最主要的功能</strong>）、资源共享、分布式处理、可靠性、负载均衡。</p>
<ul>
<li>后两者可视为分布式处理的作用</li>
<li><font color=blue>选择题能选对就行</font></li>
</ul>
</li>
<li><p>计算机网路的组成：软件、硬件、协议（负责协调软硬件工作）。</p>
<ul>
<li><font color=blue>看看就行</font></li>
</ul>
</li>
<li><p>计算机网络的分类<font color=blue>（了解就行）</font></p>
<ul>
<li>按作用范围划分：广域网（WAN，几十公里~几千公里）、城域网（MAN，街区&#x2F;城区）、局域网（LAN，公司）、个人区域网（PAN，家庭）。</li>
<li>传播技术划分：广播式网络（广播技术，如：局域网）、点对点网络（交换技术，如：广域网）。</li>
<li>拓扑结构划分：总线形、星形、环形、网状形<br> <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210701211933.png" srcset="/img/loading.gif" lazyload alt="网络拓扑结构">  </li>
<li>其它的划分方法有（不重要）：<ul>
<li>按使用者分类： 公用网和专用网  </li>
<li>按交换技术分类： 电路交换（电话）、报文交换（存储转发）、分组交换（切分报文，分组转发）  </li>
<li>按传输介质分类： 有线（双绞线、同轴电缆）和无线（蓝牙、微波、无线电）</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机网络标准化及其相关组织：  <font color=blue>新大纲已删除</font>  </p>
</li>
<li><p>计算机网络性能指标<font color=blue>（要会计算！！！）</font> :</p>
<ul>
<li>速率（bit&#x2F;s）: 单位时间内通过的比特位数 </li>
<li>带宽（bit&#x2F;s）: 单位时间内<strong>最高</strong>可通过的比特位数<ul>
<li><em>注意是发射速率，要与传播速率区分开来，比如某设备间1s才允许传输1bit的数据，但其传播速率可能接近光速</em></li>
</ul>
</li>
<li>吞吐量: 单位时间内通过某个网络的数据量  </li>
<li>时延<font color=blue>重点</font>: <code>发送时延 + 传播时延 + 排队时延 + 处理时延</code>  <ul>
<li>发送时延, 又叫<strong>传输时延,与传播时延一字之差,注意区分</strong>,发送一串数据到链路上的时间。</li>
<li>传播时延, 是一个比特从链路一端到达另一端所用的时间。</li>
<li>排队时延, 数据进入路由器后，需要在路由器的输入队列中等待处理，然后还要在输出队列中等待转发。</li>
<li>处理时延, 是检查数据完整性、找到数据出口所用的时间</li>
</ul>
</li>
<li>时延带宽积: <code>传播时延 × 带宽</code>，即某段链路最多有多少个比特</li>
<li>往返时延RTT: 从开始发送, 到发送方收到接收方的确认信息所用时间</li>
<li>利用率: <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210701214826.png" srcset="/img/loading.gif" lazyload alt="利用率"></li>
</ul>
</li>
<li><p>网络分层:</p>
<ul>
<li>分层原则<font color=blue>(不重要)</font></li>
<li>基本概念：<ul>
<li>实体：可以接收和发送信息的硬件或者软件进程。</li>
<li>不同机器上的同一层叫对等层，同一层的实体叫对等实体。</li>
<li>下次实现的功能为上层服务（从下往上1到n层）</li>
<li>SDU服务数据单元: 就是有效数据,本来要传输的那部分数据.  </li>
<li>PCI协议控制信息: 就是规定了协议需要怎么操作的信息.  </li>
<li>PDU协议数据单元: SDU + PCI, 对等层次之间传送的数据单位.</li>
</ul>
</li>
<li>分层含义<font color=blue>(理解)</font>：第一层（最底下）为第二层提供服务，第二层为第三层提供服务（第二层的功能实现依赖第一层），第三层为第四层提供服务（第三层的功能实现直接依赖第二层，间接依赖第一层）…以此类推。</li>
</ul>
</li>
<li><p>协议、接口、服务的概念<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>协议：对等实体间的通信规则，结构上看是水平的。<ul>
<li><em>不对等实体间没有协议</em></li>
</ul>
</li>
<li>接口(也叫<strong>服务访问点</strong>)：同一计算机内相邻两层之间的通信规则，结构上看是垂直的。<ul>
<li><em>不能跨层定义接口</em></li>
</ul>
</li>
<li>服务：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109082024566.png" srcset="/img/loading.gif" lazyload><ul>
<li>TCP：面向连接 &amp; 可靠</li>
<li>UDP：无连接 &amp; 不可靠</li>
<li>PPP：面向连接 &amp; 不可靠</li>
<li>无连接 &amp; 可靠：在UDP基础上实现</li>
</ul>
</li>
</ul>
</li>
<li><p>OSI参考模型<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702152844.png" srcset="/img/loading.gif" lazyload alt="OSI">  </p>
<ul>
<li><strong>除物理层外,都逐层需要添加控制信息</strong></li>
<li>端到端和点到点<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211210757.png" srcset="/img/loading.gif" lazyload></li>
<li>物理层<ul>
<li>传输单位：比特流</li>
<li>协议：EIA-232C、EIA&#x2F;TIA RS-449、CCITT的X2.1等（大于五个字母…）</li>
</ul>
</li>
<li>数据链路层<ul>
<li>传输单位：帧</li>
<li>需要完成：组帧、差错控制、流量控制、传输管理（后三个都理解为对帧的控制）</li>
<li>协议：SDLC、HDLC、PPP、STP、帧中继</li>
</ul>
</li>
<li>网络层：<ul>
<li>传输单位：数据报</li>
<li>IP数据报在下层数据链路层被拆分组装成帧</li>
<li>比链路层后三个多了拥塞控制，因为网络层需要考虑网络波动问题</li>
<li>协议：IP、IPX、ICMP、ARP、RARP、OSPF</li>
</ul>
</li>
<li>传输层：<ul>
<li>传输单位：报文段（TCP）或者用户数据报（UDP）</li>
<li>资源子网与通信子网的桥梁</li>
<li>协议：TCP、UDP</li>
</ul>
</li>
<li>会话层：<ul>
<li>负责建立、管理、撤销会话</li>
<li><strong>使用校验点可实现断线续传</strong></li>
</ul>
</li>
<li>表示层：<ul>
<li>负责数据压缩、加密、解密、数据格式变换。</li>
</ul>
</li>
<li>应用层：<ul>
<li>为特定网络应用提供访问OSI环境的手段</li>
<li>协议：FTP、SMTP、HTTP</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP&#x2F;IP参考模型<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702155201.png" srcset="/img/loading.gif" lazyload>  </p>
</li>
<li><p>TCP&#x2F;IP和OSI的区别<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702155258.png" srcset="/img/loading.gif" lazyload alt="异同"> </p>
<ul>
<li>网络层是点到点，所以必需要无连接；而传输层是端到端，需要面向连接。</li>
<li>TCP&#x2F;IP注重传输层,而OSI注重网络层</li>
</ul>
</li>
<li><p>考研通用模型<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702155705.png" srcset="/img/loading.gif" lazyload alt="五层参考模型">  </p>
</li>
<li><p>报文流与字节流的区别（面向连接且可靠）：报文流会区分边界，字节流不会。例如发送<code>1024B × 2</code>的报文数据，报文流会接收2个1024B的报文，字节流会把接收的2048B作为整体。</p>
</li>
<li><p>网桥、交换机（多接口网桥）都是链路层设备；路由器是网络层设备；中继器，集线器（多口中继器）是物理层设备。<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210711202718.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>因特网是广域网、以太网（采用CSMA&#x2F;CD）是局域网。</p>
</li>
</ol>
<div class="note note-success">
            <p>习题：<br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109082110195.png" srcset="/img/loading.gif" lazyload alt="16"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211135937.png" srcset="/img/loading.gif" lazyload alt="A16"></p><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702160353.png" srcset="/img/loading.gif" lazyload alt="23"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702160632.png" srcset="/img/loading.gif" lazyload alt="A23">  </p><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702162206.png" srcset="/img/loading.gif" lazyload alt="17"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702162218.png" srcset="/img/loading.gif" lazyload alt="A17">  </p><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702164259.png" srcset="/img/loading.gif" lazyload alt="2"><br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702164927.png" srcset="/img/loading.gif" lazyload alt="A2"></p>
          </div>

<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 - 物理层"></a>第二章 - 物理层</h1><ol>
<li><p>物理层的特性<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210702170012.png" srcset="/img/loading.gif" lazyload alt="物理层特性"> </p>
</li>
<li><p>编码和信道</p>
<ul>
<li>编码：模拟信号➡数字信号；调制：数字信号➡模拟信号</li>
<li>信道：是信号的传输媒介，其有方向。所以一台物理线路往往包含两条信道（发送和接收）。<ul>
<li><code>信源、信道、信宿</code>➡<code>头、中介、尾</code></li>
</ul>
</li>
<li>数字信道上的传输（基带传输）、模拟信道上的传输（宽带传输，例子当然是宽带-光信号…）</li>
</ul>
</li>
<li><p>信道的三种通信方式：  </p>
<ul>
<li>单工通信，只有一个方向的通信而没有反方向的交互。<strong>需要一条信道。</strong></li>
<li>半双工&#x2F;双向交替通信，通信双方都能收发信息，但不能同时发送和接收。<strong>需要两条信道</strong>，信道是有方向的，所以是两条。</li>
<li>全双工&#x2F;双向同时通信，通信双方可以同时发送和接收信息。<strong>需要两条信道。</strong></li>
</ul>
</li>
<li><p>奈氏准则（奈奎斯特定理）<font color=blue>(重点！！！)</font>：理想低通（无噪声、带宽有限）环境下，极限码元传输速率为2W波特，则极限传输速率为<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109082203384.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>注意区分带宽V和<strong>采样频率</strong>!!!采样频率不需要乘上2.</li>
</ul>
</li>
<li><p>香农公式<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109082205049.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>注意分贝表示的信噪比：<code>S/N = 100，10 * log(10,S/N) = 20dB = 20分贝</code></li>
</ul>
</li>
<li><p>数据编码方式<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109091911405.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>归零编码（RZ）：<ul>
<li>图中描述的是单极性归零码<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109091927540.png" srcset="/img/loading.gif" lazyload></li>
<li>双极性归零码<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109091939281.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>非归零编码（NRZ）<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109092002029.png" srcset="/img/loading.gif" lazyload><ul>
<li>对于计算机网络，宁愿利用这根传输线传输数据信号，也不愿意用来传输时钟信号，因此，不归零编码存在时钟同步问题</li>
</ul>
</li>
<li>反向非归零编码（NRZI）<ul>
<li>信号翻转代表0，不变代表1</li>
<li>例如USB2.0采用NRZI编码</li>
</ul>
</li>
<li>曼彻斯特编码<ul>
<li>下沿表示1，上沿表示0</li>
<li>以太网使用</li>
</ul>
</li>
<li>拆分曼彻斯特编码<ul>
<li>前半个码元和上一个码元的后半部分不同就是1，相同就是0</li>
<li>局域网、抗干扰</li>
</ul>
</li>
<li>4B&#x2F;5B编码<ul>
<li>发射5位（32种状态）数据，其中16种状态（4位映射到5位）是有效数据，其它16种状态是控制信号</li>
</ul>
</li>
</ul>
</li>
<li><p>数据调制方式<font color=blue>(重点！！！)</font><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109092010179.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>混合调制方式：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109092011430.png" srcset="/img/loading.gif" lazyload><ul>
<li>习题<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109092014145.png" srcset="/img/loading.gif" lazyload></li>
<li><code>4 * 4 = 16</code>种状态，表示需要4个比特位，所以<code>速率 = 1200 * 4 = 4800bit/s</code></li>
</ul>
</li>
<li>PCM调制（却是编码、对音频信号编码）模拟信号编码为数字信号时，为了使信号不失真，<code>f采样频率 ≥ 2f信号频率</code></li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109092020992.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li><p>电路交换、报文交换、分组交换<font color=blue>(重要，但简单且没什么细节，暂时不重要)</font></p>
<ul>
<li>分组交换又分为：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211628975.png" srcset="/img/loading.gif" lazyload><ul>
<li>数据报服务方式</li>
<li>虚电路服务方式</li>
</ul>
</li>
</ul>
</li>
<li><p>传输介质<font color=blue>(不重要)</font></p>
<ul>
<li>双绞线：绞合可以抗干扰<ul>
<li>距离过大时需要放大器放大衰减的信号，以及中继器整形失真的信号。</li>
</ul>
</li>
<li>同轴电缆：抗干扰、传输距离远，速率更高，也更贵</li>
<li>光纤</li>
<li>无线电波、微波、红外和激光、卫星</li>
</ul>
</li>
<li><p>物理层接口的特性：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109092152195.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>中继器与集线器<font color=blue>重要</font>：</p>
<ul>
<li>中继器<ul>
<li>放大信号、延长网络长度</li>
<li>不能连接速率不同的局域网</li>
<li>5-4-3规则：互相串联的中继器个数不能超过4个，形成的5段通信介质中只有三段可以连接计算机，其它2段只能用作扩展通信范围。<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109112037131.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>集线器（Hub）<ul>
<li>多口中继器；放大信号、延长网络长度</li>
<li>广播式、半双工</li>
<li>不能分割广播域和冲突域</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="note note-success">
            <p>习题<br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210704212925.png" srcset="/img/loading.gif" lazyload alt="例6"><br><font color=red size=4>解：</font>  </p><ul><li>发送延时<ul><li>源点发送延时：（（L&#x2F;p）*（h+p））&#x2F; b；</li><li>中继节点发送延时：（h+p）&#x2F;b * （k-1）；<font color=red size=4>注意在<strong>分组转发</strong>当中<strong>每个中继只延迟了一个分组</strong>的时间</font>。</li></ul></li><li>传播延时<ul><li>d * k</li></ul></li><li>连接建立时间<ul><li>s</li></ul></li><li>处理延时<ul><li>m *（k-1）</li></ul></li></ul><p><font color=red size=4>总时间相加即可</font>  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210704214241.png" srcset="/img/loading.gif" lazyload alt="例3">  </p><ol><li>传播时延 20*2 μs，处理时延 35 μs，发送时延 1000*2 μs，总 2075 μs。  </li><li>发送时延（源点 1000 μs、中继 500 μs），传播时延 20*2 μs，处理时延 35 μs，总时延 1575 μs。</li></ol><hr><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211606429.png" srcset="/img/loading.gif" lazyload></p><ul><li>没有波特率,无法用奈氏准则!!!</li></ul>
          </div>

<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 - 数据链路层"></a>第三章 - 数据链路层</h1><ol>
<li><p>数据链路层为网络层提供：</p>
<ul>
<li>无确认的无连接服务：不建立链路、收到不确认、丢失不重发</li>
<li>有确认的无连接服务：不建立连接、受到确认、丢失重发</li>
<li>有确认的面向连接服务：建立链接、收到确认才能继续发下一帧</li>
</ul>
</li>
<li><p>帧定界、帧同步和透明传输<font color=blue>(不重要)</font>:<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705174614.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>帧定界：组帧时添加头尾部控制信息，也能确认帧的边界。</li>
<li>帧同步：接收方应能够确认<strong>二进制比特流</strong>中帧的始末。</li>
<li>透明传输：数据中可能出现刚好等于控制信息的二进制比特串，需要处理。</li>
</ul>
</li>
<li><p>组帧：<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>字符计数法：头部信息中包含了帧的长度信息（错一个后面帧全错）<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211721252.png" srcset="/img/loading.gif" lazyload><ul>
<li>注意是字符(每个字符8位二进制位)</li>
</ul>
</li>
<li>字符填充的首尾定界符法：使用特定字符来界定（数据中的特殊字符前插入<strong>转义字符DEL</strong>标记）</li>
<li>零比特填充的首位标记法：用01111110标记始末（发送：数据中遇到5个1在后面添0；接收数据中遇到5个1在后面减0）</li>
<li>违规编码法：<ul>
<li>只适用于冗余编码，因为只有冗余编码有剩余位置表示违规编码（界定符）</li>
<li>例如曼彻斯特编码，高-低是1，低-高是0；违规编码1为高-高，0为低-低。</li>
<li>例如：局域网IEEE 802标准</li>
</ul>
</li>
<li>习题<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211723233.png" srcset="/img/loading.gif" lazyload><ul>
<li>答案<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109211723276.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
<li><p>差错控制<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>差错由噪声干扰形成，内部噪声可以通过提高信噪比解决，外部噪声就必须要有差错控制</li>
<li>奇偶校验码：奇校验码（在比特串末添加一位0或1使得1的个数是奇数）、偶校验码（在比特串末添加一位0或1使得1的个数是偶数）</li>
<li>循环冗余码（CRC）：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705194226.png" srcset="/img/loading.gif" lazyload><ul>
<li><em>循环冗余码由纠错功能，但数据链路层仅实现了检错功能，检测到帧出错就丢弃。因此还不算“可靠传输”而是“确认传输”</em></li>
</ul>
</li>
<li>海明码：<ul>
<li>纠错能力1位、检错能力2位</li>
<li>校验码的长度r：<code>2^r ≥ m+r+1</code></li>
<li>例：发送数据D &#x3D; 1100<ol>
<li><code>m=4</code>，算出<code>r=3</code></li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705202354.png" srcset="/img/loading.gif" lazyload></li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705202601.png" srcset="/img/loading.gif" lazyload><ul>
<li>对于x4来说，4、5、6、7的值分别是x4、0、1、1,采用偶校验则x4应当是0；</li>
<li>同理x2是0，x1是1。</li>
</ul>
</li>
<li>检错<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705203612.png" srcset="/img/loading.gif" lazyload> </li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705203754.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流量控制<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>ARQ：自动重传请求。停止-等待ARQ、后退N帧ARQ、选择重传ARQ。</li>
<li>停止-等待协议：每次传输一帧，只有收到确认信号之后才能发送下一帧<ul>
<li>相当于窗口大小为1的滑动窗口协议</li>
<li>发送一个帧后发送方不能马上丢弃（出错时方便重传），所以需要一个帧缓冲区存放尚未确认帧的副本。</li>
</ul>
</li>
<li>滑动窗口控制协议：<br>  -滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为<strong>发送窗口</strong>；同时，接收方也维持了一个连续的允许接收的帧的序号，称为<strong>接收窗口</strong>。<ul>
<li>发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。</li>
<li>不同的滑动窗口协议窗口大小一般不同。</li>
<li>发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。<br>  <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705214154.png" srcset="/img/loading.gif" lazyload alt="滑动窗口协议-发送"><br>  <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705214655.png" srcset="/img/loading.gif" lazyload alt="滑动窗口协议-接收"></li>
<li>在<strong>发送端</strong>，每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接受方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送。</li>
<li>在<strong>接受端</strong>，当收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接受窗口之外则一律丢弃。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705215031.png" srcset="/img/loading.gif" lazyload alt="协议"></li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210705215142.png" srcset="/img/loading.gif" lazyload alt="知识点"></li>
</ul>
</li>
<li>后退N帧协议（GBN）<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210706152648.png" srcset="/img/loading.gif" lazyload alt="GBN"><br>  <font color=“#4D79C0” size=4><em>具体实现步骤见上面的滑动窗口协议</em></font><ul>
<li>发送方发送<code>0</code>，然后接收方收到<code>0</code>后发送一个确认帧，并且接收方的接收窗口向后一位，最后发送方收到确认帧后也向后一位。  </li>
<li><strong>设想一种特殊情况，即接收窗口收到了<code>1、2、3</code>并发送了确认帧，但<code>1、2</code>号确认帧延迟了，这时发送方收到了<code>3</code>的确认帧，这时不需要等待<code>1、2</code>确认帧，直接将发送窗口移到数据<code>3</code>之后即可</strong>。这种情况叫做<font color=red size=5>累计确认</font>。</li>
<li><strong>如果超时，会发送所有尚未被确认且已发送的帧，如接着上面这种情况，确认<code>3</code>之后窗口从数据<code>4</code>开始，这时发送窗口发送了<code>4,5,6,7,0,1</code>数据，且收到了<code>6</code>号帧,窗口开始位移动到7,此时发送超时时间,就要重传未确认的已发送的<code>7,0,1</code></strong></li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210706160637.png" srcset="/img/loading.gif" lazyload alt="总结"></li>
</ul>
</li>
<li>选择重传协议（SR）<ul>
<li>与GBN不同的是，GBN的接收端按序确认，虽然可以连续接收然后才确认，但假如前面的帧出错，后面的帧都要丢弃；<br>  而SR则只重传出错的帧，但这就需要一个额外的缓冲区暂存未按序接收的数据帧。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210706173049.png" srcset="/img/loading.gif" lazyload alt="总结"></li>
</ul>
</li>
<li>窗口大小：<ul>
<li>无论GBN还是SR，其<code>发送窗口大小 + 接收窗口大小 = 2^n</code></li>
<li>GBN:<code>接收窗口1，发送窗口(2^n)-1</code></li>
<li>SR:<code>接收窗口 = 发送窗口 = 2^(n-1)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>信道划分</strong>介质访问控制<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>介质访问控制（MAC）子层：用于决定广播信道中信道分配</li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109112241763.png" srcset="/img/loading.gif" lazyload></li>
<li>信道划分介质访问控制：频分复用（FDM）、时分复用（TDM）、波分复用（WDM）、码分复用（CDM，采用不同编码方式区分各路原始信号）<ul>
<li>码分多址(Code Division Multiple Access. CDMA)<ul>
<li>每比特时间被分成农个更短的时间槽,称为码片(Chip)</li>
<li>每个站点被指定一个唯一的和位代码或码片序列。</li>
<li>发送1时,站点发送码片序列;发送0时,站点 发送码片序列的反码。</li>
<li>为从信道中 分离出各路信号,要求各个站点的码片序列相互正交。</li>
<li><strong>例子</strong><ul>
<li>站点 A、B 同时发送给 C</li>
<li>码片由计算机分配（题目中给出）</li>
<li>若 A 站点的芯片序列为 (-1 -1 -1 +1 +1 -1 +1 +1)，发送这个比特串就表示发送1，发送其反码就是0</li>
<li>且 B 站点的芯片序列为 (-1 -1 +1 -1 +1 +1 +1 -1)，发送这个比特串就表示发送1，发送其反码就是0</li>
<li>验证正交：A ∙ B &#x3D; sum(Ai * Bi) &#x3D; (1 + 1 - 1 -1 + 1 - 1 + 1 - 1) &#x3D; 0，只有只有正交的码片才能同时发送。</li>
<li>当 A 在链路中发送数据时，发送 1 (-1 -1 -1 +1 +1 -1 +1 +1) ，B 发送 0 (+1 +1 -1 +1 -1 -1 -1 +1)<strong>反码</strong>；</li>
<li>则，在链路中的信号叠加为 (0 0 -2 2 0 -2 0 2);</li>
<li>当 C 收到这个叠加的序列后，想获得 A 的数据，则将收到的序列与A的序列点积，得 1。（因为是计算机给出码片，所以A和B的码片，C都知道）</li>
<li>同理，想获得 B 的数据时，点积B的序列获得 -1 ，代表0。</li>
</ul>
</li>
</ul>
</li>
<li>统计时分复用（STDM）：<ul>
<li><em>是TDM的一种改进,它采用STDM帧,STDM帧并不固定分配时隙,而按需动态地分配时隙,当终端有数据要传送时,才会分配到时间片,因此可以提高线路的利用率。</em></li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210706185005.png" srcset="/img/loading.gif" lazyload alt="统计时分多路复用"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>随机访问介质访问控制<font color=blue>(超重点！！！)</font>：</p>
<ul>
<li>ALOHA协议: 想发就发，不检测线路，发生冲突（一段时间没收到确认就认为冲突）就重发。<strong>冲突后等待一段时间才重发</strong>。<ul>
<li>时隙ALOHA协议：时间片同步，规定只有每个时隙开始时才能发送一个帧<ul>
<li>一个时隙发送完一个帧，防止像纯ALOHA协议一样上个帧还在线路传输过程中就发送从而碰撞。</li>
</ul>
</li>
</ul>
</li>
<li>CSMA协议（Carrier Sense Multiple Access、载波侦听多路访问）：<ul>
<li>1-坚持CSMA：<ol>
<li>先检测线路（信道）</li>
<li>空闲则发送帧</li>
<li>忙则<strong>持续侦听</strong>，同时<strong>一直侦听线路直到空闲</strong></li>
<li>发生冲突则<strong>随机</strong>等待一段时间再发送<ul>
<li>A发出帧还未到达目的地，B会检测到空闲而发帧，从而冲突。</li>
<li>忙时A、B等待，空闲时A、B同时侦听到空闲，同时发送帧，从而冲突。</li>
</ul>
</li>
</ol>
</li>
<li>非坚持CSMA：<ol>
<li>先检测线路</li>
<li>空闲则发送帧</li>
<li>忙则<strong>放弃侦听</strong>，<strong>等待一段随机时间后再侦听线路</strong></li>
<li>发生冲突则<strong>随机</strong>等待一段时间再发送</li>
</ol>
</li>
<li>p-坚持CSMA：<ol>
<li>先检测线路</li>
<li>空闲则以概率p发送数据，以1-p概率推迟到下一个时延</li>
<li>忙则<strong>持续侦听</strong>，直到空闲</li>
<li><strong>发生冲突会坚持把帧发完</strong>，然后<strong>随机</strong>等待一段时间再发送</li>
</ol>
</li>
</ul>
</li>
<li>CSMA&#x2F;CD协议（CSMA with Collision Detection、载波侦听多路访问&#x2F;碰撞检测）：<ul>
<li>适合总线型或半双工网络环境</li>
<li>思想：<ul>
<li>载波帧听：发送数据前先侦听是否空闲</li>
<li>碰撞检测：边发送数据边检测侦听（信道电压变化），<strong>发生冲突时帧的发送立即停止</strong></li>
</ul>
</li>
<li><strong>最小帧长</strong><ul>
<li><code>最小帧长 = 总线传播时延 * 数据传输率 * 2</code></li>
<li>A发送数据到B，最迟2倍传输时延即可检测出有没有碰撞。<strong>那么为了确保发送站在发送数据的同时能够检测到碰撞</strong>，则发送时延应该至少要2倍传输时延，然后推出上述公式。</li>
</ul>
</li>
<li>二进制指数退避算法解决碰撞<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709200833.png" srcset="/img/loading.gif" lazyload alt="截断二进制指数规避算法"></li>
</ul>
</li>
<li>CSMA&#x2F;CA协议CSMA with Collision Avoidance、载波侦听多路访问&#x2F;碰撞避免）：<ul>
<li><font color=blue>王道的思维导图有问题！！！以书上为准</font></li>
<li><strong>用于无线网络，IEEE 802.11</strong></li>
<li><strong>并非完全避免碰撞，而是尽可能减少</strong></li>
<li>因为不采用碰撞检测（依然有信道忙检测），所以发送碰撞时帧会继续发送!</li>
<li>发送一帧，收到确认再发送下一帧。</li>
<li><strong>工作原理</strong>：<ol>
<li>发送数据前检测信道空闲。</li>
<li>空闲则发送RTS（Request to send，请求发送）帧，RTS包括源地址、目的地址、下一帧的发送持续时间等信息；忙则等待。</li>
<li>接收端收到RTS后，发送CTS（Clear to send）帧，告诉发送方准备好接收。</li>
<li>发送端收到CTS，开始发送数据帧（同时预约信道，发送方告诉所有其它站点自己要发多久，避免冲突）<ul>
<li>与CD协议不同！！！CD协议只有冲突时才使用退避算法，CA协议除了发送第一个数据帧以外都需要等待一个时隙然后使用退避算法</li>
</ul>
</li>
<li>接收端收到数据帧后，进行CRC检验，正确则发送ACK帧</li>
<li>发送方收到ACK帧后发送下一帧，超时未收到则重发到上限次数（发送推迟时间：二进制指数退避算法）</li>
</ol>
</li>
</ul>
</li>
<li>CD与CA协议的区别：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141357249.png" srcset="/img/loading.gif" lazyload alt="CD/CA"></li>
</ul>
</li>
<li><p>轮询访问介质访问控制：</p>
<ul>
<li>轮询访问MAC协议<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709204205.png" srcset="/img/loading.gif" lazyload alt="轮询协议思想"></li>
<li>令牌访问协议<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709204248.png" srcset="/img/loading.gif" lazyload alt="令牌传递协议"></li>
</ul>
</li>
<li><p>局域网工作在OSI下两层,广域网工作在OSI下三层</p>
</li>
<li><p>局域网相关<font color=blue>(重点！！！)</font></p>
<ul>
<li>三种特殊局域网（实际生活中）<ul>
<li>以太网（逻辑总线形、物理星形或拓展星形）</li>
<li>令牌环网（逻辑环形、物理星形）</li>
<li>FDDI（光纤分布数字接口，IEEE802.5，逻辑环形、物理双环）</li>
</ul>
</li>
<li>IEEE 802协议<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709212516.png" srcset="/img/loading.gif" lazyload alt="IEEE 802">  </li>
<li>LLC子层和MAC子层（都是链路层子层）<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709212649.png" srcset="/img/loading.gif" lazyload alt="链路层子层"><ul>
<li>区分：看功能是向上层（网络层）提供服务还是使用下层（物理层）的功能。</li>
</ul>
</li>
<li>以太网（IEEE 802.3）<ul>
<li>局域网的一种</li>
<li>逻辑总线形、物理星形</li>
<li>无连接，不可靠（尽最大努力交付、纠错由上层完成）</li>
<li>传输介质<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141507525.png" srcset="/img/loading.gif" lazyload alt="传输介质"></li>
<li>10Base-T以太网<font color=blue>(超重点！！！)</font><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709213817.png" srcset="/img/loading.gif" lazyload alt="10BASE-T以太网"></li>
<li>MAC地址：48位，前24位代表厂家；后24位厂家自己指定，常为6个16进制数，如<code>02-60-8c-e4-b1-21</code></li>
<li>以太网的MAC帧<font color=blue>(超重点！！！)</font><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141528399.png" srcset="/img/loading.gif" lazyload><ul>
<li>地址（6字节、48bit）、类型（2字节，指定数据交由哪个协议实体）、数据（46<del>1500；46：CSMA&#x2F;CD的最短帧长为64B，首尾部占18B；1500：规定如此，没有为什么）、填充（0</del>46B，防止帧太短，达不到最短帧长）、校验码FCS（4B，CRC校验，校验除自身的整个MAC帧，不校验物理层加的前导码）</li>
<li>MAC帧的发送有时隙，所以不需要帧结束定界符（有帧开始定界符，物理层加上），但不是没有尾部，数据链路层既要加首部也要加尾部。</li>
<li>其与IEEE 802.3的区别在于：<ul>
<li>802.3的第三个字段是<strong>长度&#x2F;类型</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>高速以太网：<ul>
<li>100BASE-T以太网：<ul>
<li>100Mb&#x2F;s、使用CSMA&#x2F;CD协议（半双工）、支持全双工和半双工、802.3 MAC帧</li>
</ul>
</li>
<li>吉比特以太网<ul>
<li>1Gb&#x2F;s、使用CSMA&#x2F;CD协议（半双工）、支持全双工和半双工、802.3 MAC帧</li>
</ul>
</li>
<li>10吉比特以太网<ul>
<li>10Gb&#x2F;s、光纤、只支持全双工（因此不使用CSMA&#x2F;CD）、802.3 MAC帧</li>
</ul>
</li>
</ul>
</li>
<li>无线局域网（IEEE 802.11、WIFI）<ul>
<li>有固定基础设施的无线局域网：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709221942.png" srcset="/img/loading.gif" lazyload alt="有固定基础设施无线局域网"> <ul>
<li>最小构件是基本服务集BSS</li>
<li>一个基本服务集包含一个基站和若干移动站</li>
<li>所有站在本BSS内可以直接通信，BBS外通过本BBS基站转发</li>
</ul>
</li>
<li>无固定基础设施的无线局域网<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210709222125.png" srcset="/img/loading.gif" lazyload alt="无固定基础设施移动自组织网络"><ul>
<li>移动站地位平等，自组织起的临时网络；中间节点都是转发结点，都有路由功能</li>
<li>具有自己特定的路由选择协议，不与因特网相连</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202112182040909.png" srcset="/img/loading.gif" lazyload><ul>
<li>去头发中尾补(目的,源,AP)</li>
</ul>
</li>
</ul>
</li>
<li><font color=blue>(已删！！！)</font> <del>令牌环网（IEEE 802.5）</del> <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141606093.png" srcset="/img/loading.gif" lazyload alt="令牌环网"><ul>
<li>令牌环网的每一站都与环接口干线耦合器（TCU）相连，帧由TCL转发。</li>
<li>空闲时转发令牌，需要发送数据时（有令牌）将令牌变为数据帧发送出去。</li>
<li>发送完数据后，发送站重新产生一个令牌。</li>
</ul>
</li>
<li><font color=blue>(新增！！！)</font>VLAN基本概念与基本原理：（待补）</li>
</ul>
</li>
<li><p>广域网</p>
<ul>
<li>PPP拨号协议：<ul>
<li>串行直连（点对电）线路、面向字节、以SLIP协议为基础</li>
<li>只支持全双工、不可靠（帧无编号、确认）</li>
<li>支持同步、异步线路</li>
<li>组成：<ul>
<li>链路控制协议(LCP): 一种扩展链路控制协议,用于建立、配置、测试和管理数据链路。</li>
<li>网络控制协议(NCP)。PPP协议<strong>允许同时采用多种网络层协议</strong>,每个不同的网络层协议要用一个相应的NCP来配置,为网络层协议建立和配置逻辑连接。</li>
<li>—个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分,这个信息部分的长度受最大传送单元(MTU)的限制。</li>
</ul>
</li>
<li>PPP帧格式<font color=blue>(重点！！！)</font><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141619652.png" srcset="/img/loading.gif" lazyload><ul>
<li>标志字段：规定7E，前后各一个字节；地址字段：一个字节，规定为0xFF；控制字段一个字节，规定为0x03；协议字段：2B，说明信息部分运载的是什么分组（0x0021表示IP数据报）；校验字段：2B，校验地址、控制、协议、信息字段（没有头尾部标志字段）</li>
<li>点对点传输，不需要介质访问控制（相当于专用线路），所以不采用CSMA&#x2F;CD协议，<strong>信息字段自然也没有最小帧长限制</strong></li>
<li>信息字段歧义字符处理：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141632948.png" srcset="/img/loading.gif" lazyload alt="歧义字符处理"></li>
</ul>
</li>
</ul>
</li>
<li><font color=blue>(已删！！！)</font> <del>HDLC协议</del><font color=blue><del>(重点！！！)</del></font><ul>
<li>面向比特、全双工、可靠传输（帧有编号和确认）</li>
<li><strong>主站、从站、复合站</strong></li>
<li>响应方式：<ul>
<li>正常响应方式。这是一种非平衡结构操作方式,即主站向从站传输数据,从站响应传输,但从站只有在收到主站的许可后,才可进行响应。<ul>
<li>非平衡（响应）：一主一从</li>
</ul>
</li>
<li>异步平衡方式。这是一种平衡结构操作方式。在这种方式中,每个复合站都可以进行对另一站的数据传输。<ul>
<li>平衡：两端结点平等</li>
</ul>
</li>
<li>异步响应方式。这是一种非平衡结构操作方式。在这种方式中,从站即使未受到主站的允许,也可进行传输。</li>
</ul>
</li>
<li>HDLC帧：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210711184341.png" srcset="/img/loading.gif" lazyload alt="HDLC的帧格式"><ul>
<li><em>帧的字段不一定要记, 但帧格式的这三种类型一定要背下</em></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>广域网、局域网、因特网、以太网、互联网<font color=blue>(重点！！！)</font>：</p>
<ul>
<li><code>互联网 = 广域网 + 局域网</code><ul>
<li>局域网可以连接不同类型的网络，广域网不能</li>
</ul>
</li>
<li>因特网：全球最大的互联网</li>
<li>以太网是局域网的一种</li>
</ul>
</li>
<li><p>网桥和交换机<font color=blue>(重点！！！)</font></p>
<ul>
<li><strong>两个或多个以太网通过网桥连接后，就成了覆盖范围更大的以太网，原来的以太网就叫做网段</strong></li>
<li>网桥工作在MAC子层，可以隔离冲突域（A网段的冲突不会影响B网段）</li>
<li>支持不同协议（在网桥进行协议转换）；具有缓冲功能。</li>
<li>工作原理：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141707360.png" srcset="/img/loading.gif" lazyload alt="工作原理"><ol>
<li>计算机A发送数据到B：采用广播方式（总线形），B会收到，网桥B1也会收到；但B1发现目的地址和源地址网段相同，因此丢弃信息，只有B能收到。</li>
<li>计算机A发送数据到E：广播信息到网桥B1，B1根据网桥表转发数据到下一个网段，然后数据帧到达B2，B2根据网桥表发送给下一个网段，然后到达E。</li>
<li>计算机A发送数据到B，同时B发送数据到A或者E，发生冲突。</li>
<li>计算机A发送数据给B，同时C发送数据给D，因为所属不同网段所以不会发生冲突。</li>
</ol>
</li>
<li>网桥的<strong>路径选择</strong>算法：<ul>
<li>透明网桥（转发路径由网桥确定，只负责下一站），通过自学习实现局部最佳。<ul>
<li>思想：站A发出的帧从网桥的某个端口到达某个网桥，那么沿反方向，帧从该端口发出一定能到A。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141726324.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>源路由网桥（由发送数据的源站负责选择路径，网桥只根据帧控制信息对帧进行接收和转发）<ul>
<li>源站以广播方式发送一个发现帧到目的站，根据经过的结点生成最佳路径</li>
</ul>
</li>
</ul>
</li>
<li>交换机（多口网桥）：<ul>
<li>全双工、无碰撞（不同端口之间被分为不同网段，同一端口通过集线器连接的不同计算机会发送碰撞）</li>
<li>两种交换模式<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109141732299.png" srcset="/img/loading.gif" lazyload></li>
<li>其它特点和网桥类似。</li>
</ul>
</li>
</ul>
</li>
<li><p>冲突域和广播域<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210711202718.png" srcset="/img/loading.gif" lazyload alt="冲突域&amp;广播域"></p>
</li>
</ol>
<div class="note note-success">
            <p>习题<br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210711221305.png" srcset="/img/loading.gif" lazyload alt="18"><br>接收时延当然是包括在<code>发送时延 + 传播时延当中的</code>,但<strong>确认帧的发送相当于又一次的发送时延</strong><br>所以发送时延是<code>第一次,发送数据帧用时800ms,第二次.发送确认数据帧用时800ms</code>.<br>传播时延是来去共400ms.<br>所以总效率40%</p><hr><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210711222720.png" srcset="/img/loading.gif" lazyload alt="15"><br>这里不是停等协议,而是滑动窗口协议,故总时间不能简单的<code>传播延时250 + 总发送时延X(所有窗口发送的时延)</code>,因为当第一个确认帧到达时,后面的数据还没发送,不能算入发送时延.<br>应当考虑的是<strong>在第一个窗口发送时到第一个窗口确认帧到达时</strong>这段时间里<strong>发送了多少数据</strong>.<br>所以时间T是<code>发送时延 + 传播时延 = 1000*8b / 128kb/s + 250ms</code>约为0.5625 s<br>设发送的数据量为L,则发送数据用时t为 L&#x2F;128k s<br>所以<code>t / T</code>应当≥0.8,得B.  </p><hr><p><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109221741945.png" srcset="/img/loading.gif" lazyload></p><ul><li>半双工的交换机，意味着一个端口进，另一个端口出，满速10Mb&#x2F;s需要占用两个端口。</li></ul>
          </div>

<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 - 网络层"></a>第四章 - 网络层</h1><ol>
<li><p>网络层的功能：</p>
<ul>
<li>向上层提供<strong>异构网络互联</strong><ul>
<li>异构：不同协议的网络</li>
</ul>
</li>
<li>路由选择与路由转发</li>
<li>拥塞控制<ul>
<li>流量控制与拥塞控制的区别：流量控制是抑制发送端的速率，以便接收端来得急接收；而拥塞控制是子网能够承受并发送流量的问题，是一个全局性的问题</li>
<li>拥塞控制方法：<ul>
<li>开环控制（静态）：设计网络时就考虑好产生拥塞的因素，力求网络在工作中不产生拥塞</li>
<li>闭环控制（动态）：事先不考虑拥塞因素，采用动态检测网络系统的方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>路由算法：<font color=blue>(超重点！！！)</font></p>
<ul>
<li>自治系统AS：同一技术管理下的一组路由器，他们使用相同的路由选择协议，一般是一家公司、一所大学、一个政府部门等。</li>
<li>静态路由算法（非自适应路由算法）：网络管理员手工配置路由信息</li>
<li>动态路由算法（自适应路由算法、同一自治系统AS内）：通过相互连接的路由器之间彼此交换信息来优化路由表<ul>
<li>距离-向量路由算法（代表：RIP协议）：<ul>
<li>RIP协议不支持不同子网掩码的转发</li>
<li>“好消息”传得快、”坏消息“传得慢（网络故障需要数分钟才能传到所有路由器）</li>
<li>原理：<strong>所有结点定期把他们的整个路由表发给所有与之相邻的结点</strong></li>
<li>工作流程<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109142045869.png" srcset="/img/loading.gif" lazyload><ul>
<li>修改R4发来的路由表项（距离+1，下一跳均改为R4）；即数据从R6发出去到目的地要经过R4，所以距离加一，修改后的R4（要合并到R6的路由表）目的地均为R4。</li>
<li>遍历修改后的R4路由表：<ul>
<li>R6中没有表项，直接加上去</li>
<li>R6中有表项，且R6中表项的下一跳是：<ul>
<li>下一跳是R4，立即用收到的R4修改版替换（路径更新，这里不一定距离减少，更新是因为老路径和新路径同样是R6到R4，说明原路径失效）</li>
<li>下一跳不是R4，若R4修改版距离更近就更新，否则不作处理</li>
</ul>
</li>
</ul>
</li>
<li>180s还没收到某路由器X发来的路由表，就标记为X不可达。</li>
</ul>
</li>
</ul>
</li>
<li>链路状态路由算法（代表：OSPF协议）：<ul>
<li>开放最短路径优先算法OSPF协议，链路状态路由算法中使用Dijkstra的最短路径算法SPF。</li>
<li>分布式的链路状态协议</li>
<li>收敛速度快（路由状态的更新快）</li>
<li>工作原理：<ol>
<li>向网络中的所有路由发送信息，这里使用泛洪法，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<ul>
<li>最终整个区域内的所有路由器都得到了这个信息的副本</li>
</ul>
</li>
<li>发送的信息是本路由<strong>相邻的所有路由的链路状态</strong>，包括：本路由的相邻路由统计、到相邻路由的代价（费用、距离、时延或者带宽）</li>
<li>只有<strong>当链路状态发生变化时</strong>，才泛洪发送路由信息。</li>
<li>最后所有路由器都能建立起一个<strong>链路状态数据库</strong>，即<strong>全网拓朴图</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>外部网关协议（代表：BGP、不同自治系统AS间）：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109142146838.png" srcset="/img/loading.gif" lazyload><ul>
<li>BGP采用的是路径向量路由选择协议、基于TCP</li>
<li>BGP原理与RIP类似（采用路径向量路由选择协议），只不过交换的信息是：<strong>到达某个网络所要经过的一系列AS</strong><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109142147372.png" srcset="/img/loading.gif" lazyload><ul>
<li>如自治系统AS2的BGP 发言人通知主干网AS1的BGP 发言人：“要到达网络N1、N2、N3 和 N4 可经过 AS2。“</li>
<li>主干网还可发出通知：“要到达网络N5、N6 和N7 可沿路径（AS1, AS3）。”</li>
</ul>
</li>
<li>BGP支持CIDR</li>
<li>BGP协议的四种报文<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109142150190.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>三种协议比较<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109142153144.png" srcset="/img/loading.gif" lazyload></li>
<li><font color=blue>RIP（应用层）、OSPF（网络层）、BGP协议（应用层）</font></li>
</ul>
</li>
<li><p><font color=blue>(新增！！！)</font>SDN基本概念：（待补）</p>
</li>
<li><p>IPv4<font color=blue>(能记就记，首部长度、总长度、片偏移一定要记住)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714214407.png" srcset="/img/loading.gif" lazyload alt="IP数据报"><br> <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714214525.png" srcset="/img/loading.gif" lazyload alt="IP数据报格式"> </p>
<ul>
<li>分组格式：<ul>
<li>版本：指IP的版本,目前广泛使用的版本号为4</li>
<li>首部长度：<strong>本身占4位</strong>。以4B为单位，即若该字段四位全1即<code>1111</code>，表示长度为<code>15x4B = 60B</code>,也即最大值为60B ( 15x4B)，且<strong>规定最小值为20B（5×4）</strong>。最常用的首部长度是最小值20B。</li>
<li>区分服务（期望获得哪种类型的服务）</li>
<li>总长度（本身16位。指<strong>首部和数据之和</strong>的长度,单位为1字节,因此数据报的最大长度为2^16-1 &#x3D; 65535B，数据量过大会被分组）</li>
<li>标识（占16位。它是一个计数器,每产生一个数据报就加1,并赋值给标识字段。当一个数据报的长度超过网络的MTU时,必须分片,此时每个数据报片都复制一次标识号,以便能正确重装成原来的数据报。）</li>
<li>标志（3位。标志字段的最低位为MF(More Fragmaent), MF &#x3D; 1表示后面还有分片,MF &#x3D; 0表示最后一个分片。标志字段中间的一位是DF,只有当DF &#x3D; 0时才允许分片。）<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714223245.png" srcset="/img/loading.gif" lazyload alt="标志字段"></li>
<li>片偏移（占13位。以 8B 为偏移单位,它指出较长的分组在分片后,某片在原分组中的相对位置。）<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714223430.png" srcset="/img/loading.gif" lazyload alt="片偏移"></li>
<li>生存时间TTL（占8位。IP分组的保质期。经过一个路由-1，变成0则丢弃）</li>
<li>协议（占8位。数据部分的协议。<strong>其中值为6表示TCP,值为17表示UDP</strong>。）</li>
<li>首部校验和（只检验首部）</li>
<li>源IP地址和目的IP地址（32位）</li>
</ul>
</li>
<li>IP数据报的分片<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109161627820.png" srcset="/img/loading.gif" lazyload><ul>
<li>同一数据报的分片使用相同标识<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714222731.png" srcset="/img/loading.gif" lazyload alt="分片"></li>
<li>分片例题<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714223609.png" srcset="/img/loading.gif" lazyload alt="分片"></li>
</ul>
</li>
</ul>
</li>
<li><p>IPv4地址与NAT<font color=blue>(超重点！！！)</font>：</p>
<ul>
<li>分类的IP地址按照哈夫曼编码<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714231459.png" srcset="/img/loading.gif" lazyload alt="分类的IP地址"> <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109161641066.jpg" srcset="/img/loading.gif" lazyload></li>
<li><font color=green size=5>特殊IP地址</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714231723.png" srcset="/img/loading.gif" lazyload alt="特殊IP地址"><ul>
<li>网络号全0必为0.X.X.X（0.0.0.0表示本网络上的本主机。）</li>
<li>主机号全为1表示本网络的广播地址，又称直接广播地址，如202.98.174.255。<ul>
<li>只能“收”不能“发”</li>
</ul>
</li>
<li>主机号全为0表示本网络本身，如202.98.174.0表示202.98.174.X这个网络<ul>
<li>除0.0.0.0外，不能“收”也不能“发”</li>
</ul>
</li>
<li>127.X.X.X保留为环回自检( LoopbackTest) 地址,此地址表示任意主机本身,目的地址为环回地址的IP数据报永远不会出现在任何网络上（发出去的数据会被自己接收）。</li>
<li>32位全为1,即255.255.255.255表示整个TCP&#x2F;IP网络的广播地址,又称受限广播地址。</li>
<li>实际使用时,由于路由器对广播域的隔离,255.255.255.255等效为本网络的广播地址。</li>
</ul>
</li>
<li><font color=green size=5>私有IP地址</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714232557.png" srcset="/img/loading.gif" lazyload alt="私有IP地址"><ul>
<li><strong>私有地址也是可分配地址！</strong></li>
<li>只用于LAN,不用于WAN连接</li>
<li>路由器对目的地址是私有地址的数据报一律不转发。</li>
<li>因此私有IP地址不能直接用于Internet,必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP地址后才能用于Internet</li>
</ul>
</li>
<li>各类网可用<strong>网络</strong>数<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210714233120.png" srcset="/img/loading.gif" lazyload alt="网络类别"><ul>
<li>A类：0.X.X.X（本网络的某个特定主机，只能作为“发”不能作“收”；其中0.0.0.0表示本网所有主机），127.X.X.X（环回自检地址，发出去的会被自己收到，可“发”可“收”）</li>
<li>B类：128.0.X.X（保留地址、但其实已经被分配出去一部分了，教材还没改）</li>
<li>C类：192.0.0.X(保留地址、目前还没分配出去)</li>
<li>可用主机数：-2（全0&#x2F;1）</li>
</ul>
</li>
</ul>
</li>
<li><p>NAT（Network Address Translation）：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715142558.png" srcset="/img/loading.gif" lazyload alt="NAT"></p>
<ul>
<li>普通路由器在转发IP数据报时,不改变其源IP地址和目的IP地址。而NAT路由器在转发IP数据报时,一定要更换其IP地址(转换源IP地址或目的IP地址)。</li>
<li>普通路由器仅工作在网络层,而NAT路由器转发数据报时需要查看和转换传输层的端口号。</li>
</ul>
</li>
<li><p>子网划分<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715143632.png" srcset="/img/loading.gif" lazyload alt="子网划分2"></p>
<ul>
<li>子网划分<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715143915.png" srcset="/img/loading.gif" lazyload alt="子网划分3"><ul>
<li>从主机号借用若干比特作为子网号,当然主机号也就相应减少了相同的比特。</li>
<li>三级IP地址的结构如下:IP地址&#x3D;{〈网络号〉,〈子网号〉,〈主机号&gt;}。</li>
<li>凡是从其他网络发送给本单位某台主机的IP数据报,仍然是根据IP数据报的目的网络号, 先找到连接到本单位网络上的路由器。然后该路由器在收到IP数据报后,按目的网络号 和子网号找到目的子网。最后把IP数据报直接交付给目的主机。</li>
</ul>
</li>
<li>子网掩码：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715144034.png" srcset="/img/loading.gif" lazyload alt="子网划分4"><ul>
<li>子网掩码用来表达借位，一定是一串1接一串0</li>
<li>A、B、C类地址的默认子网掩码分别为255.0.0.0、255.255.0.0、255.255.255.0。</li>
</ul>
</li>
<li>习题1<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715145355.png" srcset="/img/loading.gif" lazyload alt="习题"></li>
<li>习题2<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715150215.png" srcset="/img/loading.gif" lazyload alt="习题"><ul>
<li><code>IP地址 &amp; 子网掩码 = 180.80.X.0</code>,其中X为<code>252 &amp; 77 = 11111100 &amp; 01001101 = 01001100 = 76</code>,即所在子网<code>180.80.76.0</code></li>
<li>子网掩码前面的1表示网络号和子网号,后面的0表示主机号(不可能01交替).</li>
<li>广播地址是主机号全1,所以子网内广播地址是<code>180.80.Y.255</code>,其中Y为<code>(010011 | 01) -&gt; (010011 | 11)</code>即<code>79</code></li>
<li>故答案为<code>180.80.79.255</code></li>
</ul>
</li>
</ul>
</li>
<li><p>CIDR（无分类编址）<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715160554.png" srcset="/img/loading.gif" lazyload alt="地址块"></p>
<ul>
<li>思想是：如果一个单位需要2000块地址，就给他分配一个2048地址的块（8个连续的C类地址）</li>
<li>IP地址的无分类两级编址为：IP::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}。<ul>
<li>对于128.14.32.5&#x2F;20这个地址,它的掩码是20个连续的1和后续12个连续的0,通过逐位相“与“的方法可以得到该地址的网络前缀</li>
</ul>
</li>
<li><font color="#2E75B6" size=4>CIDR的主机号可以<strong>全0或者全1</strong></font></li>
<li>路由转发时多个子网匹配的问题<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715162344.png" srcset="/img/loading.gif" lazyload alt="构最长前缀匹配">  <ul>
<li>例题<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715163630.png" srcset="/img/loading.gif" lazyload alt="构最长前缀匹配"><ol>
<li><code>132.0.0.0/8</code>, 前8位1匹配<code>132.19.237.5</code>成功</li>
<li><code>132.0.0.0/11</code>, 前8位1匹配<code>132.19.237.5</code>成功，<code>19所在字节: 0001xxxx &amp; 11100000</code>也匹配成功</li>
<li><code>132.19.232.0/22</code>, 前22位1匹配为<code>237所在字节: 11101101 &amp; 11111100 = 11101100 = 236</code>, 不匹配</li>
<li><code>0.0.0.0/0</code>是默认路由, 全都不匹配时才起作用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>超网<font color=blue>(看看就行)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715161557.png" srcset="/img/loading.gif" lazyload alt="构成超网">  </p>
<ul>
<li>R2路由的两个端口连接的网络，其地址前缀有16位相同，到第17位不同，所以合体网络地址应是<code>206.1.0.0/16</code></li>
<li>习题<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715162039.png" srcset="/img/loading.gif" lazyload alt="习题"></li>
</ul>
</li>
<li><p>ARP协议（地址解析协议）<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210715172115.png" srcset="/img/loading.gif" lazyload alt="发送数据的过程"></p>
<ul>
<li>）<font color=blue>图看看就好，不用记</font></li>
<li><strong>IP协议帧携带的是IP地址，但最终需要使用MAC地址（硬件地址）</strong></li>
<li>因此每台主机都有ARP缓存，用来存放{IP : MAC}的映射表</li>
<li>工作原理：<ol>
<li>IP协议帧在数据链路层被加上MAC地址信息</li>
<li>发出去后有四种情况：<ol>
<li>收发方都是主机，且在同一网段：直接在ARP缓存里找到“收”方主机的硬件地址</li>
<li>收发方都是主机，且在不同网段：也就是要通过路由器转发，这时需要在ARP缓存里找到本网络任何一个路由器的硬件地址</li>
<li>发送方是路由器，和目的主机在同一网段：直接在路由器的ARP缓存里找到目的主机的硬件地址</li>
<li>发送方是路由器，和目的主机在不同网段：也就是要通过另一个路由器转发，这时需要在ARP缓存里找到本网络另外一个路由器的硬件地址，把工作交给下一个路由器</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>DHCP协议（动态主机配置协议、用来动态分配IP）<font color=blue>(图是重点)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210717170223.png" srcset="/img/loading.gif" lazyload alt="DHCP协议"></p>
<ul>
<li><font color=blue>下面的看看,了解就行</font></li>
<li>第一步客户端使用广播方式是因为客户端不知道服务器的IP地址</li>
<li>第二步服务器也使用广播是因为服务器还没给客户端配置IP，客户端还没有IP地址</li>
<li>第三步确认采用广播而不是单播（通过第一次确认已经知道服务器IP地址）是因为这样可以同时告知其它DHCP服务器，已经得到了IP，原预分配IP可以收回。</li>
<li>第四步还是用广播则是因为IP分配还没得到确认（只是预分配）</li>
<li>在没有IP的情况下因为处于同一网段，所以可以使用MAC地址找到对方。</li>
</ul>
</li>
<li><p>ICMP协议（网际控制报文协议）<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>为了提高IP数据报交付成功的机会，提供ICMP协议使主机和路由器能够<strong>报告差错和异常信息</strong></li>
<li>ICMP询问报文和ICMP差错报文：<ul>
<li>ICMP的五种差错报文：<ul>
<li>终点不可达报文：目的地址无法送达</li>
<li>源点抑制报文：发送过快，造成拥塞</li>
<li>时间超过报文：路由器或主机收到超时的数据报后发送，告诉源点超时了，重发</li>
<li>参数问题报文：路由器或主机收到首部字段有问题的的数据报后发送，告诉源点出错了，重发</li>
<li>改变路由（重定向）报文：路由器发给源点，告诉源点有更好的路径</li>
</ul>
</li>
<li><strong>不应该发送差错报文的情况</strong>：<ol>
<li>对于差错报文不发送差错报文</li>
<li>对第一个分片的数据报片的所有后续数据报片不发送</li>
<li>对有组播地址的数据报不发送</li>
<li>对有特殊地址（127.0.0.0或0.0.0.0）的数据报不发送</li>
</ol>
</li>
<li>ICMP询问报文<font color=blue>(有1和2印象就行)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109162158640.png" srcset="/img/loading.gif" lazyload></li>
<li>ICMP的应用<font color=blue>(了解就行)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109162159675.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
<li><p>IPv6：地址增大到了128位</p>
<ul>
<li>表示法<font color=blue>(重点！！！)</font>：<ul>
<li>每4位用一个十六进制数 表示,并用冒号分隔每 16 位,如<code>4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</code>。</li>
<li>缩写成更紧凑的形式<ul>
<li>当16位域的开头有一些0时,可以采用一种缩写表示法,但在域中必须至少有一个数字。例如,可以把地址<code>4BF5:0000:0000:0000:BA5F:039A:000A:2176</code> 缩写为<code>4BF5:0:0:0:BA5F:39A:A:2176</code>。</li>
<li>当有相继的0值域时,还可以进一步缩写。这些域可以用双冒号缩写(::)。如<code>4BF5::BA5F:39A:A:2176</code>。<strong>但双冒号只能替换一次</strong></li>
</ul>
</li>
</ul>
</li>
<li>IPv6数据报的目的地址可以是以下三种基本类型地址之一:<ul>
<li>单播。单播就是传统的点对点通信。</li>
<li>多播。多播是一点对多点的通信,分组被交付到一组计算机的每台计算机。</li>
<li>任播。这是IPv6增加的一种类型。任播的目的站是一组计算机,但数据报在交付时只交付其中的一台计算机,通常是距离最近的一台计算机。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210718155030.png" srcset="/img/loading.gif" lazyload alt="三种基本类型地址"><ul>
<li>某台主机要想多播（可广播，可组播），就将多播地址放入IPv6地址中的目的地址即可。</li>
</ul>
</li>
</ul>
</li>
<li>与IPv4对比<font color=blue>(重点！！！)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210718153534.png" srcset="/img/loading.gif" lazyload alt="与IPv4对比"></li>
<li>IPv4到IPv6：<ul>
<li>双协议栈：一台设备上同时装有IPv4和IPv6协议栈，使之同时支持IPv6和IPv4</li>
<li>隧道技术：将IPv6数据报封装到IPv4数据报的数据部分，使之能在IPv4网络中传输</li>
</ul>
</li>
</ul>
</li>
<li><p>IP组播<font color=blue>(重点！！！)</font>：让计算机一次发送的单个分组可以抵达用一个组地址标识的若干设备，组播仅用于UDP</p>
<ul>
<li>目的地址是一个D类地址，组播地址也只能用作目的地址，源地址总是一个单播地址。</li>
<li>需要路由器支持</li>
<li>IGMP与组播路由算法<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210719184427.png" srcset="/img/loading.gif" lazyload alt="IGMP"><ul>
<li>IGMP协议（因特网组管理协议），是TCP&#x2F;IP的一部分</li>
<li>组播路由算法<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109171102142.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
</li>
<li><p>移动IP</p>
<ul>
<li>三个功能实体<ul>
<li>移动结点：具有永久IP地址的移动设备</li>
<li>归属代理（本地代理）：在一个网络环境中，一个移动结点的永久“居所”叫做<em>归属网络</em>。而<em>归属代理</em>就负责在归属网络中代表移动结点执行移动管理功能，其根据移动用户的转交地址，采用隧道技术转发移动节点的数据包</li>
<li>外部代理：在外部网络中帮助移动结点完成移动管理功能的实体</li>
</ul>
</li>
<li>移动IP通信流程<ol>
<li>移动结点在本地网时,按传统的TCP&#x2F;IP方式进行通信(在本地网中有固有的地址)。</li>
<li>移动结点漫游到一个外地网络时,仍然使用固定的IP地址进行通信。<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109171136515.png" srcset="/img/loading.gif" lazyload></li>
<li>为了能够收到通信对端发给它的IP分组,移动结点需要向本地代理注册当前的位置地址,这个位置地址就是转交地址</li>
<li>本地代理接收来自转交地址的注册后,会构建一条通向转交地址的隧道,将截获的发给移动结点的IP分组通过隧道送到转交地址处。</li>
<li>在转交地址处解除隧道封装,恢复原始的IP分组,最后送到移动结点,这样移动结点在外网就能够收到这些发送给它的IP分组。</li>
<li>移动结点在外网通过外网的路由器或外部代理向通信对端发送IP数据包。</li>
<li>移动结点来到另一个外网时,只需向本地代理更新注册的转交地址,就可继续通信。<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109171137303.png" srcset="/img/loading.gif" lazyload></li>
<li>移动结点回到本地网时,移动结点向本地代理注销转交地址,这时移动结点又将使用传统的TCP&#x2F;IP方式进行通信。</li>
</ol>
</li>
<li>主机A与主机B进行通信：<ol>
<li>若A和B在同一个归属网络内，直接通信即可</li>
<li>若A和B在不同归属网络内，A在外部网络的外部代理注册一个转交地址，然后将转交地址注册到本地代理</li>
</ol>
<ul>
<li>当A给B发送数据报时，本地代理会截断数据报进行再封装(隧道技术)，就是再原来的数据报外面再添加一个首部，新添加首部的目的地址是转交地址，然后发送给外部代理，外部代理再将数据报发送给主机A</li>
</ul>
</li>
</ul>
</li>
<li><p>路由器补充：</p>
<ul>
<li>可连接异构网络</li>
<li>路由表的结构<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210719190451.png" srcset="/img/loading.gif" lazyload alt="路由转发"></li>
</ul>
</li>
<li><p>路由器、交换机（网桥）、集线器（中继器）<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>集线器（Hub）：速率必须相等。<ul>
<li><strong>两个网段在“XX”层进行互联：“XX“层及”XX“层以下协议必须相等，”XX“层以上协议可以不同</strong></li>
</ul>
</li>
<li>交换机（Switch）：不同物理层协议，不同MAC子层协议（相同LLC子层）及不同速率以太网</li>
<li>路由器（Router）：物理层、数据链路层和网络层协议都不同，网络层以上协议必须相同</li>
</ul>
</li>
</ol>
<div class="note note-success">
            <p>习题<br><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109222048578.png" srcset="/img/loading.gif" lazyload></p><ol><li>R3检测到X（201.1.2.0&#x2F;25）不可达，说明R3与X原本是直连的</li><li>得到R1路由表<code>X 2</code>，R2路由表<code>X 2</code>，R3路由表<code>X 16</code>（注意！！！”坏消息“是慢收敛！！！也就是说不是一下变成16的，情况很复杂，可能R2给R3的信息也到了，让R3误以为可以通过R2到。总之看成慢慢加到16的就行）</li><li>不管如何，R2收到R1（X，2）和R3（X，&gt;2，因为R3开始只发了R2，所以距离至少+1）</li><li>选择后得到R2（X，3），更新。</li></ol>
          </div>


<h1 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 - 传输层"></a>第五章 - 传输层</h1><ol>
<li><p>传输层功能<font color=blue>(看看就行)</font>：</p>
<ul>
<li>复用和分用：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109181106222.png" srcset="/img/loading.gif" lazyload></li>
<li>传输层需要进行差错检测（首部和数据部分）</li>
<li>提供面向连接的TCP和无连接的UDP协议</li>
</ul>
</li>
<li><p>传输层的寻址与端口：<font color=blue>(了解)</font>：</p>
<ul>
<li>端口：标识进程，传输层使用的是软件端口<ul>
<li>软件端口：协议栈层间抽象的协议端口，相当于信息交互时的一种地址</li>
<li>硬件端口：硬件设备接口</li>
</ul>
</li>
<li>端口号<font color=blue>（65535 &#x3D; 2^16）</font>：<ul>
<li>服务端端口号：<ul>
<li>熟知端口号（0~1023）：指派给TCP&#x2F;IP最重要的一些应用进程<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722203025.png" srcset="/img/loading.gif" lazyload alt="寻址和端口"></li>
<li>登记端口号（1024~49151）：指派给一些熟知的应用，需要在IANA登记防止重复</li>
</ul>
</li>
<li>客户端端口号：（49152~65535）：临时端口，进程结束后端口会回收等待分配给其它应用进程</li>
</ul>
</li>
<li>套接字（Socket）：如<code>127.0.0.1:8080</code></li>
</ul>
</li>
<li><p>TCP&#x2F;IP协议族：TCP（面向连接、可靠）、UDP（无连接、不可靠）</p>
</li>
<li><p>IP数据报和UDP数据报的区别：</p>
<ol>
<li>IP数据报在网络层要经过路由的存储转发</li>
<li>UDP数据报<strong>逻辑上</strong>是在传输层的端到端逻辑信道上传输，实际上被封装成IP数据报在网络层上传输，UDP数据报信息对于路由来说不可见</li>
</ol>
</li>
<li><p>TCP和网络层虚电路的区别：</p>
<ol>
<li>TCP在传输层抽象逻辑信道上传输，对路由不可见</li>
<li>虚电路经过的中间节点都需要保存虚电路状态信息</li>
<li>网络层若采用虚电路，则无法提供无连接服务</li>
<li>传输层使用TCP，但也可以使用网络层提供的无连接服务</li>
</ol>
</li>
<li><p>UDP协议<font color=blue>(重点！！！)</font>：UDP协议基于IP协议，在IP服务之上增加了“复用和分用”以及“差错检测（尽最大努力交付）”</p>
<ul>
<li>特点<ul>
<li>UDP常为数据量小的传输协议提供服务（如DNS、SNMP）</li>
<li>尽最大努力交付但不保证可靠传输、可靠传输的实现在上层</li>
<li>UDP是面向报文的</li>
</ul>
</li>
<li>UDP首部格式<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722203628.png" srcset="/img/loading.gif" lazyload alt="UDP首部格式"><ul>
<li>源端口：16位（因为端口号最多16位，即65535）</li>
<li>目的端口：16位（同上）</li>
<li>UDP长度：16位（单位1B，最小值是8，即8B，仅有首部）</li>
<li>UDP校验和：16位（不想校验时就全0）</li>
</ul>
</li>
<li><strong>如果接收方UDP发现端口号找不到（不在运行），就丢弃报文，由ICMP回馈“不可达”差错报文</strong></li>
<li><strong>UDP校验</strong>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722204952.png" srcset="/img/loading.gif" lazyload><ul>
<li>UDP的校验和检查首部和数据部分</li>
<li>UDP校验和校验出错误时，可以丢弃，也可以交付，但要发送错误报告</li>
<li>在计算校验和时,要在UDP数据报之前增加12B的伪首部,伪首部并不是UDP的真正首部。只是在计算校验和时,临时添加在UDP数据报的前面,得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。</li>
<li>校验方法<font color=blue>(不可能大题，算到猴年马月去)</font><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722205439.png" srcset="/img/loading.gif" lazyload alt="UDP校验方法"></li>
</ul>
</li>
</ul>
</li>
<li><p>TCP协议<font color=blue>(超重点！！！)</font>：</p>
<ul>
<li>特点：<ul>
<li>TCP协议是在不可靠的IP层上实现了可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。</li>
<li>TCP面向字节流（TCP传送时逐个字节传送，但注意！！！TCP报文并不是只有1B的数据部分，而是一整个TCP数据报被逐个字节发送出去，例如一段100B的TCP报文段，被逐个字节地通过滑动窗口协议发送给目的地址）</li>
</ul>
</li>
<li>TCP报文段首部格式：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722210855.png" srcset="/img/loading.gif" lazyload alt="TCP报文段首部格式">  <ul>
<li>源端口、目的端口：各16位（2B）</li>
<li>序号（seq）：4B，范围0 ~ (2^32)-1<ul>
<li>例如：一段报文的第一个字节序号字段值是301，报文段共携带100B数据，则本报文段下一个字节序号301，最后一个字节序号400，下一个报文段的序号应该是401开始</li>
</ul>
</li>
<li>确认号（ack小写）：4B，期望收到对方下一个报文段的第一个数据字节的序号，若确认号N，则表示N-1和之前的数据都已经正确收到<ul>
<li>例如：B正确收到了A发来的一个报文段，序号字段501，数据长度200B，这表明B正确收到了包含501~700序号的数据的TCP报文（这个报文被逐字节发送接收），于是B在发给A的确认报文中将确认号置为701.</li>
</ul>
</li>
<li>数据偏移（首部长度）：4位，单位是4B，不是IP数据报那个数据偏移，而是首部长度（因为首部有变长的选项字段）。最大长度15*4&#x3D;60B</li>
<li>保留：6位，保留为今后使用，目前置0</li>
<li>紧急位URG：为1时是紧急数据，因尽快传送（不用排队&#x2F;不入缓存）</li>
<li><strong>确认位ACK</strong>：ACK&#x3D;1时上面的确认号才能用，表明这是个确认报文<ul>
<li>连接建立后所有报文段都是ACK&#x3D;1</li>
</ul>
</li>
<li>推送位PUSH：PUSH&#x3D;1时应该尽快交付（≠传送，是已经接收并放到缓存里了），不用等缓存满了才交付<ul>
<li><ul>
<li>注意<strong>紧急位URG</strong>是在<strong>发送方中不用排队,不入缓存</strong>,紧急交付;而<strong>推送位PSH</strong>则是在<strong>接收方缓存中尽快交付,不等缓存满即交付</strong></li>
</ul>
</li>
</ul>
</li>
<li>复位位RST：RST&#x3D;1时，表示TCP连接出现严重差错，必须释放连接，重新建立连接</li>
<li><strong>同步位SYN</strong>：SYN&#x3D;1表示这是个连接请求或连接接收报文。<ul>
<li>SYN&#x3D;1，ACK&#x3D;0表示这是个连接请求报文，对方正确收到就应回复SYN&#x3D;1，ACK&#x3D;1</li>
</ul>
</li>
<li>终止位FIN：FIN&#x3D;1时用来释放连接</li>
<li><strong>窗口字段</strong>：2B，对方的窗口数量，表示允许对方发送的数据量</li>
<li>校验和：2B，包括首部和数据部分</li>
<li>紧急指针字段：2B，单位1B，表示紧急数据共有多少字节（紧急数据在数据部分的最前面）</li>
<li>选项：长度可变，TCP只规定了一种选项（最大报文段长度）</li>
<li>填充字段，使首部长度是4B的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP的连接<font color=blue>(超重点！！！)</font>：</p>
<ul>
<li>连接的建立（三次握手🤝）：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722213715.png" srcset="/img/loading.gif" lazyload alt="TCP连接建立"><ol>
<li>客户端向服务器发送一个请求连接报文（SYN&#x3D;1，ACK&#x3D;0，seq&#x3D;X）<ul>
<li>客户端为自己选择一个初始号X</li>
</ul>
</li>
<li>服务器收到请求连接报文后，如同意，就回确认报文（SYN&#x3D;1，ACK&#x3D;1，ack&#x3D;X+1，seq&#x3D;Y），并为TCP连接准备资源（服务器）<ul>
<li>服务器端为自己选择一个初始号Y</li>
</ul>
</li>
<li>客户端收到确认报文后还要给服务器一个确认（ACK&#x3D;1，ack&#x3D;Y+1，seq&#x3D;X+1），并为TCP连接准备资源（客户端）</li>
</ol>
</li>
<li>连接的释放（四次挥手👋）：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722215028.png" srcset="/img/loading.gif" lazyload alt="TCP连接释放"><ol>
<li>客户端向服务器发送一个连接释放报文（FIN&#x3D;1，seq&#x3D;U）<ul>
<li>U是上次客户端发给服务器的数据的最后字节的序号+1</li>
<li>TCP客户端进入FIN-WAIT-1状态，等待服务器发送FIN&#x3D;1（客户端：“我说完了”）</li>
</ul>
</li>
<li>服务器收到连接释放报文后发送确认（ACK&#x3D;1，ack&#x3D;U+1，seq&#x3D;V）<ul>
<li>V是上次服务器端发给客户端的数据的最后字节的序号+1</li>
<li>服务器进入CLOSE-WAIT状态，发送最后一些数据（服务器：“好的，我还有一点要讲”）</li>
</ul>
</li>
<li>服务期通知客户端释放连接（FIN&#x3D;1，ACK&#x3D;1，ack&#x3D;U+1，seq&#x3D;W）<ul>
<li>为什么seq不是V+1？因为2到3之间可能服务器又发了些数据</li>
<li>服务器进入LASt-ACK状态，等待客户端确认（服务器：“我也讲完了”）</li>
</ul>
</li>
<li>客户端收到连接释放报文后，发出确认（ACK&#x3D;1，ack&#x3D;W+1，seq&#x3D;U+1）<ul>
<li>客户端进入CLOSED关闭状态（客户端：“好的🆗”）</li>
</ul>
</li>
</ol>
</li>
<li>SYN泛洪攻击，不停发送连接请求报文（SYN&#x3D;1），等服务器同意后发送确认报文，故意不回确认，这样这个TCP连接就被挂起，如果收到大量的TCP请求就会崩溃</li>
</ul>
</li>
<li><p>TCP可靠传输的实现：序号、确认号、重传</p>
</li>
<li><p>TCP流量控制<font color=blue>(了解)</font>：滑动窗口协议<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109181558492.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>TCP拥塞控制<font color=blue>(重点！！！)</font>：</p>
<ul>
<li>最大报文段长度MSS</li>
<li>慢开始算法：先让拥塞窗口cwnd&#x3D;1，每收到一个新的报文确认就增大拥塞窗口<ul>
<li>如：A发B，发送方cwnd&#x3D;1，A收到B关于第一个报文段（非字节）的确认cwnd&#x3D;2，A收到B关于第二个报文段（非字节）的确认cwnd&#x3D;4，上限16.</li>
</ul>
</li>
<li>拥塞避免算法：让拥塞窗口缓慢增大<ul>
<li>如：每经过一个往返时延RTT就让拥塞窗口cwnd+1</li>
</ul>
</li>
<li><strong>慢开始和拥塞避免算法结合</strong>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722224715.png" srcset="/img/loading.gif" lazyload><ul>
<li>传输轮次: A发送一个报文段<code>m1</code>给B,直到收到来自B的<code>m1</code>的确认的时间段即第一个轮次; 然后A发送两个报文段<code>m2、m3</code>给B,直到收到来自B的<code>m3</code>的确认的时间段即第二个轮次;</li>
</ul>
</li>
<li>快重传和快恢复算法：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210722225926.png" srcset="/img/loading.gif" lazyload><ul>
<li>快重传：A发送0到5，B收到<code>0、1、3、4、5</code>，B收到3时会发送ack&#x3D;2提醒A2号没到，同理4、5，则3次ack确认后A即使还没到超时时间也会立即发2.</li>
<li>快恢复：发生快重传时cwnd&#x3D;N；一旦发生快重传，就将慢开始的阈值降低到发生快重传时的一半即N&#x2F;2；且重新开始慢开始</li>
</ul>
</li>
<li><strong>不管哪种方法，发送窗口的大小由拥塞窗口和接收窗口的最小值决定</strong></li>
</ul>
</li>
<li><p>TCP协议首部20B,IP协议首部20B.</p>
</li>
</ol>
<h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 - 应用层"></a>第六章 - 应用层</h1><ol>
<li><p>网络应用模型<font color=blue>(了解)</font>：</p>
<ul>
<li>客户端&#x2F;服务器模型<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725194734.png" srcset="/img/loading.gif" lazyload alt="客户/服服务器模型"></li>
<li>P2P模型<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725194820.png" srcset="/img/loading.gif" lazyload alt="P2P模型"></li>
</ul>
</li>
<li><p>域名系统（DNS）<font color=blue>(了解)</font>：将便于记忆的网址（<a target="_blank" rel="noopener" href="http://www.google.com)转变为方便计算机处理的ip地址/">www.google.com）转变为方便计算机处理的IP地址</a></p>
<ul>
<li>协议运行在UDP，使用53端口</li>
<li>域名服务器层次<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725203004.png" srcset="/img/loading.gif" lazyload>  <ul>
<li><strong>根域名服务器</strong><ul>
<li>最高层次服务器，<strong>所有根域名服务器都知道所有顶级域名服务器的IP</strong></li>
<li>最重要的域名服务器，<strong>本地域名</strong>服务器在无法解析一个域名时，首先求助于根域名服务器</li>
<li>用来管辖顶级域(如：com)，一般不直接转化为IP，而是告知应该去哪个顶级域名服务器查询</li>
</ul>
</li>
<li><strong>顶级域名服务器</strong><ul>
<li>负责管理在该顶级域名服务器注册的所有二级域名</li>
<li>收到DNS查询请求时, 就给出相应的回答</li>
</ul>
</li>
<li><strong>权限域名服务器</strong><ul>
<li>二级及以下的域名服务器</li>
<li>每台主机（网站服务器的主机）都必须在授权域名服务器处登记。</li>
<li>实际上,许多域名服务器都同时充当本地域名服务器和授权域名服务器。</li>
<li>授权域名服务器总能将其管辖的主机名转换为该主机的IP地址。</li>
</ul>
</li>
<li>本地域名服务器<ul>
<li>每个因特网服务提供者(ISP),或一所大学,甚至一所大学中的各个系,甚至计算机内都可以拥有一个本地域名服务器。</li>
<li>当一台主机发出DNS查询请求时,这个 查询请求报文就发送给该主机的本地域名服务器。</li>
</ul>
</li>
</ul>
</li>
<li>域名的层次<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725202146.png" srcset="/img/loading.gif" lazyload alt="域名层次"></li>
</ul>
</li>
<li><p>域名解析过程</p>
<ul>
<li>域名解析是指把域名映射成为IP地址或把IP地址映射成域名的过程。前者称为正向解析, 后者称为反向解析。</li>
<li>当客户端需要域名解析时,通过本机的DNS客户端构造一个DNS请求报文, 以UDP数据报方式发往本地域名服务器。</li>
<li>查询方式：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725203111.png" srcset="/img/loading.gif" lazyload><ul>
<li>递归查询：本机去本地域名服务器查询，本地服务器查不到，将任务转交给根域名服务器，再根域名➡顶级域名➡权限域名一级一级直到查到再返回</li>
<li>迭代查询：本地域名查不到，由本地域名服务器分别依次去根域名服务器、顶级域名服务器、权限域名服务器查询（根域名告知去哪个顶级域名服务器查询，以此类推，直到查到）。</li>
</ul>
</li>
</ul>
</li>
<li><p>文件传输协议FTP<font color=blue>(重要)</font></p>
<ul>
<li>特点:<ul>
<li>FTP采用客户&#x2F;服务器的工作方式,它使用TCP可靠的传输服务</li>
<li>一个FTP服务器进程可同时为多个客户进程提供服务</li>
<li>可匿名方式提供公共文件共享</li>
</ul>
</li>
<li>工作原理：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109202030726.png" srcset="/img/loading.gif" lazyload><ul>
<li>使用两个并行的TCP连接(都是服务器上打开的端口)：<ul>
<li>控制连接（端口21）：<ul>
<li>服务器监听21端口，等待客户端连接请求；</li>
<li>控制信息都以7为ASCⅡ格式发送；</li>
<li>控制连接整个会话期间都打开</li>
</ul>
</li>
<li>数据连接（端口20）：<ul>
<li>控制进程收到请求后，就创建数据连接子进程负责该客户端进程的传输</li>
<li>传送完毕后关闭数据连接子进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>打开21端口(控制),使客户进程能够连接上</li>
<li>等待客户进程发连接请求</li>
<li>FTP启动从属进程来处理客户端进程发来的请求.主进程和从进程并发执行,从属进程处理完客户进程的请求立即终止</li>
<li>回到等待状态,继续接收其它客户基础发来的请求</li>
</ol>
</li>
</ul>
</li>
<li><p>电子邮件📧<font color=blue>(了解)</font><img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725211257.png" srcset="/img/loading.gif" lazyload alt="组成构件"></p>
<ul>
<li>组成部分：<ol>
<li>用户代理（UA）：用户与电子邮件系统的接口</li>
<li>邮件📧服务器：负责发送接收邮件和跟踪邮件状态</li>
<li>协议：SMTP（发送协议，负责用户代理UA发给邮件服务器或邮件服务器之间的发送）、POP3（接收协议，负责UA从邮件服务器读取邮件📧）</li>
</ol>
</li>
<li>电子邮件📧的收发过程：<ol>
<li>【发】发信人攥写邮件📧。用户代理UA通过STMP发送邮件📧到<strong>发送方</strong>的邮件服务器</li>
<li>【存】发送方邮件服务器将邮件📧放入缓存队列</li>
<li>【连】发送方服务器发现缓存队列的邮件后，向接收方的SMTP服务器发起TCP连接。</li>
<li>【发】（邮件服务器的）<strong>TCP</strong>连接建立后，STMP客户进程开始向远程STMP服务器进程发送邮件📧，发完后关闭TCP连接。</li>
<li>【存】接收方STMP服务器收到邮件，放入用户邮箱（暂存）</li>
<li>【取】收信人使用UA调用POP3（或IMAP）将邮件从接收方邮件服务器中的用户邮箱取回</li>
</ol>
</li>
<li>邮件格式<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109202056988.png" srcset="/img/loading.gif" lazyload><ul>
<li>”To“和”From“是必需的</li>
</ul>
</li>
<li>多用途网际邮件扩充（MIME）：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109202101068.png" srcset="/img/loading.gif" lazyload><ul>
<li>STMP只支持ASCⅡ码，对非英文用户极不友好，也无法传输二进制文件（图片、压缩包等附件）</li>
</ul>
</li>
</ul>
</li>
<li><p>SMTP 和 POP3 和 IMAP<font color=blue>(看看就行)</font>：</p>
<ul>
<li>STMP：<ul>
<li>连接建立、邮件传送、连接释放</li>
<li>依赖TCP</li>
</ul>
</li>
<li>POP3：<ul>
<li>UA运行POP客户端程序、邮件服务器运行POP服务器程序</li>
<li>依赖TCP</li>
<li>两种工作方式：<ul>
<li>下载并保留</li>
<li>下载并删除</li>
</ul>
</li>
</ul>
</li>
<li>IMAP（因特网报文存取协议）：<ul>
<li>只有存取，即邮件接收协议，比POP复杂</li>
<li>为用户提供：<strong>创建文件夹、不同文件夹间移动邮件、远程文件夹查看邮件、查看邮件报文的部分内容</strong>功能</li>
<li>需要维护会话用户状态信息</li>
</ul>
</li>
</ul>
</li>
<li><p>基于万维网的电子邮件📧<font color=blue>(看看就行)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725214232.png" srcset="/img/loading.gif" lazyload alt="基于万维网的电子邮件📧">  </p>
<ul>
<li>直接使用网页发送</li>
<li>从<strong>发送方到邮件📧服务器</strong>和从<strong>邮件📧服务器到接收方</strong>使用的是HTPP协议</li>
</ul>
</li>
<li><p>万维网和HTTP协议<font color=blue>(了解)</font>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109202115396.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>万维网一般使用超文本传输协议（HTTP）将资源（一般是HTML）发给使用者</li>
</ul>
</li>
<li><p>HTTP协议<font color=blue>(超重点！！！)</font>：</p>
<ul>
<li>特点：<ul>
<li>无状态（第二次访问页面时和第一次访问，其服务器响应相同）</li>
<li>无状态特性意味着对于不同客户端的同一页面请求，可以返回相同的响应，<strong>使服务器支持大量并发HTTP请求</strong></li>
<li>使用cookie和数据库来跟踪用户活动</li>
<li>使用TCP作为传输层协议，可靠</li>
<li>持久连接和非持久连接</li>
</ul>
</li>
<li>工作原理：<ol>
<li>每个站点背后都有一个服务器进程，不断地监听TCP端口80（默认）</li>
<li>服务器监听到连接请求就与客户端建立连接</li>
<li>TCP连接建立后，浏览器向服务器发送获取某个Web页面的HTTP请求</li>
<li>服务器收到HTTP请求后，将构建Web页的必需信息（渲染文件路径、内容文件路径等），通过HTTP响应返回给浏览器</li>
<li>浏览器解释执行，显示Web页，TCP连接释放</li>
</ol>
</li>
<li>两种报文：HTTP请求报文、HTTP响应报文</li>
<li>用户单击鼠标后所发生的事件按顺序如下（以访问清华大学的网站为例）<font color=blue>(看看就行)</font>：<ol>
<li>浏览器分析链接指向页面的URL(<a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn/chn/index.htm">http://www.tsinghua.edu.cn/chn/index.htm</a>)</li>
<li>浏览器向DNS请求解析<a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn的ip地址./">www.tsinghua.edu.cn的IP地址。</a></li>
<li>域名系统DNS解析出清华大学服务器的IP地址。</li>
<li>浏览器与该服务器建立TCP连接（默认端口号为80)。 </li>
<li>浏览器发出HTTP请求：<code>GET /chn/index.htm</code></li>
<li>服务器通过HTTP响应把文件index.htm发送给浏览器。</li>
<li>释放TCP连接。</li>
<li>浏览器解释文件index.htm,并将Web页显示给用户。</li>
</ol>
</li>
<li>持久连接和非持久连接<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/20210725221406.png" srcset="/img/loading.gif" lazyload alt="连接方式"><ul>
<li>非持久连接（静态加载）：每个网页元素对象(如JPEG图形、Flash等)的传输都需要单独建立一个TCP连接</li>
<li>持久连接（动态加载）：是指万维网服务器在发送响应后仍然保持这条连接,使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文<ul>
<li>持久连接又分为非流水线和流水线两种方式。</li>
<li><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求。</li>
<li><strong>流水线方式</strong>：<ul>
<li>HTTP&#x2F;1.1的默认方式是使用流水线的持久连接。</li>
<li>如果所有的请求和响应都是连续发送的,那么所有引用的对象共计经历1个RTT延迟,而不是像非流水线方式那样,每个引用都必须有1个RTT延迟。</li>
<li>一个对象引用就立即发出一个请求;因而客户可以逐个地连续发出对各个引用对象的请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>状态码</strong>：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202109202141531.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ol>
<h1 id="新考点"><a href="#新考点" class="headerlink" title="新考点"></a>新考点</h1><ul>
<li>SDN：路由选择算法不再运行在每台路由器上，由一台远程控制器负责进行路由选择，路由仅进行转发。<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202112151102494.png" srcset="/img/loading.gif" lazyload><ul>
<li>网络范围状态管理层负责实现自定义路由选择协议</li>
<li>向上（北）网络控制应用程序&#x2F;软件。向下（南）受控网络设备&#x2F;路由器</li>
</ul>
</li>
<li>VLAN：<img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202112151117698.png" srcset="/img/loading.gif" lazyload> <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202112151119904.png" srcset="/img/loading.gif" lazyload> <img src="https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img/202112151123790.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h1 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;<br>四号红: &lt;font color=red size=4&gt;&lt;/font&gt;<br>红:    &lt;font color=red&gt;&lt;/font&gt;<br>绿:    &lt;font color=green&gt;&lt;/font&gt;<br>蓝:    &lt;font color=blue&gt;&lt;/font&gt;<br><br>分割线:  <br><br>----------------------------<br><br><br>拼图<br>&#123;% gi 2 2 %&#125;<br><br>&#123;% endgi %&#125;<br><br>便签：  <br>&#123;% note success %&#125;  <br><br>&#123;% endnote %&#125;<br><br></code></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>王道参考书 &amp; <a target="_blank" rel="noopener" href="https://github.com/AFutureD/How-to-learn-408/blob/master/Computer_Networks">GitHub: How-to-learn-408</a>  </p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%BD%91/" class="category-chain-item">计网</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%80%83%E7%A0%94/">#考研</a>
      
        <a href="/tags/%E8%AE%A1%E7%BD%91/">#计网</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络考研复习</div>
      <div>https://chen0495.github.io/posts/a01c1709/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Chen0495</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年7月1日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                <i class="iconfont icon-nc"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                <i class="iconfont icon-sa"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/4c949373/" title="操作系统考研复习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统考研复习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/5c8ae43f/" title="快速排序算法">
                        <span class="hidden-mobile">快速排序算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.5.1/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.5.1/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline-fvl6vv4xc-chen0495.vercel.app/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":[],"lang":"zh-CN","emoji":["https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
