<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理课程笔记(弃坑) | Chen0495的空间站</title><meta name="author" content="Chen0495"><meta name="copyright" content="Chen0495"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶词法分析 前面的课程没有笔记，在这里补一下哈，主要参考国防科技大学的编译原理MOOC 简单来说就是判断一个字符串是否是合法单词 正规式的等价性: b(ab)*&amp;#x3D;(ba)*b 即：  ¶确定的有限自动机(DFA) M&amp;#x3D;(S,Σ,f,S?,F)  S：有穷状态集 Σ：输入字母表 f：状态转换函数，后继"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chen0495.github.io/posts/f3ce9b23/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cfdf1bbbfc14c67b6054b14a9f17c34";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chen0495","link":"链接: ","source":"来源: Chen0495的空间站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理课程笔记(弃坑)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 14:19:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-heart"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.chen0495.top/img/20200713000952.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Chen0495的空间站"><span class="site-name">Chen0495的空间站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-heart"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编译原理课程笔记(弃坑)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-16T03:48:00.000Z" title="发表于 2020-04-16 11:48:00">2020-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T06:19:09.653Z" title="更新于 2023-09-08 14:19:09">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编译原理课程笔记(弃坑)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="词法分析"><a class="header-anchor" href="#词法分析">¶</a>词法分析</h2>
<p><s>前面的课程没有笔记，在这里补一下哈，主要参考国防科技大学的编译原理MOOC</s><br>
简单来说就是判断一个字符串是否是合法单词<br>
正规式的等价性:<br>
b(ab)*=(ba)*b<br>
即：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430103730.jpg" alt="MOOC"></p>
<h3 id="确定的有限自动机-DFA"><a class="header-anchor" href="#确定的有限自动机-DFA">¶</a>确定的有限自动机(DFA)</h3>
<p>M=(S,Σ,f,S?,F)</p>
<span id="more"></span>
<p>S：有穷状态集<br>
Σ：输入字母表<br>
f：状态转换函数，<strong>后继唯一</strong><br>
S?：S? ∈ S，<strong>是唯一的一个初态</strong><br>
F：F ∈ S，终态集(可以为空)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430105139.jpg" alt="MOOC"></p>
<p>tips:</p>
<ul>
<li>DFA每个顶点射出的弧上的标记符不同</li>
<li>DFA M所识别的字的全体为L(M)</li>
</ul>
<h3 id="非确定的有限自动机"><a class="header-anchor" href="#非确定的有限自动机">¶</a>非确定的有限自动机</h3>
<p>M=(S,Σ,f,S?,F)</p>
<p>S：有穷状态集<br>
Σ：输入字母表<br>
f：状态转换函数，<strong>可以是字符，字，正规式</strong><br>
S?：S? ∈ S，<strong>非空初态集</strong><br>
F：F ∈ S，终态集(可以为空)<br>
NFA与DFA区别：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430111624.jpg" alt="MOOC"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430115640.jpg" alt="MOOC"></p>
<p>DFA与NFA识别能力相同：</p>
<ul>
<li>对于每一个NFA，有一个DFA与该NFA识别能力相同</li>
</ul>
<h3 id="NFA到DFA的转换-NFA的确定化"><a class="header-anchor" href="#NFA到DFA的转换-NFA的确定化">¶</a>NFA到DFA的转换(NFA的确定化)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430115640.jpg" alt="MOOC"><br>
如上图，NFA的确定化就是要消除这三个方面的差异</p>
<ol>
<li>消除初始状态的差异</li>
</ol>
<ul>
<li>引进新的初态结点X和终态结点Y，X经过ε到S?(初始状态集)中任意结点，Y经过ε到F(终态集)中的任意结点</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430120536.jpg" alt="NFA by MOOC"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200430120541.jpg" alt="INSERT XY by MOOC"></p>
<ol start="2">
<li>消除弧上标记差异和转换差异<br>
子集法: 解决 ε 弧和转换关系</li>
</ol>
<ul>
<li>引入定义<strong>ε-闭包</strong>，即ε-closure(I)为:
<ul>
<li>若S ∈ I，则S ∈ ε-closure(I)；</li>
<li>若S ∈ I，则从S出发经过任意条 ε 弧所能到达的任何状态 S′ 都属于ε-closure(I)。</li>
</ul>
</li>
</ul>
<p><font color=green size=5>偷下懒，直接放图</font><br>
定义Ia如图：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200502144604.jpg" alt="MOOC"><br>
即：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200502144718.jpg" alt="MOOC"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200502145258.jpg" alt="MOOC"><br>
得到转换表:<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200502145841.jpg" alt="MOOC"><br>
注意即使Ia或者Ib是空集若满足条件也要放入I计算下去<br>
<u>话说计算 J 中间能经过 ε 吗？应该是不能的(若有错误请联系我订正)，而且只能经过一个a|b。</u></p>
<p>放个例子：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200502151035.jpg" alt="MOOC"><br>
转换表编号后变成DFA：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo//2020/20200502151845.jpg" alt="MOOC"></p>
<p>DFA化简( <font color=green size=4>待补</font> )：<br>
先划分为终态和非终态；<br>
再对两个子集细分直到无法再分：<br>
即子集中每个元素的move结果不同的要区分开来，具体见<a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/NUDT-1003101005?tid=1450256472#/learn/content?type=detail&amp;id=1214459156&amp;cid=1218189141">MOOC 6.1 第4个视频</a></p>
<hr>
<h2 id="语法分析"><a class="header-anchor" href="#语法分析">¶</a>语法分析</h2>
<p>简单理解为判断一个输入串是否是一个<strong>句子</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508140318.jpg" alt="分析方法"></p>
<h3 id="回顾上下文无关文法"><a class="header-anchor" href="#回顾上下文无关文法">¶</a>回顾上下文无关文法</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508135238.jpg" alt="四元组"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508135424.jpg" alt="一些定义"></p>
<ul>
<li>开始符S能推导出的叫做<strong>句型</strong>，<strong>句型</strong>只有<strong>终结符组成</strong>叫<strong>句子</strong>, 文法的所有句子的集合叫<strong>语言</strong></li>
</ul>
<h3 id="自上而下分析"><a class="header-anchor" href="#自上而下分析">¶</a>自上而下分析</h3>
<p>示例如图：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508141105.jpg" alt=""><br>
从文法开始符号S开始推导,S只有一个右部，取 S -&gt; xAy 进入下一层，x匹配成功，A匹配失败且A有下一层，取右部(从左到右取),A下一层是两个※号,第一个 * 匹配成功，第二个 * 匹配失败，<strong>回溯</strong>,<br>
取A -&gt; * ，匹配成功，y匹配成功，完成。<br>
下面介绍下一些可能遇到的问题。</p>
<h4 id="回溯问题"><a class="header-anchor" href="#回溯问题">¶</a>回溯问题</h4>
<p>如上例，匹配成功可能是暂时的，出错时就得<strong>回溯</strong></p>
<h4 id="文法左递归问题"><a class="header-anchor" href="#文法左递归问题">¶</a>文法左递归问题</h4>
<p>即可能存在 P =+=&gt; Pα，即P推导出的句型中又有P开头<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508142439.jpg" alt="左递归"><br>
构建语法树的过程中可能不断遇到使用左递归式的问题，这会导致语法树一直构建下去而未继续读入任何字符，陷入死循环</p>
<h4 id="消除文法左递归"><a class="header-anchor" href="#消除文法左递归">¶</a>消除文法左递归</h4>
<h5 id="消除直接左递归"><a class="header-anchor" href="#消除直接左递归">¶</a>消除直接左递归</h5>
<p>例如： P -&gt; Pα|β (β不以P开头)<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508143258.jpg" alt="简单直接左递归"><br>
而右递归因为有字符会不断被读入并匹配，所以右递归不会产生死循环<br>
下面是一个复杂点的 m个左递归<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508143648.jpg" alt="复杂直接左递归"></p>
<h5 id="消除间接左递归"><a class="header-anchor" href="#消除间接左递归">¶</a>消除间接左递归</h5>
<p>如：<br>
S -&gt; Qc|c<br>
Q -&gt; Rb|b<br>
R -&gt; Sa|a<br>
没有直接左递归，但其实S,Q,R都是左递归的，例如存在 S =&gt; Qc =&gt; Rbc =&gt; Sabc</p>
<p>现在来消除间接左递归<br>
但是有前提条件</p>
<ul>
<li>不含以 ε 为右部的产生式</li>
<li>不含回路，即不能自己推自己(P =+=&gt; P)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508145132.jpg" alt=""><br>
通过不断带入来打破循环<br>
算法 ：<br>
所有非终结符P = { P1…Pn }按顺序排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 把(Pi) -&gt; (Pj)α 改写为 (Pi) -&gt; (β1)α|(β2)α|(β3)α...|(βk)α</span></span><br><span class="line">        <span class="comment"># 示例见下图</span></span><br></pre></td></tr></table></figure>
<p>同一个文法<br>
S -&gt; Qc|c<br>
Q -&gt; Rb|b<br>
R -&gt; Sa|a<br>
排列：R,Q,S<br>
首先R，R以S开头，但S顺序在R后面，故R不处理；然后Q，Q以R开头，R在Q前面，所以把R用R的右部代替即 Q -&gt; Sab|ab|b ,<br>
R的右部现在没有<u>按照顺序在它前面的非终结符</u>开头的了，所以完成；开始S，Q在S之前，Q要替换成Q的右部即 S -&gt; Sabc|abc|bc|c<br>
<strong>注意了！！！</strong> ,S有有直接左递归，按照消除左递归的方法消除它：S -&gt; abcS’ | bcS’ | cS’ and S’ -&gt; abcS’ | ε<br>
<strong>然后！！！</strong> 可以看到从S出发到S’, S’ 又到 S’,Q和R无用，删掉</p>
<h4 id="消除回溯"><a class="header-anchor" href="#消除回溯">¶</a>消除回溯</h4>
<p>即保证在构建分析树的时候输入一个字符串，对于每一个非终结符，如果它有多个候选A -&gt; α|β|σ 选择必须是正确唯一的，这样就不需要回溯。</p>
<p>我们这样想，我们要扩展A就要选择A的右部中 <u>以当前匹配字符a开头的</u> 或者 <u>经过若干步推导以a开头的</u><br>
但是A的右部有多个以当前匹配字符a开头的怎么办？依旧有回溯啊？<br>
于是引入FIRST集，<font color=red size=5>这个FIRST集是针对所有非终结符(例如上面的A)的右部的每个式子而产生的</font><br>
这样就能解决上面提出的问题<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508160102.jpg" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508160337.jpg" alt=""><br>
示例：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508160902.jpg" alt=""><br>
匹配 i+i ，<strong>在末尾加个结束符#</strong>，从开始符E开始，E只有一个右部，扩展；T只有一个右部，扩展；F要匹配i，(E) 的首符集是左括号，i的首符集是i，所以F选择推导到i而不是(E);<br>
对于T’ 因为另一个首符集是星号，只能选择 ε。后面略。</p>
<p>但是我们同时也看到在第一个T’时，T’只能取 ε，且+号跟在 T’ 后面,…我也半知半解…<br>
总之，引入FOLLOW集，即从开始符S能推出的所有句子中，A后面跟着的那个字符组成的集合就是A的FOLLOW集<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508174944.jpg" alt=""><br>
例如上图，若A要匹配a但a不在A的FIRST集里，所以只能取ε，但取了后是否就能匹配呢，这要看FOLLOW集。</p>
<h5 id="FIRST集及其构造方法"><a class="header-anchor" href="#FIRST集及其构造方法">¶</a>FIRST集及其构造方法</h5>
<ul>
<li>为了消除公共左公因子产生的回溯问题<br>
左公因子产生式举例：<br>
<strong>A -&gt; αβ1 | αβ2</strong><br>
即某个非终结符的多个候选式具有相同前缀，上式αβ1和αβ2具有相同前缀α</li>
</ul>
<p>构造方法：<br>
对于每一个X ∈ V_t ∪ V_n , 使用如下规则直到每个FIRST集不再增大：</p>
<ul>
<li>若X ∈ V_t，则FIRST(X)={X}<br>
若X是终结符，则其FIRST集就是其本身</li>
<li>若X ∈ V_n，X是非终结符，那么有
<ul>
<li>若X -&gt; a… ，则 a ∈ FIRST(X)，<strong>这里 a 可以是 ε</strong></li>
<li>若X -&gt; Y… ，则 FIRST(Y) - {ε} ∈ FIRST(X)</li>
<li>若X -&gt; Y?Y?Y?..Ym…Yn , Y(1-m) 即 前m个Y 都是非终结符.
<ul>
<li>若FIRST(Yj) 1 &lt;= j &lt;= m 都含有ε，则把FIRST(Ym+1)中的非ε元素加入FIRST(X),直白点就是前面m个都<strong>可以</strong>为空，那就把他们取成空来算后面那个。</li>
<li>若FIRST(Yj) 1 &lt;= j &lt;= n 都含有ε，则把ε加入FIRST(X).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><font color=red size=4>若在构造过程中有FIRST(X)发生变化，从头开始</font><br>
例：<br>
G_S:<br>
S -&gt; aA<br>
S -&gt; d<br>
A -&gt; bAS<br>
A -&gt; ε<br>
有FIRST集<br>
FIRST(S) = {a,d}<br>
FIRST(A) = {b,ε}<br>
FIRST(aA) = {a}<br>
FIRST(d) = {d}<br>
FIRST(bAS) = {b}<br>
FIRST(ε) = {ε}</p>
<h5 id="FOLLOW集及其构造"><a class="header-anchor" href="#FOLLOW集及其构造">¶</a>FOLLOW集及其构造</h5>
<p>对于A ∈ V_t，有 FOLLOW(A) = {a | S =*=&gt; …Aa… , a ∈ V_t }</p>
<p>若S =*=&gt; …A ,则规定 # ∈ FOLLOW(A)<br>
这里用#作为输入串的结束符，也叫输入串符号</p>
<p>构造方法：<br>
对于每个非终结符A，使用如下规则直到每个FOLLOW集不再增大：</p>
<ul>
<li>首先，若S为文法开始符号，{ # } ∈ FOLLOW(S)</li>
<li>若 B -&gt; αAβ 是一个产生式,则FIRST(β)-{ε} ∈ FOLLOW(A)</li>
<li>若 B -&gt; αA 或者 B -&gt; αAβ且β =*=&gt; ε，则FOLLOW(B) ∈ FOLLOW(A)<br>
例：<br>
A -&gt; BCc|gDB<br>
B -&gt; bCDE|ε<br>
C -&gt; DaB|ca<br>
D -&gt; dD|ε<br>
E -&gt; gAf|c<br>
有</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">非终结符</th>
<th style="text-align:center">FIRST集</th>
<th style="text-align:center">FOLLOW集</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">{ a,b,c,d,g }</td>
<td style="text-align:center">{ f,# }</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">{ b,ε }</td>
<td style="text-align:center">{ a,c,d,g,f,# }</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">{ a,c,d }</td>
<td style="text-align:center">{ c,d,g }</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">{ d,ε }</td>
<td style="text-align:center">{ a,b,c,g,f,# }</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">{ c,g }</td>
<td style="text-align:center">{ a,c,d,g,f,# }</td>
</tr>
</tbody>
</table>
<h4 id="LL-1-文法"><a class="header-anchor" href="#LL-1-文法">¶</a>LL(1)文法</h4>
<p>L - 从左到右扫描字符串<br>
L - 最左推导<br>
1 - 每次分析根据当前单词向前看一个符号<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200508175746.jpg" alt="图"><br>
满足上面三条的是LL(1)文法</p>
<h4 id="LL-1-分析法"><a class="header-anchor" href="#LL-1-分析法">¶</a>LL(1)分析法</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527124558.jpg" alt="LL1分析法"></p>
<h4 id="预测分析表的构造"><a class="header-anchor" href="#预测分析表的构造">¶</a>预测分析表的构造</h4>
<h5 id="SELECT集"><a class="header-anchor" href="#SELECT集">¶</a>SELECT集</h5>
<p>其实就是上面LL(1)分析法，用select作为中介方便写，不容易出错。<br>
对于待输入字符a，我们现在匹配a，所以找到 a ∈ FIRST(A-&gt;α)</p>
<ul>
<li><strong>若 α 不能推导出 ε ，那么 SELECT(A-&gt;α) = FIRST(α)</strong></li>
<li><strong>若 α 能推导出 ε ，那么 SELECT(A-&gt;α) = (FIRST(α)-{ε}) ∪ FOLLOW(A)</strong>，其实就是 α 能推出 ε，所以还要考虑α = ε的情况啦，这时候(α = ε)匹配a的就应该是A后面跟的字符。</li>
</ul>
<h5 id="构造预测分析表"><a class="header-anchor" href="#构造预测分析表">¶</a>构造预测分析表</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527130452.jpg" alt="百度文库-构造"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527130700.jpg" alt="百度文库-示例"></p>
<h3 id="自下而上分析"><a class="header-anchor" href="#自下而上分析">¶</a>自下而上分析</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527131836.jpg" alt="语法分析的方法"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527134330.jpg" alt="图"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527134256.jpg" alt="图"></p>
<h4 id="短语和直接短语-算符优先分析"><a class="header-anchor" href="#短语和直接短语-算符优先分析">¶</a>短语和直接短语(算符优先分析)</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200527135806.jpg" alt="图"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528104245.jpg" alt="图"></p>
<h4 id="算符优先分析法"><a class="header-anchor" href="#算符优先分析法">¶</a>算符优先分析法</h4>
<p>句子可能有几种不同的归约方法，导致结果不同。如果事先规定算符的优先次序，并按照优先级进行归约，则这个归约过程就会是唯一的。<br>
如，对于文法G[E]: E -&gt; i | E+E | E-E | E*E | E/E | (E),  有句子i+i-i*(i+i)<br>
其归约过程如下：<br>
i+i-i*(i+i)    E -&gt; i<br>
E+i-i*(i+i)    E -&gt; i<br>
E+E-i*(i+i)    E -&gt; E+E<br>
E-i*(i+i)    E -&gt; i<br>
E-E*(i+i)    这一步涉及到算符优先级，需要先算乘法，而乘法算符后面是括号，括号优先级更高，应该先算括号表达式<br>
E-E*(E+E)    E -&gt; i 两次<br>
E-E*(E)    E -&gt; E+E<br>
E-E*E    E -&gt; (E)<br>
E-E   E -&gt; E*E<br>
E   E -&gt; E-E<br>
归约完成<br>
但我们知道文法本身没有规定算符优先级，我们再看一个例子，同样对于上面的句子进行归约<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528110336.jpg" alt="图"><br>
归约过程中你会发现并不需要考虑算符优先级，这个句子依旧被正确地归约。  实际上我们是可以看出该文法优先级关系的。</p>
<h5 id="算符优先关系"><a class="header-anchor" href="#算符优先关系">¶</a>算符优先关系</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528111248.jpg" alt="图"><br>
注意此关系与数学上的 &lt; , = , &gt; 是不同的，它表示左边的算符a与右边的算符b之间的关系，有前后顺序。<br>
如对于 + 算符，数学上当然是两个加号相等的，不会出现大于小于关系(不考虑大于等于，小于等于)，但在算符优先关系上是可以规定优先级的，即可以规定左部的加号优先级小于右边的加号。<br>
且<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528111908.jpg" alt="图"></p>
<h5 id="算符优先文法"><a class="header-anchor" href="#算符优先文法">¶</a>算符优先文法</h5>
<p>我们规定算符文法：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528112258.jpg" alt="图"><br>
上面的计算的两个文法都是算符文法<br>
继续规定:<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528113051.jpg" alt="图"><br>
怎么理解？<br>
小写字母是终结符，大写字母是非终结符</p>
<ol>
<li>如对于E -&gt; (E) ，左( 和 右) 的优先级相等</li>
<li>对于E -&gt; E?+E? ，这里用下标区分位置，又有E? -&gt; E?*E?，所以 左+ 优先级小于 右*</li>
<li>对于E -&gt; E?*E?,这里用下标区分位置,又有E? -&gt; E?+E?，所以 左+ 优先级大于 右*</li>
</ol>
<p>我们看到2与3似乎是矛盾的，但我们已经在上面的计算中发现该文法具有二义性，不能唯一地归约一个句子，所以这个矛盾恰恰说明其不是算符优先文法<br>
我们规定：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528114147.jpg" alt="图"></p>
<p>例子：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528115047.jpg" alt="图"><br>
得到算符优先关系表：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528115210.jpg" alt="图"></p>
<h5 id="构造算符优先关系表"><a class="header-anchor" href="#构造算符优先关系表">¶</a>构造算符优先关系表</h5>
<ol>
<li>
<p>对于相等优先关系，我们只需要考虑产生式右部中各个候选式，连续出现的终结符的优先关系就行，不需要考虑非终结符的推导<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200528115514.jpg" alt=""></p>
</li>
<li>
<p>大于小于优先关系则需要考虑非终结符的推导<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602083003.png" alt=""><br>
其简单理解就是P的<strong>所有</strong>推导式的最左的终结符和最右的终结符<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602083746.png" alt=""></p>
</li>
</ol>
<p>构造FIRSTVT(P)的算法：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602084441.png" alt=""></p>
<p>构造LASTVT(P)的算法：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602085314.png" alt=""></p>
<p>构造关系表<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602090754.png" alt=""></p>
<h4 id="句柄和规范归约-LR分析"><a class="header-anchor" href="#句柄和规范归约-LR分析">¶</a>句柄和规范归约(LR分析)</h4>
<p>L: 从左到右扫描输入串<br>
R: 自下而上进行归约<br>
<strong>一个句型的最左直接短语叫句柄</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602095041.png" alt=""></p>
<p>例：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602092834.png" alt="">  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/chen0495/Chen0495_PicGo/2020/20200602092843.png" alt=""></p>
<h4 id="LR分析法"><a class="header-anchor" href="#LR分析法">¶</a>LR分析法</h4>
<p>LR分析表：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602100204.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602100952.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602101004.png" alt=""></p>
<p>空白表示报错</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602101235.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602101502.png" alt=""><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602101625.png" alt=""></p>
<p>举例：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200602101717.png" alt=""><br>
右边LR分析表的构造会在后面提到</p>
<h5 id="LR-0-项目集规范族、DFA和分析表的构建"><a class="header-anchor" href="#LR-0-项目集规范族、DFA和分析表的构建">¶</a>LR(0)项目集规范族、DFA和分析表的构建</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200712194809.png" alt="概念"></p>
<p>例子:<br>
文法：<br>
S --&gt; BB<br>
B --&gt; aB<br>
B --&gt; b</p>
<p>步骤:</p>
<ol>
<li>
<p>拓展文法<br>
S’ --&gt; S<br>
S --&gt; BB<br>
B --&gt; aB<br>
B --&gt; b</p>
</li>
<li>
<p>求出项目集规范族<br>
Item0 = CLOSURE({S’ --&gt; .S}) = {S’ --&gt; .S，S --&gt; .BB，B --&gt; .aB，B --&gt; .b}<br>
Item1 =GO(Item0,S) = CLOSURE({S’ --&gt; S.}) = {S’ --&gt; S.}<br>
Item2 = GO(Item0,B) = CLOSURE({S --&gt; B.B}) = {S --&gt; B.B，B --&gt; .aB，B --&gt; .b}<br>
Item3 = GO(Item0,a) = CLOSURE({B --&gt; a.B}) = {B --&gt; a.B，B --&gt; .aB，B --&gt; .b}<br>
Item4 = GO(Item0,b) = CLOSURE({B --&gt; b.}) = {B --&gt; b.}<br>
至此Item0已经遍历完，开始遍历下一个，由于Item1圆点已经到达末尾，所以跳过Item1。<br>
Item5 = GO({Item2,B) = CLOSURE({S --&gt; BB.}) = {S --&gt; BB.}<br>
由于 GO(Item2,a) 和 GO(Item2,b) 重复，所以去掉。<br>
Item6 = GO(Item3,B) = CLOSURE({B --&gt; aB.}) = {B --&gt; aB.}<br>
由于 GO(Item3,a) 和 GO(Item3,b) 重复，所以去掉。<br>
至此，项目集闭包不再增加，所以项目集规范族构造完毕！</p>
</li>
<li>
<p>构造DFA<br>
!<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200712194908.jpg" alt=""></p>
</li>
<li>
<p>构造LR(0)分析表(根据DFA图将分析表填充)<br>
输入：文法G的扩展文法G’<br>
输出：G’的LR(0)分析表（即 Action表和Goto表）<br>
步骤：<br>
1、 本例中Item2  --B–&gt;  Item5，则在  状态号为2的行，列名为B的格中填入状态5<br>
(转移条件为非终结符，填充Goto表，填入状态号， 转移条件为终结符，填充Action表,<br>
填入Sn，Sn表示移进，移进符号并且移进状态号n)<br>
Item2  --a–&gt;  Item3 ，则在状态号为2的行，列名为a的格填入S3。<br>
2、 对于圆点在右部最右边：<br>
if  A --&gt; α. ∈ Itemk (0&lt;k&lt;n)  &amp; A --&gt; α 为G的第 j 个产生式，<br>
then for  任意 a ∈ T U { # }  do<br>
Action[k,a]  =  Rj<br>
（Rn表示归约，不移进符号，用第n个产生式的右部替换符号栈的X）<br>
3、 if  S’ --&gt; S.  ∈ Itemk (0&lt;k&lt;n)    then Action[k,#] = acc.<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200712194947.jpg" alt=""></p>
</li>
</ol>
<h5 id="SLR-1-分析"><a class="header-anchor" href="#SLR-1-分析">¶</a>SLR(1)分析</h5>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hjc256/article/details/90573145">见CSDN</a></p>
<h5 id="LALR-1-分析"><a class="header-anchor" href="#LALR-1-分析">¶</a>LALR(1)分析</h5>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44225182/article/details/105599118">见CSDN</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Chen0495.github.io">Chen0495</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chen0495.github.io/posts/f3ce9b23/">https://chen0495.github.io/posts/f3ce9b23/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Chen0495.github.io" target="_blank">Chen0495的空间站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></div><div class="post_share"><div class="social-share" data-image="https://img.chen0495.top/img/20200713000952.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e83dc864/" title="android系统https抓包问题分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200713000435.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">android系统https抓包问题分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/87a809ba/" title="双线部署你的个人博客"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20200713000551.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">双线部署你的个人博客</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA-DFA"><span class="toc-number">1.1.</span> <span class="toc-text">确定的有限自动机(DFA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">非确定的有限自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFA%E5%88%B0DFA%E7%9A%84%E8%BD%AC%E6%8D%A2-NFA%E7%9A%84%E7%A1%AE%E5%AE%9A%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">NFA到DFA的转换(NFA的确定化)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">回顾上下文无关文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">自上而下分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">回溯问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%B7%A6%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">文法左递归问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E6%96%87%E6%B3%95%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">2.2.3.</span> <span class="toc-text">消除文法左递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E7%9B%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">消除直接左递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E9%97%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">消除间接左递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%9B%9E%E6%BA%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">消除回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FIRST%E9%9B%86%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">FIRST集及其构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FOLLOW%E9%9B%86%E5%8F%8A%E5%85%B6%E6%9E%84%E9%80%A0"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">FOLLOW集及其构造</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">LL(1)文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">LL(1)分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">2.2.7.</span> <span class="toc-text">预测分析表的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SELECT%E9%9B%86"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">SELECT集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E8%A1%A8"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">构造预测分析表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">自下而上分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%AF%AD%E5%92%8C%E7%9B%B4%E6%8E%A5%E7%9F%AD%E8%AF%AD-%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">短语和直接短语(算符优先分析)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">算符优先分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">算符优先关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E6%96%87%E6%B3%95"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">算符优先文法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%85%B3%E7%B3%BB%E8%A1%A8"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">构造算符优先关系表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E6%9F%84%E5%92%8C%E8%A7%84%E8%8C%83%E5%BD%92%E7%BA%A6-LR%E5%88%86%E6%9E%90"><span class="toc-number">2.3.3.</span> <span class="toc-text">句柄和规范归约(LR分析)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">LR分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LR-0-%E9%A1%B9%E7%9B%AE%E9%9B%86%E8%A7%84%E8%8C%83%E6%97%8F%E3%80%81DFA%E5%92%8C%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">LR(0)项目集规范族、DFA和分析表的构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SLR-1-%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">SLR(1)分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LALR-1-%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">LALR(1)分析</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img2022/202207290206838.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Chen0495</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://chen0495.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'waline-cb3yck4r1-chen0495.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, {"placeholder":"说些什么吧QAQ","meta":["nick","mail","link"],"emoji":["https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili"],"search":false,"wordLimit":200,"pageSize":10}))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://unpkg.com/@waline/client/dist/waline.css').then(() => {
      getScript('https://unpkg.com/@waline/client/dist/waline.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-show-text" src="https://unpkg.com/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>