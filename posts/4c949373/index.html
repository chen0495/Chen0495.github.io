<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统考研复习 | Chen0495的空间站</title><meta name="author" content="Chen0495"><meta name="copyright" content="Chen0495"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶第一章 - 计算机系统概述   操作系统的概念（了解，选择题不选错就行）：  控制和管理计算机软硬件 合理组织调度计算机的工作与资源 为用户和其它软件提供接口    操作系统的基本特征（了解）：  并发（区分并行） 共享 虚拟：一个物理实体变成多个逻辑上的对应物  虚拟处理器：并发多道程序，让用户"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chen0495.github.io/posts/4c949373/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4cfdf1bbbfc14c67b6054b14a9f17c34";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chen0495","link":"链接: ","source":"来源: Chen0495的空间站","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统考研复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 14:19:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-heart"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.chen0495.top/img/20210701210018.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Chen0495的空间站"><span class="site-name">Chen0495的空间站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-heart"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统考研复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-27T06:25:49.000Z" title="发表于 2021-07-27 14:25:49">2021-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T06:19:09.989Z" title="更新于 2023-09-08 14:19:09">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统考研复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-计算机系统概述"><a class="header-anchor" href="#第一章-计算机系统概述">¶</a>第一章 - 计算机系统概述</h1>
<ol>
<li>
<p>操作系统的概念<font color=blue>（了解，选择题不选错就行）</font>：</p>
<ol>
<li>控制和管理计算机软硬件</li>
<li>合理组织调度计算机的工作与资源</li>
<li>为用户和其它软件提供接口</li>
</ol>
</li>
<li>
<p>操作系统的基本特征<font color=blue>（了解）</font>：</p>
<ul>
<li>并发（<strong>区分并行</strong>）</li>
<li>共享</li>
<li>虚拟：一个物理实体变成多个逻辑上的对应物
<ul>
<li>虚拟处理器：并发多道程序，让用户以为有多个处理器</li>
<li>虚拟存储器：如虚拟内存</li>
<li>I/O处理器的空分复用技术</li>
</ul>
</li>
<li>异步：多道程序走走停停，以不可预知的速度前进</li>
</ul>
</li>
<li>
<p>操作系统的目标和功能<font color=blue>（了解）</font></p>
<ul>
<li>管理功能：处理机管理、存储器管理、文件管理、设备管理。</li>
<li>接口功能：
<ul>
<li>命令接口：联机命令接口（cmd）、脱机命令接口（批处理系统的作业说明书）。</li>
<li>程序接口：由系统调用（也叫广义指令）组成，例如“printf程序调用”由定位内存、显示字符等多个系统调用组成。</li>
</ul>
</li>
<li>扩展机器（不重要）</li>
<li>系统调用<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109292038825.png" alt=""></li>
</ul>
</li>
<li>
<p>操作系统发展与分类<font color=blue>（重点关注批处理阶段，其它了解即可）</font></p>
<ol>
<li>手工处理阶段：这个阶段<strong>没有操作系统</strong>，所有调度包括程序的装入、允许、结果输出都需要人为干预</li>
<li>批处理阶段：出现操作系统，为了解决“人（慢）机（快）矛盾”和“CPU（快）与I/O设备（慢）矛盾”而出现
<ol>
<li>单道批处理系统：自动性（磁带上的程序逐个允许，无需人工干预）、顺序性（磁带上的程序依次调入内存、依次按序执行）、单道性（一次只调入一道程序到内存，只有一道程序在运行）</li>
<li>多道批处理系统：允许多个程序同时（宏观）被调入内存并交替执行。宏观上并行，微观上串行。</li>
</ol>
</li>
<li>分时操作系统：处理机运行时间划分时间片，分配给任务运行。同时、交互、独立、及时性。</li>
<li>实时操作系统：保证规定时间内完成某项任务。实时性、可靠性。</li>
<li>分布式计算机系统、个人计算机操作系统。</li>
</ol>
</li>
<li>
<p>操作系统的运行机制<font color=blue>（重点关注中断和异常部分，其它简单或者在后面章节才展开）</font></p>
<ul>
<li>操作系统内核程序（核心态/管态）和用户程序（用户态/目态）
<ul>
<li>核心态可以执行特权指令，而用户态只能执行非特权指令。</li>
<li>切换要通过程序状态字寄存器PSW（计组）</li>
<li><code>核心态 ➡ 用户态</code>: 执行一条特权指令,修改程序状态字PSW,主动让出CPU使用权</li>
<li><code>用户态 ➡ 核心态</code>: 自陷/中断</li>
</ul>
</li>
<li>内核需要实现：
<ol>
<li>时钟管理：CLOCK</li>
<li>中断机制：<font color=blue>见后面部分</font>，一开始是为了提高CPU利用率（计组-系统总线设计部分），后面也负责核心/用户态切换。</li>
<li>原语：不可被打断的小程序，因为某些操作被中断会造成大麻烦。</li>
<li>系统控制的数据结构及处理：快表、索引表、进程控制块等等…</li>
</ol>
</li>
<li>中断与异常<font color=blue>（重点！！！）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109292035480.png" alt="">
<ul>
<li><strong>中断是操作系统必须要实现的！！！</strong></li>
<li>访管/陷入指令：顾名思义，访问管态程序/特权指令的指令，因其可以在用户态下使用，所以不是特权指令</li>
<li>中断（外中断、相对于CPU来说是“外”）：I/O中断（输入输出完成）、时钟中断
<ul>
<li>内存外存的访问都需要通过系统调用trap触发中断</li>
</ul>
</li>
<li>异常（内中断、相对于CPU来说是“内”、<strong>不能被屏蔽</strong>）：非法操作数（除0、地址越界、算术溢出）、陷入指令（用户程序自己设置，用户态➡核心态）
<ul>
<li>内中断的响应发生在指令执行过程中，且不需要返回断点</li>
</ul>
</li>
</ul>
</li>
<li>系统调用：操作系统中提供的实现一些特定功能的小程序。
<ul>
<li>分类就不谈了，没见过考这么细的。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大内核与微内核<font color=blue>（需要理解）</font>：</p>
<ul>
<li>大内核：操作系统的大多数功能都运行在核心态
<ul>
<li>优点：性能优势（想想大部分功能都可以在核心态，也就是更靠近硬件的状态下运行）</li>
<li>缺点：设计复杂</li>
</ul>
</li>
<li>微内核：操作系统的最基本功能运行在核心态
<ul>
<li>优点：有效分离各功能模块，维护成本大大降低</li>
<li>缺点：性能问题（需要在用户态和核心态频繁切换）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="第二章-进程管理"><a class="header-anchor" href="#第二章-进程管理">¶</a>第二章 - 进程管理</h1>
<ol>
<li>
<p>进程<font color=blue>（超重点！！！）</font>：</p>
<ul>
<li>区分<strong>程序</strong>和<strong>进程</strong>:
<ul>
<li>程序：是<strong>静态</strong>的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</li>
<li>进程（Process）：是动态的，是程序的一次执行过程。</li>
</ul>
</li>
<li><font color=green size=4>进程控制块PCB</font>,以&quot;打开三个QQ进程，操作系统怎么区分他们？&quot;为例:
<ul>
<li>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的</strong>、<strong>不重复</strong>的“身份证号”—— <font color=red size=4>PID</font>（Process ID，进程ID）</li>
</ul>
<ol>
<li>操作系统要记录PID、进程所属用户ID（UID）——<em>基本的进程描述信息，可以让操作系统区分各个进程</em></li>
<li>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）——<em>可用于实现操作系统对资源的管理</em></li>
<li>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）——<em>可用于实现操作系统对进程的控制、调度</em></li>
</ol>
<ul>
<li><strong>这些信息都被保存在一个数据结构PCB （Process Control Block）中，即进程控制块操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</strong></li>
</ul>
</li>
<li>程序的运行过程: <code>程序文件 ➡ 可执行文件(二进制、机器指令) ➡ 入内存 ➡ 分配PCB ➡ 顺序执行机器指令 ➡ 执行产生的中间数据被放入数据段</code></li>
<li>一个<strong>进程实体（进程映像）<strong>由</strong>PCB、程序段、数据段</strong>组成。
<ul>
<li><strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）<strong>是</strong>静态</strong>的。</li>
</ul>
</li>
<li><font color=green size=4>进程的特征</font>: 动态性、独立性、并发性、异步性、结构性（PCB、程序段、数据段）</li>
</ul>
</li>
<li>
<p>进程的状态和转换</p>
<ul>
<li>状态<font color=blue>（解释部分看看就行）</font>：
<ul>
<li>运行态。进程正在处理机上运行。在单处理机环境下，一个<strong>时刻</strong>最多只有一个进程处于运行态。</li>
<li>就绪态。进程已经获得了除了处理机以外的所有资源，一旦得到处理机资源，即可立即运行。处于就绪态的进程可能有多个，通常将他们排成队列即<strong>就绪队列</strong>。</li>
<li>阻塞态（等待态）。进程正在等待某一事件而暂停运行，如等待某资源（除处理机以外）可用或I/O完成。即使处理机空闲，该进程也不能运行。</li>
<li>创建态。<strong>进程正在被创建</strong>，尚未转到就绪态。</li>
<li>结束态。进程正在从系统中消失，可能是进程正常运行结束或者中断退出运行。进程需要结束运行时，首先将进程置为结束态，然后回收资源。</li>
</ul>
</li>
<li>进程状态的转换<font color=blue>（超重点！！！）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728151032.png" alt="进程状态的转换">
<ul>
<li>阻塞态只能到就绪态，只有运行态能到阻塞态。</li>
</ul>
</li>
<li>进程的创建：<code>分配进程号、申请PCB ➡ 分配资源（内存等） ➡ 初始化PCB ➡ 进入就绪队列</code></li>
<li>进程的结束：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机 ➡ 终止子进程 ➡ 剥夺所有资源（还给父进程或操作系统） ➡ 删除PCB</code>
<ul>
<li>正常结束、异常结束（异常事件导致无法执行）、外界干预（用户或操作系统请求关闭）</li>
</ul>
</li>
<li>进程的阻塞：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机，保存现场至PCB并修改状态为阻塞态 ➡ 入阻塞队列</code></li>
<li>进程的唤醒/就绪：<code>阻塞队列找到PCB ➡ 移出阻塞队列，状态改为就绪 ➡ 入就绪队列</code></li>
</ul>
</li>
<li>
<p>进程的切换：</p>
<ul>
<li><strong>状态的切换在核心态！！！</strong></li>
<li>进程切换过程：<code>保存现场 ➡ 更新PCB ➡ PCB移入相应队列（就绪、等待） ➡ 找到切换进程的进程号，更新其PCB ➡ 运行 ➡ 运行结束 ➡ 根据PCB恢复现场（不一定是那个被替换掉的进程）</code></li>
</ul>
</li>
<li>
<p>进程的组织</p>
<ul>
<li>即要解决怎么将各个进程的PCB组织起来的问题。</li>
<li>进程控制块PCB：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109282140340.png" alt="">
<ul>
<li>PID（进程号、进程标识符）和UID（用户号、标识进程归属用户）</li>
<li>进程运行、控制、中断相关的信息</li>
<li>资源分配清单、处理机相关信息</li>
</ul>
</li>
<li>进程包括：程序控制块PCB、程序段、数据段</li>
<li>进程的组织方式<font color=blue>（重点！！！）</font>：
<ul>
<li>链接方式：指针。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728151601.png" alt="链接方式">
<ul>
<li>也可以细分，如阻塞队列细分为：打印机阻塞队列、磁盘阻塞队列</li>
</ul>
</li>
<li>索引方式：索引表。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728151920.png" alt="索引方式"></li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程的控制</p>
<ul>
<li>创建进程、结束进程、进程状态转换</li>
<li>原语的“原子性”
<ul>
<li>利用开/关中断实现</li>
</ul>
</li>
<li>原语<font color=blue>（理解）</font>：
<ul>
<li>进程创建原语：<code>分配进程号、申请PCB ➡ 分配资源（内存等） ➡ 初始化PCB ➡ 进入就绪队列</code>
<ul>
<li>引起进程创建的事件：用户登录（创建系统父进程）、作业调度（作业放入内存，为其创建进程）、提供服务（某些请求会创建进程，如FTP）、应用请求（用户进程请求创建子进程）</li>
</ul>
</li>
<li>进程终止原语：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机 ➡ 终止子进程 ➡ 剥夺所有资源（还给父进程或操作系统） ➡ 删除PCB</code>
<ul>
<li>引起进程终止的事件：正常结束、异常结束、外界干预</li>
</ul>
</li>
<li>进程阻塞原语：<code>根据进程号找到PCB、查看进程状态 ➡ 剥夺处理机，保存现场至PCB并修改状态为阻塞态 ➡ 入阻塞队列</code>
<ul>
<li>引起进程阻塞的事件：请求的资源不足、等待其它进程</li>
</ul>
</li>
<li>进程唤醒原语：<code>阻塞队列找到PCB ➡ 移出阻塞队列，状态改为就绪 ➡ 入就绪队列</code>
<ul>
<li>引起进程唤醒的事件：等待的事件发生</li>
</ul>
</li>
<li>进程切换原语：<code>保存现场 ➡ 更新PCB ➡ PCB移入相应队列（就绪、等待） ➡ 找到切换进程的进程号，更新其PCB ➡ 运行 ➡ 运行结束 ➡ 根据PCB恢复现场（不一定是那个被替换掉的进程）</code>
<ul>
<li>引起进程切换的事件：时间片到、高优先级到、进程主动阻塞、进程结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程的通信</p>
<ul>
<li>共享存储：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728163632.png" alt="共享存储"></li>
<li>管道通信：相当于缓存<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728164048.png" alt="管道通信"></li>
<li>信息传递：类似计网，中间一个信箱，信息都发往信息<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728164418.png" alt="信息传递"></li>
</ul>
</li>
<li>
<p>线程：<code>进程 ➡ 线程</code></p>
<ul>
<li>引入线程之后：进程只是资源分配的单位，线程成为处理机的分配单元；</li>
<li>线程最直接的理解就是“轻量级进程”。</li>
<li>引入线程后的变化
<ul>
<li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</li>
<li>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。</li>
<li>线程则作为处理机的分配单元。</li>
</ul>
</li>
<li>线程的特点/属性：<font color=blue>（理解）</font>：
<ul>
<li>线程不能创建进程</li>
<li>不拥有系统资源，拥有唯一标识符和线程控制块</li>
<li>不同线程可以执行相同程序，同一服务程序被不同用户调用，可能创建不同线程</li>
<li>同一进程的线程共享该进程全部资源（互斥共享）</li>
<li>线程是处理机的独立调度单位</li>
<li>线程也有生命周期、阻塞、就绪、运行等状态</li>
<li>多CPU，各个线程可占用不同CPU</li>
<li>每个线程都有线程ID、线程控制块（TCB）</li>
<li>切换同进程的线程，开销小（不用换进程）</li>
<li>线程共享进程的内存空间，因此其通信甚至无需系统干预</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程的实现方式<font color=blue>（重点！！！）</font>：</p>
<ul>
<li>用户级线程：线程管理工作交由进程，内核意识不到线程的存在
<ul>
<li>用户级线程切换不需要CPU状态转换</li>
<li>当一个用户级线程被阻塞时，整个进程都被阻塞。多个线程不可在多核处理机上运行</li>
</ul>
</li>
<li>内核级线程：线程的管理工作由内核完成
<ul>
<li>主流方式</li>
<li>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li>
<li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
</li>
<li>多线程模型
<ul>
<li><strong>一对一</strong>模型<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728172054.png" alt="一对一模型">
<ul>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
</li>
<li><strong>多对一</strong>模型<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728172505.png" alt="多对一模型">
<ul>
<li>退化为用户级线程</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
<li><strong>重点重点重点</strong>：操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</li>
</ul>
</li>
<li><strong>多对多</strong>模型<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210728172949.png" alt="多对多模型">
<ul>
<li>即提高了并发性，又降低了开销（什么都会就是什么都不会…）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>处理机调度：作业调度（高级调度）、中级调度（内存调度）、进程调度（低级调度、<strong>最基本</strong>）<font color=blue>（重要的是计算）</font>：</p>
<ul>
<li>三层调度的对比<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210729162951.png" alt="三层调度的对比"></li>
<li>不能进行调度的场景：中断处理中、进程进入<strong>内核程序临界区</strong>、其它需要完全屏蔽中断的原子操作过程</li>
<li>剥夺式调度和非剥夺式调度</li>
<li>周转时间：是指从<strong>作业被提交</strong>给系统开始，到<strong>作业完成为止</strong>的这段时间间隔。
<ul>
<li>它包括四个部分
<ol>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</li>
</ol>
</li>
<li><code>（作业）周转时间 = 作业完成时间 – 作业提交时间</code></li>
<li><code>平均周转时间 = 各作业周转时间之和 / 作业数</code></li>
<li><code>带权周转时间 = 作业周转时间 / 作业实际运行时间</code></li>
<li><code>带权平均周转时间 = 带权周转时间 / 作业数</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>调度算法<font color=blue>（重要的是计算）</font>：</p>
<ul>
<li>先来先服务(FCFS)调度算法
<ul>
<li>顾名思义：谁先到谁先被服务</li>
<li>如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109290929702.png" alt="">
<ul>
<li><code>P1、P2、P3、P4</code>依次到达，所以其时序图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109290933835.png" alt=""></li>
<li>周转时间：<code>7-0、11-2、12-4、16-5</code>，平均周转时间8.75</li>
<li>带权周转时间：<code>7/7、9/4、8/1、11/4</code>，平均带权周转时间3.5</li>
<li>等待时间：<code>0、7-2、11-4、12-5</code>，平均等待时间4.75</li>
</ul>
</li>
<li>特点：
<ul>
<li>不会导致饥饿</li>
<li>不可剥夺</li>
<li>长作业有利、短作业不利（排在后面的短作业要等上非常久、但只运行小段时间）</li>
<li><strong>有利千CPU繁忙型作业、不利于I/0繁忙型作业</strong>（I/O作业往往更加紧急）</li>
</ul>
</li>
</ul>
</li>
<li>短作业优先（SJF）算法：
<ul>
<li>短作业优先调度</li>
<li>如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109290929702.png" alt=""></li>
<li>短作业优先调度SJF没什么好说的<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109291702353.png" alt=""></li>
<li>最短剩余时间优先SRTN（剥夺式SJF）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109291703123.png" alt=""></li>
<li>特点：
<ul>
<li>可能“饥饿”</li>
</ul>
</li>
</ul>
</li>
<li>高响应比优先（HRRN）：
<ul>
<li><code>响应比 = （等待时间 + 要求服务时间） / 要求服务时间</code></li>
<li>如图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109291705026.png" alt=""></li>
<li>特点：
<ul>
<li>不会“饥饿”</li>
<li>非抢占式</li>
</ul>
</li>
</ul>
</li>
<li>时间片轮转算法：
<ul>
<li>使用分时系统，使用时间片，就绪进程按照到达先后排成队列，依次在时间片内占用处理机，时间片到就释放</li>
<li>时间片选择很重要，过大就变成了先来先服务，过小就变成了短作业优先</li>
<li>特点：
<ul>
<li>不会导致饥饿</li>
<li>抢占式</li>
</ul>
</li>
</ul>
</li>
<li>优先级调度算法
<ul>
<li>抢占式、非抢占式都有</li>
<li>会导致饥饿</li>
<li>如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109291714349.png" alt="">
<ul>
<li>非抢占式：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109291715863.png" alt=""></li>
<li>抢占式：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109291716006.png" alt=""></li>
</ul>
</li>
<li>补充：
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种。
<ul>
<li>静态优先级：创建进程时确定，之后一直不变。</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。
<ul>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li>
</ul>
</li>
</ul>
</li>
<li>一些常见的系统优先级
<ul>
<li>系统进程优先级<strong>高于</strong>用户进程</li>
<li>前台进程优先级<strong>高于</strong>后台进程</li>
<li>操作系统更偏好<strong>I/O型进程</strong>（或称<strong>I/O繁忙型进程</strong>）
<ul>
<li>这是因为<em>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</em></li>
</ul>
</li>
<li>与I/O型进程相对的是<strong>计算型进程</strong>（或称<strong>CPU繁忙型进程</strong>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多级反馈调度算法：
<ul>
<li>抢占式、会饥饿</li>
<li>算法规则：
<ol>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第k 级队列为空时，才会为k+1 级队头的进程分配时间片</li>
</ol>
</li>
<li>在k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k 级队列队尾。</li>
<li>流程：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108021619391.png" alt="多级反馈队列调度算法">
<ol>
<li><code>P1(8)</code>先到达, 入1级队列. 执行1个单位时间片<code>P1(7)</code>, 进入2级队列.</li>
<li>1时刻<code>P2(4)</code>到达, 入1级队列. 执行1个单位时间片<code>P2(3)</code>, 进入2级队列.</li>
<li>2时刻1级队列为空, 则对2级队列进行调度, <code>P1(7)</code>执行2个单位时间片之后入三级队列<code>P1(5)</code>.</li>
<li>4时刻<code>P2(3)</code>运行到5时刻<code>P2(2)</code>, 此时<code>P3(1)</code>进入, 应该优先调度1级队列, 被剥夺处理机的<code>P2(2)</code>重新放回2级队列.</li>
<li><code>P3(1)</code>运行1个单位时间<code>P3(0)</code>, 完成并结束该进程.</li>
<li><code>P2(2)</code>运行2个时间单位<code>P2(0)</code>, 完成并结束该进程.</li>
<li><code>P1(5)</code>运行4个时间单位<code>P1(1)</code>, 已经位于最下级队列, 回到该队列运行并完成.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程同步、互斥<font color=blue>（理解！！！）</font>：</p>
<ul>
<li>进程同步：直接制约关系，进程间可能需要一种先后顺序或者互相依赖的关系</li>
<li>进程互斥：间接制约关系，当一个进程访问临界资源的时候，其它进程不能访问
<ul>
<li><strong>一段时间内只允许一个进程使用</strong>的资源叫<strong>临界资源</strong></li>
</ul>
</li>
<li>临界区互斥（同步机制实现需尽量遵循）<font color=blue>（重点！！！）</font>：
<ul>
<li>前三个满足“临界区互斥”，最后一个解决“饥饿”
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程互斥的软件实现方法(同步机制) <font color=blue>（理解！！！）</font>：</p>
<ul>
<li><font color=green size=4>单标志法</font><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108021757036.png" alt="单标志法">
<ul>
<li>只能按<code>P0 P1 P0 P1 ……</code>这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</li>
<li>因此，单标志法存在的主要问题是：<strong>违背“空闲让进”原则</strong>。</li>
</ul>
</li>
<li><font color=green size=4>双标志先检查法</font><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042010911.png" alt="双标志先检查法">
<ul>
<li>先检查是否被占用，然后才自己占用</li>
<li>若按照<code>①⑤②⑥③⑦….</code>的顺序执行，<code>P0</code> 和 <code>P1</code> 将会同时访问临界区。(即并发进程中,<code>P0</code>执行while后正要标记数组值,这时发生切换…)</li>
<li>因此，双标志先检查法的<strong>主要问题</strong>是：<strong>违反“忙则等待”原则</strong>。</li>
<li>原因在于，<strong>进入区</strong>的“检查”和“上锁” 两个处理<strong>不是一气呵成</strong>的。“检查”后，“上锁”前可能发生进程切换。</li>
</ul>
</li>
<li><font color=green size=4>双标志后检查法</font><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042021519.png" alt="双标志后检查法">
<ul>
<li>先自己占用，然后才检查是否被占用</li>
<li>若按照<code>①⑤②⑥….</code>的顺序执行，<code>P0</code> 和 <code>P1</code> 将都无法进入临界区</li>
<li>因此，双标志后检查法虽然 <strong>解决了“忙则等待”</strong> 的问题，但是又 <strong>违背了“空闲让进”和“有限等待”</strong> 原则，会因各进程都长期无法访问临界资源而 <strong>产生“饥饿”</strong> 现象。</li>
<li>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</li>
</ul>
</li>
<li><font color=green size=4>Peterson算法</font><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042027612.png" alt="Peterson算法">
<ul>
<li>进入区:
<ol>
<li>主动争取；</li>
<li>主动谦让；</li>
<li>检查对方是否也想使用，且最后一次是不是自己说了“客气话”</li>
</ol>
</li>
<li>Peterson 算法用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然<strong>未遵循让权等待</strong>的原则。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程互斥的硬件实现方法(同步机制) <font color=blue>（理解！！！）</font>：</p>
<ul>
<li>硬件方法无法实现<strong>让权等待</strong>！！！</li>
<li><font color=green size=4>中断屏蔽方法</font>：
<ul>
<li>利用<strong>开/关中断</strong>指令实现(与原语的实现思想相同,从进程开始访问临界区到结束访问为止都不允许中断,也就是不能发生进程切换)  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042055893.png" alt="开/关中断"></li>
<li>优点: 简单、高效</li>
<li>缺点: 不适合多处理机; 只适用于操作系统内核进程,不适用于用户进程(开/关中断指令无法在用户态进行,也不能让用户随意使用)</li>
</ul>
</li>
<li>TestAndSetLock指令（TSL）、Swap指令：硬件实现，不允许中断，必须一气呵成</li>
<li>信号量
<ul>
<li>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 wait(S)和 signal(S)访问， 也可记为 “ P 操作“ 和 “ V 操作“（来自荷兰语proberen 和verhogen）。<strong>其中S即信号量（可以是整型，也可以是复杂的记录型）</strong>。</li>
<li>信号量其实就是一个变量，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量，<code>P： S-- #若S不为0，则可以使用，资源S的量减少1</code>，<code>V： S++ # 资源使用完毕，释放资源，资源量+1</code>。</li>
<li>记录型信号量例子：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042151771.png" alt="">
<ol>
<li>P0申请打印机资源，S–</li>
<li>P0使用打印机时，P1申请，S–</li>
<li>P1使用打印机时，P2申请，S–，但此时<code>S.value = -1</code>，所以将其挂到等待队列中去</li>
<li>P3申请，S–，<code>S.value = -2</code>，挂载到等待队列</li>
<li>此时P0使用完资源，S++，<code>S.value = -1</code>，唤醒等待队列中的一个进程（如P2，将其放入就绪队列，打印机资源分配给它）</li>
<li>这时P2得到处理机，使用资源并释放，S++，<code>S.value = 0</code>，唤醒P3，P3进入就绪队列，打印机资源分配给P3</li>
<li>P3得到处理机，使用资源并释放，S++，因为<code>S.value = 1</code>，所以不需要执行唤醒操作</li>
<li>最后P1得到处理机并使用资源，S++，<code>S.value = 2</code>，不需要执行唤醒操作</li>
</ol>
</li>
<li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value &lt; 0 </code>时表示该类资源已分配完毕，因此进程应<strong>调<br>
用 block原语 进行自我阻塞</strong>（当前运行的进程从<strong>运行态➡阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列S.L 中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</li>
<li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行<code>S.value++</code>，表示资源数加1，若加1后仍是<code>S.value &lt;= 0</code>，表示依然有进程在等待该类<br>
资源，因此应<strong>调用 wakeup原语 唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态➡就绪态</strong>）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>管程<font color=blue>（重要！！！）</font>：</p>
<ul>
<li>用共享数据结构来描述临界资源，如：S是共享数据结构，然后take_away()申请一个资源，give_back()归还一个资源</li>
<li>定义条件变量x，x.wait()表示将自己插入x条件的等待队列（x是否满足条件需要用户自己判断，这里一定会插入），x.signal()表示唤醒一个因为x条件阻塞的进程（一定唤醒，x是否满足条件用户判断）</li>
</ul>
</li>
<li>
<p>信号量机制实现进程同步和互斥：</p>
<ul>
<li>同步：实现进程或代码段的运行“一前一后”<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042253759.png" alt="进程同步"></li>
<li>前驱：拆分成同步问题：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108042258300.png" alt="前驱关系"></li>
<li>认为PV操作中V操作自带唤醒功能!!!不然若多个进程互斥访问临界资源时,信号量负数,即使V操作释放了也依然负数,进程无法继续!!!</li>
</ul>
</li>
<li>
<p>死锁的条件<font color=blue>（重要！！！）</font>：</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又提出了<strong>新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的<strong>循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。
<ul>
<li><strong>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件）</li>
<li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>为什么会发生死锁：<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong>。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://chen0495.top/posts/59e4ca55/">🔗银行家算法🔗</a></p>
</li>
<li>
<p>死锁的检测和解除<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108122017602.png" alt=""></p>
</li>
<li>
<p>解除死锁<font color=blue>（重要！！！）</font>：</p>
<ol>
<li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
</li>
<li>
<p>大题解法：</p>
<ul>
<li>生产消费者问题：前v后p。</li>
<li>理发师问题：理发师=0、顾客=0、空椅子=n、椅子互斥量=1。</li>
<li>读者写者问题：1+n+n；互斥锁lock=1；同类进程计数器count=0；同类进程count互斥锁=1。</li>
<li>哲学家问题：大锁lock=1；a、b、c类型资源=m、n、k；</li>
</ul>
</li>
</ol>
<h1 id="第三章-内存管理"><a class="header-anchor" href="#第三章-内存管理">¶</a>第三章 - 内存管理</h1>
<ol>
<li>
<p>内存管理：</p>
<ul>
<li>程序的装入和链接<font color=blue>（理解！！！）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108122057849.png" alt="链接">
<ol>
<li>编译：编译程序将用户源代码编译成若干目标模块</li>
<li>链接：各个模块和所需要的库函数链接起来（形成完整装入模块、形成逻辑地址）
<ul>
<li>静态链接：程序<strong>运行前</strong>，各模块和所需库函数链接，之后不再拆开</li>
<li>装入时动态链接：<strong>装入过程中</strong>，边装入边链接</li>
<li>运行时动态链接：程序<strong>运行时</strong>，执行中若需要某模块，才进行链接
<ul>
<li>便于修改更新，便于模块共享</li>
</ul>
</li>
</ul>
</li>
<li>装入：模块装入内存（绝对地址）
<ul>
<li><strong>绝对装入</strong>：按照绝对地址寻址
<ul>
<li><em>编译阶段（得到模块的绝对地址）</em></li>
<li><em>只适用于单道程序环境。</em></li>
</ul>
</li>
<li><strong>静态重定位</strong>：又称可重定位装入。按照相对地址寻址
<ul>
<li>装入后物理地址不再改变（固定分区分配）的才能静态重定位</li>
<li><em>装入阶段</em></li>
<li><em>特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</em></li>
</ul>
</li>
<li><strong>动态重定位</strong>：又称动态运行时装入。装入内存后，绝对地址可变，而且程序运行时才进行地址转换。这种方式需要一个重定位寄存器的支持。
<ul>
<li><em>程序执行阶段</em></li>
<li>重定位寄存器：存放装入模块存放的起始位置</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>内存保护
<ol>
<li>CPU中设置上、下限寄存器</li>
<li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。<em>重定位寄存器中存放的是进程（数据）的起始物理地址</em>。<em>界地址寄存器中存放的是进程（数据）的最大逻辑地址</em>。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>连续分配管理方式<font color=blue>（了解）</font>：</p>
<ul>
<li>连续分配（分配一个连续的内存空间）
<ul>
<li>单一连续分配（将内存分为系统区/用户区，系统区存操作系统，<strong>用户区只有一道用户程序</strong>）</li>
<li>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的PC 操作系统MS-DOS）。</li>
<li>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</li>
</ul>
</li>
<li><strong>固定分区分配</strong>
<ul>
<li>分区大小也可以不等，但必须予以规定，即总的来说固定。如：较多小分区、适量中分区、少量大分区</li>
<li>优点：无外部碎片</li>
<li>缺点：程序过大时一个分区不够、主存利用率低、内部碎片</li>
</ul>
</li>
<li><strong>动态分区分配</strong>
<ul>
<li>进程装入时，根据程序大小动态建立分区</li>
<li>程序运行时可以改变物理位置</li>
<li>优点：无内部碎片</li>
<li>缺点：外部碎片（紧凑技术）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>动态分区分配算法<font color=blue>（理解）</font>：</p>
<blockquote>
<p>首次适应算法</p>
<blockquote>
<ul>
<li>思想: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li>
<li>算法: 空闲分区以<strong>地址递增</strong>的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的<strong>第一个空闲分区</strong>。</li>
</ul>
</blockquote>
<p>最佳适应算法</p>
<blockquote>
<ul>
<li>思想: 优先使用能够满足要求的<strong>最小的空闲分区</strong></li>
<li>算法: 空闲分区<strong>按容量递增</strong>次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
</ul>
</blockquote>
<p>最坏(最大)适应算法</p>
<blockquote>
<ul>
<li>思想: 优先使用能够满足要求的<strong>最大的空闲分区</strong>,以使得外部小碎片数量问题得到缓解.</li>
<li>算法: 空闲分区<strong>按容量递减</strong>次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
</ul>
</blockquote>
<p>邻近适应算法</p>
<blockquote>
<ul>
<li>思想: 首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都<strong>从上次查找结束的位置开始检索</strong>，就能解决上述问题。</li>
<li>算法: 空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
</ul>
</blockquote>
<p>总结</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108131510981.png" alt="总结"><br>
<font color=blue size=4><em>综合来看，四种算法中，首次适应算法的效果反而更好</em></font></p>
</blockquote>
</blockquote>
</li>
<li>
<p>分页<font color=blue>（了解）</font>：</p>
<ul>
<li>将内存空间划分为<strong>大小相等的分区</strong>, 每个分区就是一个&quot;<strong>页框</strong>&quot;(= 页框 = 页帧 = 内存块 = 物理块 = 物理页), 页框号从0开始。</li>
<li>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，<strong>页号也是从0开始,与页框号一一对应.</strong>
<ul>
<li><em>逻辑地址分成很多页，页表项 = {页号：物理块号/页框号/内存块号}</em></li>
<li>页表项大小与页面大小没有直接联系！但由页表项大小可以推出逻辑空间大小，间接得出页面大小！
<ul>
<li>认为<code>页面个数 = 页面大小 / 页表项大小</code></li>
</ul>
</li>
</ul>
</li>
<li>页表寄存器（PTR）：<strong>方便将逻辑地址转换为物理地址</strong>。存放页表在内存中的起始地址F 和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器</li>
<li><strong>页表</strong>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301852851.png" alt=""></li>
</ul>
</li>
<li>
<p>快表</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sjxgghg/article/details/107726093">🔗二级页表🔗</a> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301845847.png" alt=""></p>
</li>
<li>
<p>分段存储：分段大小不定,分页大小固定.</p>
<ul>
<li>段表：每个进程都有一张逻辑空间与内存空间的映射的段表，每个段表项对应进程的一段，段表项记录了该段在内存中的始址和长度<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301854406.png" alt="">
<ul>
<li><code>段表内容 = 段号（隐含）、段长、本段在主存中的位置</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>段页式管理</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分页管理</td>
<td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td>
<td>不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>很方便按照逻辑模块实现信息的共享和保护</td>
<td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>虚拟内存<font color=blue>（了解）</font>：<br>
虚拟存储技术和交换技术很像，乍一看都是换入换出，把暂时不需要用的数据换出内存，将需要用到的数据换入内存，从而实现逻辑上内存的扩充。二者之间的区别是，虚拟存储技术是在一个作业运行的过程中，将作业的数据进行换入换出。王道老师举得例子就是玩儿游戏。这儿换一个游戏，比如玩儿DOTA，停留在场景A的时候，场景B的数据不需要用到，所以不放在内存，转换到场景B的时候再把场景B的数据放入内存。而交换技术是内存紧张时，换出某些进程，腾出内存空间，换入其他进程。换而言之，交换技术是在不同的进程（作业）间的，虚拟存储技术是在一个作业间的。另外提一嘴，覆盖技术也是在同一个程序或进程中的。<br>
引用一个大哥的话，“<strong>交换技术是以进程为单位</strong>，若进程所需内存大于系统内存 ，则此进程无法进行。而<strong>虚拟存储是以页或段为单位</strong>，是把进程再分为页或段对内存进行分化，若进程所需内存大于系统内存，进程也可以运行，因为该进程的一部分可换到外存上”，这个总结的挺好的。(否则我以4G的老年机怎么可能运行十几G的游戏23333)</p>
</li>
<li>
<p>请求分页管理方式<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108141422518.png" alt="请求分页"></p>
<ul>
<li>缺页时，请求从外存上调入缺失的页。</li>
</ul>
</li>
<li>
<p>页面置换算法<font color=blue>（理解！！！）</font>：</p>
<blockquote>
<p>最佳置换算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108141434736.png" alt="最佳置换算法"></p>
</blockquote>
<p>先进先出置换算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108141438152.png" alt="先进先出置换算法"><br>
只有先进先出算法会产生<strong>Belady异常</strong>, 即可用内存块增加, 缺页次数反而增加的现象.</p>
</blockquote>
<p>最近最久未使用置换算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108141443127.png" alt="最近最久未使用置换算法"></p>
</blockquote>
<p>时钟置换算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108141456296.png" alt="时钟置换算法"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108141510606.png" alt="改进时钟置换算法"></p>
</blockquote>
</blockquote>
</li>
<li>
<p>页面分配策略和调页时机<font color=blue>（重要！）</font>：</p>
<ul>
<li>页面分配策略（物理块数即页框数、驻留集大小）：
<ul>
<li>固定分配全局置换<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301907172.png" alt=""></li>
<li>可变分配全局置换<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301909268.png" alt=""></li>
<li>可变分配局部置换<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301909435.png" alt=""></li>
</ul>
</li>
<li>调页时机：
<ul>
<li>预调页策略：把预计不久将被访问的页面调入，成功率55开</li>
<li>请求调页：进程提出缺页时，才调入</li>
</ul>
</li>
<li>调页来源：
<ul>
<li>对换区充足：从对换区调入可以提高速度</li>
<li>对换区不足：不会被修改的文件从文件区调入，可能被修改的文件换入对换区，再从对换区调入</li>
<li>UNIX方式：进程相关文件访问文件区，没有运行的页面从文件区调入，曾经运行过但被换出的页面放在对换区</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="第四章-文件管理"><a class="header-anchor" href="#第四章-文件管理">¶</a>第四章 - 文件管理</h1>
<ol>
<li>
<p>文件的结构：数据项（描述某个属性的值，如文件大小是10KB、文件名是1.txt等）、记录（一组相关数据项的集合，如一个文件包含文件名、后缀名/格式、大小等）、文件（有结构文件、无结构文件）</p>
<ul>
<li><code>数据项 ➡ 记录 ➡ 文件</code></li>
</ul>
</li>
<li>
<p>文件的属性：名称、标识符（计算机识别的唯一标签，用户不可见）、类型（格式）、位置、大小、保护、其它（时间、日期、归属用户等标识）</p>
</li>
<li>
<p>文件控制块和索引节点<font color=blue>（理解！！！）</font>：</p>
<ul>
<li>文件控制块（FCB）：用来存放控制文件需要的各种信息的数据结构，实现“按名存取”
<ul>
<li>包含：基本信息（文件名、文件物理位置、逻辑结构、物理结构等）、存取控制信息（文件存取权限、安全）、使用信息（文件建立信息、修改时间）</li>
</ul>
</li>
<li>索引节点（检索文件时，不需要将文件调入内存，而只是查找由目录项、文件描述信息等形成的叫做索引节点的数据结构）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108161617195.png" alt="索引节点">
<ul>
<li>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</li>
<li>磁盘索引节点：文件主标识符、文件类型（目录、文件、ISO）、文件存取权限、文件物理地址、文件大小、<strong>文件链接计数（文件系统中指向该文件的快捷方式等）</strong>，文件存取/修改时间</li>
<li>文件打开后索引节点增加的信息：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109301957667.png" alt=""></li>
</ul>
</li>
<li>索引表查找到的是逻辑地址</li>
</ul>
</li>
<li>
<p>文件共享<font color=blue>（理解！！！）</font>：</p>
<ul>
<li>基于索引节点的共享（硬链接）：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302016546.png" alt=""> 如共享文件<code>D:\MATH\1.txt</code>的物理地址及其它文件信息不再放在目录项当中，而是放在索引结点当中（目录项中关于该文件就只会有：文件名、指向改索引结点的指针）。需要共享给其它文件夹<code>D:\ENGLISH\ </code>时在文件目录里增加一项指针指向那个索引节点即可<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302016761.png" alt=""></li>
<li>基于符号链的共享（软连接）：创建一个<strong>快捷方式</strong>（内含原文件路径），将快捷方式加入要共享到的路径下即可</li>
</ul>
</li>
<li>
<p>目录的实现：线性列表（文件名：文件指针）、哈希表（哈希值：文件指针）</p>
</li>
<li>
<p>文件的逻辑结构</p>
<ul>
<li>无结构文件(流式文件)：.txt .jpg等，往往以字节为单位存储。</li>
<li>有结构文件(记录文件)：.csv .xls等，往往以记录为单位存储。
<ul>
<li>顺序文件：每个记录都是一个定长的数据，每个记录之间没有任何的间隔。
<ul>
<li>串结构：记录没有特定顺序</li>
<li>顺序结构：记录按照特定顺序存储，可采用折半查找</li>
</ul>
</li>
<li>索引文件：采用索引表，每个表项为<code>长度 记录指针</code></li>
<li>索引顺序文件：采用索引表，每个表项为<code>组名 记录指针</code>，分组按顺序排列，组内无序，组间有序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件的物理结构（文件分配）<font color=blue>（重点！！！）</font>：</p>
<ul>
<li>连续分配<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302024434.png" alt="">
<ul>
<li>记录文件的<strong>起始块号</strong>和<strong>长度</strong></li>
<li>支持顺序访问和随机(直接)访问</li>
<li>连续分配的文件块物理相邻,所以方便磁盘读取</li>
<li>不方便文件的拓展(当前连续分配块之后的空闲地址块可能不够)</li>
<li><strong>存储空间利用率低,产生磁盘碎片</strong></li>
</ul>
</li>
<li>链接分配
<ul>
<li><em>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</em></li>
<li><strong>隐式链接</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302025602.png" alt="">
<ul>
<li>记录<strong>起始块号</strong>和<strong>结束块号(或者长度)</strong>,</li>
<li><strong>每个磁盘块(除最后)都保存有一个指针指向下一个盘块</strong>.</li>
<li>只支持顺序访问,查找效率低</li>
<li>不会产生碎片问题、方便拓展文件</li>
<li>指针也要占用盘块少量空间</li>
</ul>
</li>
<li><strong>显式链接</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302027061.png" alt="">
<ul>
<li>将隐式链接盘块尾的指针用文件分配表(FAT)来表示，文件分配表记录了所有磁盘块的分配情况，开机时放入内存</li>
<li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li>
<li>缺点：文件分配表的需要占用一定的存储空间。</li>
</ul>
</li>
</ul>
</li>
<li>索引分配<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302030928.png" alt="">
<ul>
<li>FAT表记录了所有盘块的文件分配情况，但我们希望随文件打开再将索引表放入内存。</li>
<li>在显示链接的基础上，将文件分配表变成索引块存在盘块上，目录信息直接指向索引盘块</li>
<li>每个文件都有一个文件索引表，文件FCB记录了文件索引表所在的盘块号(索引块)，索引块中第i项指向该文件的第i块。</li>
<li>优化方式：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302036504.png" alt=""></li>
</ul>
</li>
<li>文件分配方式比较<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302032592.png" alt=""></li>
</ul>
</li>
<li>
<p>空闲空间管理<font color=blue>（重点！！！）</font>：</p>
<ul>
<li><strong>空闲表法</strong>: <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302038406.png" alt=""></li>
<li><strong>空闲链表法</strong>: <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108162121777.png" alt="">
<ul>
<li>空闲盘块链</li>
<li>空闲盘区链</li>
</ul>
</li>
<li><strong>位示图法</strong>: <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108162130254.png" alt=""></li>
<li><strong>成组链接法</strong>: <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302043678.png" alt="">
<ul>
<li>把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区则保存另一顺序扇区的地址，如此继续，直到所有空闲扇区都链接上</li>
<li>超级块：一般放在卷头，开机时超级块会被读入到主存，并保持主存和辅存超级块的一致性。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>虚拟文件系统VFS：用于解决不同文件系统(u盘FAT、移动硬盘NTFS)间的差异性</p>
<ul>
<li>向上层用户进程提供统一标准的系统调用接口</li>
<li>要求下层文件系统(u盘FAT、移动硬盘NTFS)支持VFS(否则用不了)</li>
<li>为解决不同文件系统文件结构不同的问题，为每个打开的文件创建一个vNode，vNode中保存了文件的所有信息，且指向对应下层文件系统的函数列表<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img2022/202208232133181.png" alt=""></li>
</ul>
</li>
<li>
<p>磁盘的结构<font color=blue>（理解）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171506931.png" alt="磁盘的结构"></p>
<ul>
<li>磁盘以簇为分配单位进行空间分配!</li>
<li><strong>寻找时间（寻道时间）T_s</strong>：在读/写数据前，将磁头移动到指定磁道所花的时间
<ol>
<li>启动磁头臂是需要时间的。假设耗时为s；</li>
<li>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间<code>T_s = s + m * n</code></li>
</ol>
</li>
<li><strong>延迟时间T_r</strong>：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（单位：转/秒，或转/分），则平均所需的延迟时间<code>T_r = (1/2)*(1/r) = 1/2r</code></li>
<li><strong>传输时间T_t</strong>：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。则：传输时间<code>T_t = (1/r) * (b/N) = b/(rN)</code></li>
<li><font color=blue size=4>可以看到操作系统唯一能够影响的只有寻道时间, 所以寻道算法很重要…</font></li>
</ul>
</li>
<li>
<p>磁盘调度算法<font color=blue>（重点！！！）</font>：</p>
<blockquote>
<p>先来先服务(FCFS)</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171519677.png" alt="先来先服务"></p>
</blockquote>
<p>最短寻找时间优先(SSTF)</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171520001.png" alt="最短寻找时间优先"></p>
</blockquote>
<p>扫描算法(SCAN)</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171521264.png" alt="扫描算法"></p>
</blockquote>
<p>LOOK调度算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171524120.png" alt="LOOK调度算法"></p>
</blockquote>
<p>C-SCAN算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171527604.png" alt="C-SCAN算法"></p>
</blockquote>
<p>C- LOOK算法</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171528987.png" alt="CLOCK算法"></p>
</blockquote>
</blockquote>
</li>
<li>
<p>减少磁盘延迟时间的方法：扇区交替编号，因为磁头在读/写完一个数据块时（往往是一个扇区），需要经过短暂的处理时间才能继续读/写下一块</p>
</li>
<li>
<p>磁盘的管理</p>
<ul>
<li>磁盘初始化: <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108171551683.png" alt="磁盘初始化">
<ul>
<li>物理(低级)格式化：划分扇区、扇区校验码、分区</li>
<li>逻辑格式化：创建文件系统、根目录、初始化存储空间管理的数据结构（位示图、空闲分区表）</li>
</ul>
</li>
<li>引导块: <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302057927.png" alt=""></li>
<li>坏道</li>
</ul>
</li>
<li>
<p>固态硬盘SSD</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img2022/202208232206920.png" alt=""></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img2022/202208232209881.png" alt=""></li>
</ul>
</li>
</ol>
<h1 id="第五章-I-O管理"><a class="header-anchor" href="#第五章-I-O管理">¶</a>第五章 - I/O管理</h1>
<ol>
<li>
<p>I/O设备分类<font color=blue>（了解）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302059335.png" alt=""></p>
<ul>
<li>块设备。<strong>以数据块为存取单位</strong>，属于<strong>有结构</strong>设备。传输速率<strong>高</strong>，<strong>可寻址（随机读写）</strong>。
<ul>
<li>硬盘、蓝光光盘、U盘</li>
</ul>
</li>
<li>字符设备。<strong>以字符为存取单位</strong>，属于<strong>无结构</strong>设备。传输速率<strong>低</strong>，<strong>不可寻址（不可随机读写）</strong>
<ul>
<li>打印机、网络设备、鼠标以及大多数与磁盘不同的设备</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I/O控制方式<font color=blue>（理解！！！）</font>：</p>
<ul>
<li><strong>程序直接控制方式</strong>：每次读一个字的数据，对读入的每个字，CPU都要对外设状态循环检查<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302106898.png" alt="">
<ul>
<li>读写单位：<strong>字</strong></li>
<li>优点：简单</li>
<li>缺点：CPU全程负责I/O设备，效率极低。CPU和I/O只能串行</li>
</ul>
</li>
<li><strong>中断驱动方式</strong>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302111116.png" alt="">
<ul>
<li>读写单位：<strong>字</strong></li>
<li>优点：CPU效率比程序直接控制高</li>
<li>缺点：数据的传输需要经过CPU，仍然消耗CPU的时间</li>
</ul>
</li>
<li><strong>DMA方式</strong>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302114733.png" alt="">
<ul>
<li>读写单位：<strong>数据块</strong></li>
<li>在I/O设备和内存间开辟数据通路，彻底解放CPU</li>
<li>设备直接送入内存</li>
<li>只有当一个或多个数据块开始/结束时，CPU才会干预</li>
<li>DMA控制器的组成：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302117102.png" alt="">
<ul>
<li>命令/状态寄存器（CR）。用来接收CPU发来的控制信息，或设备的状态</li>
<li>内存地址寄存器（MAR）。输入时，存放数据将要放到内存的起始目标地址；输出时，存放数据由内存到设备的内存源地址。</li>
<li>数据寄存器（DR）。暂存设备到内存或内存到设备的数据</li>
<li>数据寄存器（DC）。记录本次要传输的字（节）数</li>
</ul>
</li>
</ul>
</li>
<li><strong>通道控制方式</strong>：设置一个专门负责I/O的处理机，这个处理机就叫通道
<ul>
<li>读写单位：一组数据块</li>
<li>优点：完全解放CPU，通道只需要接收CPU的I/O任务即可</li>
<li>缺点：实现复杂</li>
</ul>
</li>
<li>DMA与通道的区别：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302126090.png" alt=""></li>
</ul>
</li>
<li>
<p>I/O软件的层次结构<font color=blue>（了解）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108172209009.png" alt=""></p>
<ul>
<li>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。
<ul>
<li>向上层提供统一的调用接口（如read/write系统调用）</li>
<li>设备的保护</li>
<li>差错处理</li>
<li>设备分配与回收</li>
<li>数据缓冲区管理</li>
<li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</li>
</ul>
</li>
<li>设备驱动程序
<ul>
<li>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等</li>
</ul>
</li>
<li>中断处理程序</li>
</ul>
</li>
<li>
<p>设备控制器的组成<font color=blue>（了解）</font>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302129560.png" alt=""></p>
</li>
<li>
<p>I/O调度：</p>
<ul>
<li>通过I/O调度改善系统整体性能，使得进程之间公平共享设备访问，减少I/O的平均等待时间</li>
<li>使用主存或者磁盘上的存储空间的技术，如：缓存、高速缓存、假脱机等改善计算机效率</li>
</ul>
</li>
<li>
<p>磁盘高速缓存和缓冲区<font color=blue>（重点！！！）</font>：</p>
<ul>
<li>磁盘高速缓存：
<ul>
<li>逻辑上属于磁盘，物理上属于驻留在内存中的盘</li>
<li>在内存中的两种形式：
<ul>
<li>在内存中开辟出一个单独的存储空间，大小固定</li>
<li>未利用的内存空间作为缓冲池，供请求分页系统和磁盘I/O共享</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区：
<ul>
<li>缓和CPU与I/O之间的速度差异矛盾、提高CPU与I/O的并行度、减少CPU中断的频率、解决基本数据单元大小不匹配问题</li>
<li>实现：
<ul>
<li>硬件缓冲器（成本过高）</li>
<li>内存缓冲区</li>
</ul>
</li>
<li>分类：
<ul>
<li>单缓冲：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302142194.png" alt="">
<ul>
<li><code>T：I/O ➡ 缓冲区</code>，<code>M：缓冲区 ➡ 用户区</code>，<code>C：CPU处理</code></li>
<li>使用时间<code>MAX(C , T) + M</code></li>
</ul>
</li>
<li>双缓冲：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302145928.png" alt="">
<ul>
<li>使用时间<code>MAX(C + M , T)</code></li>
</ul>
</li>
<li>循环缓存：包含多个大小相等的缓冲区，通过指针首位相连形成环状。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108172252635.png" alt=""></li>
<li>缓冲池：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302149489.png" alt="">
<ul>
<li>缓冲区分为三个队列：空缓冲、输入缓冲、输出缓冲。</li>
<li>缓冲池包含四种缓冲区：收容输入、收容输出、提取输入、提取输出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>高速缓存和缓冲区的对比：
<ul>
<li>相同点：速度都介于高速设备和低速设备之间</li>
<li>不同点：
<ul>
<li>数据来源：高速缓存存放的是低速设备上的某些数据的复制；缓冲区存放的是低速设备传给高速设备的数据</li>
<li>数据目标：高速缓存放的是高速设备经常要访问的（低速设备）数据，若高速缓存中没有，高速设备就直接访问低速设备；高速设备和低速设备的双向通信都经过缓冲区，高速设备永远不会直接访问低速设备
<ul>
<li>数据流向：<code>高速设备 ⬅ 高速缓存 ⬅ 低速设备</code>、<code>高速设备 ↔ 缓冲区 ↔ 低速设备</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设备分配的数据结构<font color=blue>（了解、类比Windows的设备管理器！！！）</font>：</p>
<ul>
<li>设备控制表（DCT）：一个设备控制表对应一个设备，控制表是设备的各项属性<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302157427.png" alt=""></li>
<li>控制器控制表（COCT）：记录某个设备控制器的具体信息<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302159626.png" alt=""></li>
<li>通道控制表（CHCT）：记录某个通道设备的具体信息<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202109302201205.png" alt=""></li>
<li>系统设备表（SDT）：记录已经连接到系统的所有物理设备的情况</li>
</ul>
</li>
<li>
<p>设备分配的策略（发挥效率，避免死锁）：</p>
<ul>
<li>静态：设备一次性分配给相应的作业，直到作业结束
<ul>
<li>没有死锁，但设备利用率低</li>
</ul>
</li>
<li>动态：进程执行过程中根据需要进行分配
<ul>
<li>设备利用率高，但算法不当会导致死锁</li>
</ul>
</li>
<li>独占设备一般静态分配，共享设备一般动态分配。</li>
</ul>
</li>
<li>
<p>设备分配的安全性：</p>
<ul>
<li>安全分配方式：进程发出I/O请求后立即阻塞（无条件），I/O完成后唤醒
<ul>
<li>CPU和I/O设备串行工作</li>
</ul>
</li>
<li>不安全分配方式：进程发出I/O请求后继续运行，需要时发出第二个、第三个请求
<ul>
<li>进程推进速度快，但可能产生死锁</li>
</ul>
</li>
</ul>
</li>
<li>
<p>假脱机技术（SPOLLing）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202108172224131.png" alt="假脱机技术"></p>
<ul>
<li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</li>
</ul>
<ol>
<li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li>
<li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</li>
</ol>
</li>
<li>
<p>设备分类：独占设备、共享设备、虚拟设备。</p>
<ul>
<li><strong>独占设备</strong>: 一个时段只能分配给一个进程（如打印机）</li>
<li><strong>共享设备</strong>: 可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li>
<li><strong>虚拟设备</strong>: 采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使<br>
用（如采用SPOOLing技术实现的共享打印机）</li>
</ul>
</li>
</ol>
<h1 id="新考点"><a class="header-anchor" href="#新考点">¶</a>新考点</h1>
<ol>
<li>用户进程<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202112150951671.png" alt=""></li>
<li>分层操作系统<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202112150955141.png" alt="">
<ul>
<li>便于维护,增加一层</li>
<li>难以定义层边界</li>
</ul>
</li>
<li>模块操作系统<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202112150957787.png" alt=""> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202112150958580.png" alt=""></li>
<li>外核<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202112151002193.png" alt=""></li>
<li>虚拟机<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/202112151008724.png" alt="">
<ol>
<li>第一类虚拟机管理程序: 内核态</li>
<li>虚拟机: 用户态(以为自己在内核态)</li>
<li>第二类虚拟机即我们常用的虚拟机软件,第一类虚拟机会直接管理硬件.第二类虚拟机管理程序运行在用户态</li>
</ol>
</li>
<li>操作系统引导: 运行RAM自举程序,将操作系统内核部分从磁盘加载到内存.</li>
<li>虚拟文件系统: 操作系统可能有多个文件系统,其调用的接口各不相同,因此引入虚拟文件系统VFS,用户进程只需使用VFS提供的接口,VFS负责文件操作和将结果返回给用户进程</li>
</ol>
<h1 id="tool"><a class="header-anchor" href="#tool">¶</a>tool</h1>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">四号绿: &lt;font color=green size=4&gt;&lt;/font&gt;</span><br><span class="line">四号红: &lt;font color=red size=4&gt;&lt;/font&gt;</span><br><span class="line">红:    &lt;font color=red&gt;&lt;/font&gt; </span><br><span class="line">绿:    &lt;font color=green&gt;&lt;/font&gt;</span><br><span class="line">蓝:    &lt;font color=blue&gt;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">分割线:  </span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line"></span><br><span class="line">表格:  </span><br><span class="line">|        |      |       |</span><br><span class="line">| ----- | --:  | :----: |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line">|       |       |       |</span><br><span class="line"></span><br><span class="line">拼图</span><br><span class="line">&#123;% gi 2 2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endgi %&#125;</span><br><span class="line"></span><br><span class="line">便签：  </span><br><span class="line">&#123;% note success %&#125;  </span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">链接:  </span><br><span class="line">🔗</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Chen0495.github.io">Chen0495</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chen0495.github.io/posts/4c949373/">https://chen0495.github.io/posts/4c949373/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Chen0495.github.io" target="_blank">Chen0495的空间站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://img.chen0495.top/img/20210701210018.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/88a8eec7/" title="计算机组成原理补充疑难点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210701205946.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机组成原理补充疑难点</div></div></a></div><div class="next-post pull-right"><a href="/posts/a01c1709/" title="计算机网络考研复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210701210022.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络考研复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/645157d/" title="微分方程求解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210508174605.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-17</div><div class="title">微分方程求解</div></div></a></div><div><a href="/posts/865e512f/" title="平衡二叉树的插入与调整"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210508174402.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-28</div><div class="title">平衡二叉树的插入与调整</div></div></a></div><div><a href="/posts/f8bc8215/" title="概率论笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.chen0495.top/img/20210508174556.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-21</div><div class="title">概率论笔记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 - 计算机系统概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第二章 - 进程管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第三章 - 内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">第四章 - 文件管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-I-O%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第五章 - I&#x2F;O管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E8%80%83%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">新考点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tool"><span class="toc-number">7.</span> <span class="toc-text">tool</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/chen0495/newpicgo/img2022/202207290206838.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Chen0495</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://chen0495.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'waline-cb3yck4r1-chen0495.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, {"placeholder":"说些什么吧QAQ","meta":["nick","mail","link"],"emoji":["https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili"],"search":false,"wordLimit":200,"pageSize":10}))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://unpkg.com/@waline/client/dist/waline.css').then(() => {
      getScript('https://unpkg.com/@waline/client/dist/waline.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-show-text" src="https://unpkg.com/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>